Changes from Kawa 1.6.55 to 1.6.57
==================================
A new command-line flag --server PORT specifies that Kawa should run
as a telnet server on the specified PORT, creating a new read-eval-print
loop for each connection.  This allows you to connect using any
telnet client program to a remote "Kawa server".

A new front-end program, written in C, that provides editing of
input lines, using the GNU readline library.  This is a friendlier
interface than the plain "java kawa.repl".  However, because kawa.c
needs readline and suitable networking library support, it is not
built by default, but only when you configure Kawa with the
--enable-kawa-frontend flag.

The way Scheme names are mapped ("mangled") into Java identifiers
is now more natural.  E.g. "foo-bar?" now is mapped to "isFooBar".

New syntax (object (SUPERS ...) FIELD-AND-METHODS ...) for creating
a new object instance of an anonymous class.  Now fairly powerful.

New procedures field and static-field for more convenient field access.

Syntactic sugar:  (lambda ARGS <TYPE> BODY) -> (lambda ARGS (as <TYPE> BODY)).
This is especially useful for declaring methods in classes.

A new synchonized form allows you to synchronize on an arbitrary Java
object, and execute some forms while having an exclusive lock on the
object.  (The syntax matches that used by Skij.)

Changes from Kawa 1.6.53 to 1.6.55
==================================
New --debug-dump-zip option writes out a .zip file for compilation.
(Useful for debugging Kawa.)

You can now declare parameter types.

Lot of work on more efficient procedure representation and calling
convention:  Inlining, directly callable statics method, plus some
procedures no longer generate a separate Class.

Local functions that are only called from one locations, except for
tail-recursion, are now inlined.  This inlines do loops, and most
"named let" loops.

New representation of closures (closures with captured local variables).
We no longer use an array for the closure.  Instead we store the captured
variables in the Procedure itself.  This should be faster (since
we can use field accesses rather than array indexing, which requires
bounds checking), and avoids a separate environment object.

If the compiler sees a function call whose (non-lexically-bound) name
matches an existing (globally-defined) procedure, and that procedure
instance has a static method named either "apply" or the mangled
procedure name, them the compiler emits a direct call to that method.
This can make a very noticable speed difference, though it may
violate strict Scheme sementics, and some code may break.

Partial support for first-class "location" variables.

Changes from Kawa 1.6.53 to 1.6.54
==================================
Created new packages gnu.mapping and gnu.expr.  Many classes were
moved from kawa.lang to the new packages.
(This is part of the long-term process of splitting Kawa into more
manageable chunks, separating the Scheme-specific code from the
language-independent code, and moving classes under the gnu hierarchy.)

You can now write keywords with the colon first (e.g. :KEYWORD),
which has exactly the same effect and meaning as putting the colon
last (e.g. KEYWORD:).  The latter is preferred is being more consistent
with normal English use of punctuation, but the former is allowed
for compatibility with soem other Scheme implementations and Common Lisp.

Changes from Kawa 1.6.52 to 1.6.53
==================================
The new package gnu.text contains facilities for reading, formatting,
and manipulating text.  Some classes in kawa.lang where moved to there.

Added string-upcase!, string-downcase!, string-capitalize!, string-upcase,
string-downcase, and string-capitalize;  compatible with Slib.

Character constants can now use octal notation (as in Guile).
Writing a character uses octal format when that seems best.

A format function, similar to that in Common Lisp (and Slib) has been
added.

The default parameter of a #!optional or #!key parameter can now be #!null.

Changes since Kawa 1.6.51
=========================
The "record" feature has been changed to that a "record-type descriptor"
is now a gnu.bytecode.ClassType (a <record-type>), rather than a
java.lang.Class.  Thus make-record-type now returns a <record-type>,
not a Class, and record-type-descriptor takes a <record-type>,
not a Class.

More robust Eval interfaces.

New Lexer abstract class.  New ScmRead class (which extends Lexer)
now contains the Scheme reader (moved from Inport).
Now read errors are kept in queue, and can be recovered from.

Comparing an exact rational and an inexact real (double) is now done
as if by first converting the double to exact, to satisfy R5RS.

Changes since Kawa 1.6.1
========================
The compile virtual method in Expression now takes a Target object,
representing the "destination".  The special ConditionalTarget is
used to evaluate the test of an 'if expression.  This allows us to
generate much better code for and, or, eq?, not and nested if
inside an if.

Added port-line, port-column, and set-port-line! to match Guile.

The Makefiles have been written so all out-of-date .java (or .scm).
files in a directory are compiled using a single invocation of
javac (or kawa).  Building Kawa should now be much faster.
(But note that this depends on unreleased recent autoamke changes.)

How the Kawa version number is compiled into Kawa was changed
to make it easier for people who want to build from source on
non-Unix-like systems.

A new gnu.ecmascript package contains an extremely incomplete implementation
of ECMSScript, the ECMA standardized version of JavaScript.  It includes
an ECMAScript lexer (basically complete), parser (the framework is
there but most of the language is missing), incomplete expression evaluation,
and a read-eval-print-loop (for testing only).

Changes in Kawa 1.6.1
=====================
Improved Kawa home page with extra links, pointer to Java-generated api docs,
and homepages for gnu.math and gnu.bytecode.

Implemented system, make-process, and some related procedures.

Added macros for primitive access to object fields, static fields, and
Java arrays.  Added constant-fold syntax, and used it for the other macros.

The --main flag compiles Scheme code to an application (containing a main
method), which can be be invoked directly by a Java interpreter.

Implemented --version (following GNU standards) as kawa.repl command-line flag.

Changes since Kawa 1.5.93
=========================
Adding make procedure to create new objects/records.

Extended (set! (f . args) value) to be equivalent to ((setter f) value . args).
Implemented setter, as well as (setter car) and (setter cdr).

Can now get and set a record field value using an application:
(rec 'fname) gets the value of the field named fname in record rec.
(set! (rec 'fname) value) sets the value of the field named fname in rec.

A partial re-write of the implementation of input ports and the Scheme
reader, to fix some problems, add some features, and improve performance.

Compiled .class files are now installed in $(datadir)/java,
rather than $(prefix)/java.  By default, that means they are
installed in /usr/local/shared/java, rather than /usr/local/java.

There is now internal infrastructure to support inlining of
procedures, and general procedure-specific optimized code
generation.

There is better testing that the right number of arguments are
passed to a procedure, and better error messages when you don't.
If the procedure is inlined, you get a compile-time error message.

The functions created by primitive-constructor, primitive-virtual-method,
primitive-static-method, and primitive-interface-method are now
first-class procedure values.  They use the Java reflection facily,
except when the compiler can directly inline them (in which case
it generates the same efficient bytecodes as before).

New functions instance? (tests type membership) and as (converts).

The kawa.html is now split into several files, one per chapter.
The table of contents is now kawa_toc.html.

The syntactic form try-catch provides low-level exception
handler support.  It is basically the same as Java's try/catch
form, but in Scheme syntax.  The new procedure primitive-throw
throws an exception object.

The higher-level catch and throw procedures implement
exception handling where the handler is specified with a "key"
(a symbol).  These functions were taken from Guile.

The error function has been generalized to take multiple arguments
(as in Guile).  It is now a wrapper around (throw 'misc-error ...).

There is a new "friendly" GUI access to the Kawa command-line.
If you invoke kawa.repl with the -w flag, a new interaction
window is created.  This is uses the AWT TextArea class.  You can
create multiple "consoles".  They can either share top-level
enevironments, or have separate environments.  This window
interface has some nice features, including editing.  Added a
scheme-window procedure, which is another way to create a window.

Changes since Kawa 1.5
======================
The default prompt now shows continuations lines differently.

The copy-file function was added.

The variable port-char-encoding controls how external files
are converted to/from internal Unicode characters.  It also
controls whether CR and CR-LF are converted to LF.

The reader by default no longer down-cases letters in symbols.
A new variable symbol-read-case control how case is handled:
'P (the default) preserves case;  'U upper-cases letters;
'D or -" down-cases letters; and 'I inverts case.

The gnu.bytecode package now supports exception handlers.
The new syntactic form try-finally supports a cleanup hook that is run
after some other code finishes (normally or abnormally).
Try-finally is used to implement dynamic-wind and fluid-let.

The environment handling has been improved to support thread-specific
environments, a thread-safe fluid-let, and multiple top-levels.
(The latter still needs a bit of work.)

The gnu.bytecode package has been extensively changed.
There are new classes representing the various standard Attributes,
and data associated with an attribute is now stored there.

Added new procedures environment-bound? and scheme-implementation-version.

Scheme symbols are represented as java.lang.String objects.
Interned symbols are interned Strings;  uninterned symbols are
uninterned Strings.  Note that Java strings literals are
automatically interned in JDK 1.1.  This change makes symbols
slightly more efficient, and moves Kawa closer to Java.

Ports now use the JDK 1.1 character-based Reader and Writer classes,
rather than the byte-oriented InputStream and OutputStream classes.
This supports different reading and writing different character
encodings [in theory - there is no support yet for other than Ascii
or binary files].

An interactive input port now has a prompt function associated with it.
It is settable with set-input-port-prompter!.  The prompt function
takes one argument (the input port), and returns a prompt string.
There are also user functions for inquiring about the current line
and column number of an input port.

The R4RS procedures transcript-on and transcript-off are implemented.

Standard types can be referred to using syntax similar to RScheme.
For example Scheme strings now have the type <string> which is
preferred to "kawa.lang.FString" (which in addition to being longer,
is also more suspectible to changes in internal implementation).
Though these types are first-class values, this is so far mainly
useful for invoking primitive methods.

Changes from Kawa 1.4 to 1.5
============================
Execute a ~/.kawarc.scm file on startup, if it exists.

Add a number of functions for testing, renaming, and deleting files.
These are meant to be compatible with scsh, Guile, and MIT Scheme:
file-exists?, file-directory?, file-readable?, file-writable?, delete-file,
rename-file, create-diretory, and the variable home-directory.

Fixed some small bugs, mainly in gnu.math and in load.

Generalize apply to accept an arbitrary Sequence, or a primitive Java array.

Changes from Kawa 1.2 to 1.4
============================
The codegen package has been renamed gnu.bytecode.
The kawa.math package has been moved to gnu.math.
Both packages have new license:  No restrictions if you use an
unmodified release, but GNU General Public License.  Let me know
if that causes problems.  The rest of Kawa still has the old license.

Implement defmacro and gentemp.

Implement make-record-type and related functions to create and use
new record types.  A record type is implemented as a java.lang.Class
object, and this feature depends on the new reflection features of JDK 1.1.

Implement keywords, and extend lambda parameter lists to support
#!optional #!rest and #!keyword parameters (following DSSSL).

Added more primitives to call arbitrary interface and constructor methods.

Changes from Kawa 1.0 to 1.2
============================

Added primitives to make it easy to call arbitrary Java methods
from Scheme.

Exact rational arithetic is now fully implemented.
All integer functions now believed to correctly handle bignums.
Logical operations on exact integers have been implemented.
These include all the logical functions from Guile.

Complex numbers are implemented (except {,a}{sin,cos,tan}).
Quantities (with units) are implemented (as in DSSSL).

Eval is available, as specified for R5RS.
Also implemented are scheme-report-environment, null-environment, and
interaction-environment.

Internal define is implemented.

Rough support for multiple threads is implemented.

Moved kawa class to kawa/repl.  Merged in kawac (compiler)
functionality.  A 'kawa' shell-script is now created.
This is now the preferred interface to both the interactive
evaluator and the compiler (on Unix-like systems).

Now builds "without a snag" using Cafe 1.51 under Win95.
(Symantec JIT (ver 2.00b19) requires disabling JIT - JAVA_COMPCMD=disable.)
Compiles under JDK 1.1 beta (with some warnings).

A testsuite (and testing framework) was added.

Documentation moved to doc directory.
There is now an internals overview, in doc/kawa-tour.ps.

Changes since 0.4:
==================

The numeric classes have been re-written.  There is partial support
for bignums (infinite-precision integers), but divide (for example)
has not been implemented yet.  The representation of bignums uses
2's complement, where the "big digits" are laid out so as to be
compatible with the mpn functions of the GNU Multi-Precision library
(gmp).  (The intent is that a future version of Kawa will support
an option to use gmp native functions for speed.)

The kawa application takes a number of useful command-line switches.

Basically all of R4RS has been implemented.  All the essential
forms and functions are implemented.  Almost all of the optional
forms are implemented.  The exceptions are transcript-on,
transcript-off, and the functions for complex numbers,
and fractions (exact non-integer rationals).

Loading a source file with load now wraps the entire file in
a lambda (named "atFileLevel").  This is for better error
reporting, and consistency with compile-file.

Changes since 0.3:
==================
The hygienic macros described in the appendix to R4RS are now
impemented (but only the define-syntax form).  They are
used to implement the standard "do" form.

The R5RS multiple value functions values and call-with-values are implemented.

Macros (and primitive syntax) can now be autoloaded as well as procedures.

New kawac application compiles to one or more .class files.

Compile time errors include line numbers.
Uncaught exceptions cause a stack trace that includes .scm line numbers.
This makes it more practical to debug Kawa with a Java debugger.

Quasiquotation is implemented.

Various minor bug fixes and optimizations.

Changes since 0.2:
==================
The biggest single change is that Scheme procedures are now compiled
to Java bytecodes.  This is mainly for efficiency, but it also allows
us to do tail-recursion-elimination in some cases.

The "codegen" library is included.  This is a toolkit that handles
most of the details needed to generate Java bytecode (.class) files.

The internal structure of Kawa has been extensively re-written,
especially how syntax transforms, eval, and apply are done,
largely due to the needs for compilation.

Almost all the R4RS procedures are now implemented, except that
there are stiil large gaps in Section 6.5 "Numbers".
