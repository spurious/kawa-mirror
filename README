	README for kawa-0.3 release

This documents how to install and use Kawa, a Scheme system
implemented in Java, and which compiles into Java bytecodes.

The file NEWS summarizes changes since previous releases.

Setting up to use Java
======================

You will need a working Java system.
The program 'java' is the Java interpreter.
The program 'javac' is the Java compiler,
and is needed if you want to compile the source release yourself.
Both programs must both be in your PATH.

You also need to set CLASSPATH so it includes both the
current directory, and the standard Java library.

If you have the Java Developer's Kit in directory $JDK,
and your are using a Bourne-shell compatible shell
(/bin/sh, ksh, bash, or other) you can set both variables thus:

	export PATH=$JDK/bin:$PATH
	export CLASSPATH=.:$JDK/lib/classes.zip

Installing the binary release
=============================
The binary release includes only the binary compiled (.class)
versions of the same .java source files in the source release.
It does not include any documentation, so you probably want the
source release in addition to the binary release.  The prupose
of the binary release is just to save you time and trouble
compiling the sources.

The binary release comes as a gzip-compress tar file:
kawa-0.3-compiled.tar.gz.

You need to decide where you want to put the kawa .class files.
Assuming it is /usr/local/java, you can do:

	gunzip -c <kawa-0.3-compiled.tar.gz|(cd /usr/local/java; tar xf -)

Then, before you can actually run Kawa, you need to set CLASSPATH so it
includes the Kawa files.  For example:

	export CLASSPATH=.:/usr/local/java:$JDK/lib/classes.zip

Then to run Kawa do:

	java kawa

Unpacking and Installation the source release
=============================================
The Kawa release normally comes as a gzip-compressed tar file.

In your build directory do:

	tar xzf kawa-0.3.tar.gz
	cd kawa-0.3

Then you must configure the sources.  This you can do
the same way you configure most other GNU software.  Normally
you can just run the configure script with no arguments:

	./configure

This will specify that a later 'make install' will install the
compiled .class files into /usr/local/java.  If you want them
to be installed someplace else, such as $PREFIX/java, then
specify that when you run configure:

	./configure -- prefix $PREFIX

Thus you need to compile all the .java source files.
Just run make:

	make

You can now test the system by running Kawa in place:

	java kawa

or you can install the compiled files:

	make install

This will install your classes into $PREFIX/java (and its
sub-directories).  Here $PREFIX is the directory you specified
to configure with the --prefix option, or /usr/local if you
did not specify a --prefix option.

To use the installed files, you need to set CLASSPATH so
that $PREFIX/java is on the path:

	export CLASSPATH=.:$PREFIX/java:$JDK/lib/classes.zip

Running Kawa
============

The interface to Kawa is typical of Scheme interpreters.
You start it by typing:

	java kawa

(Remember, the Java interpreter must be on your PATH,
and the kawa.class file must be in your CLASSPATH.)

You will then get the "kawa>" prompt, which means you are
in the Java read-eval-print-loop.  If you type a Scheme
expression, Kawa will evaluate it.  Kawa will then print the
result (if there is a non-"void" result).

To exit Kawa, type the end-of-file character (normally ctrl/D),
or call the exit procedure (with 0 or 1 integer argument).

Scheme restrictions
===================
The file Compliance.html specifies which functions and syntax
have been implemented so far.

Missing syntax forms are do, case, quasi-quote, and promise.

There is no macro system.

The only numeric datatypes are fix-width (32-bit) integers, and
double-precision floats.  Many of the numeric and math functions
have not been implemented yet.

Also, call-with-current-continuation is only "upwards" (?).
I.e. once a continuation has been exited, it cannot be invoked.
These restricted continuations can be used to implement catch/throw
(such as the examples in R4RS), but not co-routines or backtracking.

Tail-call elimination
=====================
Kawa does not do general tail-call elimination.  However, if the
compiler can prove that the procedure being called is the current
function, then the tail call will be replaced by a jump.
This means the procedure must be defined using a letrec, not a
define (because the compiler does not know if someone might
re-define a global definition), and there must be no assignments
(using set!) to the procedure binding.

Compilation
===========
To byte-compile a file foo.scm do:

	(compile-file "foo.scm" "foo")

This will create "foo.zip", which contains bytecompiled "j-code"
that implements "foo.scm".

You can later do:

	(load "foo")

This will load foo.zip, which should have the same effect as
loading foo.scm, except you will get the byte-compiled versions.

Actually, note that if you type a lambda expression to the
read-eval-print loop, or there is one in a .scm file you load,
those procedures will actually be compiled into bytecodes too.
The evaluator (in the traditional sense) is only used for top-level
expressions *outside* a lambda.  (It would have been more elegant
to also byte-compile top-level expressions by surrounding them
by a dummy lambda.  However, this would create a new Class object
in the Java VM for every top-level expression.  This is undesirable
unless you hava a VM that can garbage collect Class objects.
I believe Sun's VM does not.)

Authors
=======
R. Alexander Milowski <alex@copsol.com> wrote and released
versions 0.1 and 0.2.  He is still actively involved.

Per Bothner <bothner@cygnus.com> re-wrote the evaluator to
use byte compilation, made many other changes, and released 0.3.

If you have a problem or bug, for now send a report to the authors.
(However, one or both will be on vacation until August 12.)
If there is demand, we will set up a mailing list.
Future announcements will be announced at least to comp.lang.scheme.
