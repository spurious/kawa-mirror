Perhaps CallFrame should extend ModuleBody.

BEFORE KAWA 1.7:
* Finish modules: define-module?  constructor arguments?
* Handle defmacro definition and use in same source file.
* load.loadSource if (true) should be if (false).
* Implement Scheme API for serialization.
* Printer for ELisp and CLisp.
* document define-procedure
* Tail-calls in top-level functions should loop.
* Document in internals.html how ModuleMethod/ModuleBody works.

Should inline when accessing a final static field (using static-field),
for int (or shorter) types - but only for "compile-time constants".
(Needs checking .class file that field is given ConstantValue.)

Starting (emacs) has wrong keybindings unless --elisp is specified.

ModuleMethod should do type-checking in match, for proper generics.

Move kawa.standard.convert to gnu.kawa.reflect.Convert.
Move kawa.lang.Lambda to gnu.kawa.lispexpr.Lambda.  Merge with Elisp version.
Remove Scheme.getTypeValue.

(define plus +) ... (plus ...) should not inline call to +.

(define-alias <alias> <class>) doesn't work interactively.

Implement IntRange class.
Use it to replace Char's hashtable.
Replace Char by Character.

JEmacs:
* clean up function-binding hacks
* vertical-motion

Modules:
* Infer parameter and return types when defaulted and otherwise match
method in explicit module-extends or module-interface.

compile-file should generate .jar, not .zip.
Should perhaps take multiple file names.
Update manual to removing .zip references.

Binding for imported unknown names (idN$NAME) should not be static!

(this) needs to be more general/robust.
Start by forcing it to make the generated method non-static.
What about 'super' ?

Re-store code to check argument count when applyN is involved.
(in Compilation and maybe ApplyExp).

BindingInitializer.emit: global Environment should be cached

Add --inline and --no-inline flags.

TO BE DONE FOR 2.0:

Implement SRFI 0: Feature-based conditional expansion construct 
Implement SRFI 9: Defining Record Types

Move more of kawa.lang.* to gnu.kawa.reflect and gnu.kawa.*.

Calls to setter (as in (set! (...)) should be inlined.

'object': being able to pass constructor arguments. eg., to simulate:
   new javax.swing.JDialog(myFrame) {  public void foo() {} };
Perhaps:  (object ((<javax.swing.JDialog> myFrame)) ...)

Fix scheme-window in misc.scm.

Generate better code for `(and test1 test2 test3)'.
[See maybe-report-section in testing.scm]

Lexer should implement mark/reset.

Module compilation:
* Allocated selctor indexes "densely" within each applyX method
of a ModuleBody, so tableswitch gets used, rather than lookupswitch.

define-syntax and friends are not properly hygienic when checking
literals:  symbols listed among the literals lists are matched as
raw symbols, rather that checking that the symbol has the same
binding, if any, as at the defining site.

Complain if syntax or macro is used in other than function-call position.

Why is start pc==0 in LocalVariableTable?

Let LineBufferedReader pos, limit, buffer be private,
but provide methods to get/set them.

exact->inexact only implemented for RealNums, not other Complex.

Fix scheme-window so #!eof closes window.

Option(s) to control/disable inlining.

Change Declaration so it no longer inherits from Variable.
(Instead, maybe it should inherit from constraint.)
Instead use getVariable() { return (Variable)field; }
Then we can get rid of the sym field and the symbol method,
because getName() would be source name, while getVariable.getName()
is mangled name.  Would also allow us to allocate Variables
while generating byteocde, which is cleaner and more flexible,

Implement source-filename source-line source-column macros.
Macro-expansions lose line number information.
Fix when switching to syntatic closures.

All function calls in kawa.lib that call standard or library functions
should be resolved statically (inlined or direct methods calls).

Combine primitive field with record facility and define-class.

Support persistence and serialization of Scheme values.

Provide getopt-long (Guile, check scsh).

Implement SwitchExp;  use it for Scheme case.

Replace use of ZipArchive by jar files.

Implement full call-cc by re-writing.
This would be slower, so should be optional, probably not the default.

Compile a module with top-level function definitions to a single class
with methods.  More efficient when functions can be statically resolved.
However less efficient otherwise, since need to use reflection interface.

Implement pretty-printer, ideally in a way that works with AWT containers.

Complete R4RS procedures.
  trig functions for complex numbers

Complete R5RS number syntax.

Implement system open-input-pipe open-output-pipe close-pipe.

Add a way to specify a load-path (or maybe just use CLASSPATH?).
First seach for loaded files in directory where current file was found.

OTHER:

Provide a way to compile a Scheme program into an Applet class (with
init/start/stor/pain/etc methods).  Also provide a stripped down
"kawa-run.zip", without eval, load, or compiler.

Implement modules.

Update to match kawa-tour:
  Vector -> FVector
  SyntaxRule.match should use Pattern.

Should SyntaxRule inherit from Pattern?

Move readSchemeObject readSchemeNumber etc from InPort
to new class(es) Parser:
	class Parser;
	class SchemeReader extends Parser;  // Provides read
	class SchemeParser extends SchemeReader;  // Provides read+rewrite
Move Interpreter.syntaxError to Parser.
Treat ReadError as SyntaxError.
Support warning, error, fatal.
Parser accumulates list of syntax errors.
When done, if errors or warnings, throw SyntaxErrors.
Printing SyntaxError prints error log.

Make closure representation consistent with inner classes wrt
use of Attributes (for possible improved debugging).

Optionally issue a warning if a symbol is rebound.

Make kawa.repl -f FILE (or something) work for compiled FILEs.

Use primitive types for expressions when declared/inferred.  Inline arithmetic
when possible.  Integrate native numeric types into numeric tower.
Native ints would have "modular" semantics.  32-bit int would be
converted to an Object as a java.lang.Int, and would overflow by
wrapping around, while gnu.math.IntNum would not wrap around.
Need specification and implementation of mixed modular and
infinite-precision integers.

Inline calls to simple methods, especially builtins.
Ties in with module specifications (to determine which bindings are builtin).

Load should take an optional environment argument.

Quantities:
Arithmetic involving Units should return Units.
Printing a Unit should return something readable, maybe:
  (quantity->unit 1cm) -> "1cm". while 1cm -> "1.0cm".

EVENT CALLBACKS - Proposed design

Syntax:  (listener (EXTRA-INTERFACE ...)
           ((METHOD-NAME+ [EVENT-TYPE])+ ARG ACTIONS ...) ...)

Example:  (invoke component 'addMouseListener
	    (listener ((mousePressed mouseReleases) evt
              (display (list "mouse pressed or released:" evt))))

This creates a new "listener" instance.  The instance has one
method for each METHOD-NAME; the method takes a single argument
of the specified EVENT-TYPE.  The EVENT-TYPE can be left out
in the case of standard java METHOD-NAMES;  for example
if the METHOD-NAME is mousePressed, the implied EVENT-TYPE
is <java.awt.event.MouseEvent>.  When the method is executed,
the actual Event is bound to ARG, and the ACTIONS executed.
(The type is ARG is the least common super-type of all
the explicit or implicit EVENT-TYPES for corresponding METHOD-NAMES.)
The allocated listener instance implements all the interfaces
listed in the EXTRA-INTERFACE list;  if addition, if an EVENT-TYPE
was implied, the corresponding Listener interface is also implied.
(For example a METHOD-NAME of mousePressed implies an EVENT-TYPE
of <java.awt.event.MouseEvent>, and hence an interface of
<java.awt.event.MouseListener>.)
New syntax:
(listener [(EXTRA-INTERFACE ...)]
  ((METHOD-NAME ... EVENT-ARG-NAME [:: EVENT-TYPE]) ...))

SYMBOLS
If we have pre-process environments, (define exit ...) should only re-define
exit in the current environment, not all.

JDK1.2 TASKS - THINGS TO DO ONCE WE REQUIRE JAVA2

Rewrite (make-temporary-file) to use File.createTempFile.

Have kawa.lang.Sequence implement java.util.List.
gnu.mapping.Binding should implement java.util.Map.Entry.

Possibly replace GuiConsole to use JTextPane (or gnu.jemacs.buffer.Window).

BENCHMARKS
http://www.ccs.neu.edu/home/will/Twobit/kvwbenchmarks.html
