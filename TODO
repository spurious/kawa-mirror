TO BE DONE FOR 2.0:

Literals in inline should use fields (rather than array);
use java.lang.reflect.Field to pass them in.

Why is start pc==0 in LocalVariableTable?

Let LineBufferedReader pos, limit, buffer be private,
but provide methods to get/set them.

exact->inexact only implemented for RealNums, not other Complex.

Fix scheme-window so #!eof closes window.

Implement source-filename source-line source-column macros.
Macro-expansions lose line number information.
Fix when switching to syntatic closures.

Make all the primitive-XXX macros be procedures, once we have better inlining.
E.g.: (primitive-virtual-method <TYPE> "NAME" <RTYPE> (<ARG1> ...))
becomes: (prim-virtual-method <TYPE> 'NAME <RTYPE> <ARG1> ...)

Combine primitive field with record facility and define-class.

Support persistence and serialization of Scheme values.

Allow the type of an Expression to be other than Object.
Use type declarations and (local) type inference.

Replace use of ZipArchive by jar files.

Implement full call-cc and tail-calls by re-writing as in RScheme.
This would be slower, so should be optional, probably not the default.

Compile a module with top-level function definitions to a single class
with methods.  More efficient when functions can be statically resolved.
However less efficient otherwise, since need to use reflection interface.

Provide bindings/implementations for the Format concept of java.text.
Implement Common Lisp-style format.  (SLib version cannot be used,
as it is not thread-safe.  That could perhaps be fixed.)
Implement pretty-printer, ideally in a way that works with AWT containers.

Complete R4RS procedures.
  trig functions for complex numbers

Complete R5RS number syntax;  clean up quantity syntax.

Implement let-syntax and letrec-syntax.
Implement syntax-case.
Possibly re-write macro syntax to use syntactic closures.

Implement system open-input-pipe open-output-pipe close-pipe.
Implement read-line; other Guile port operations.

Add a way to specify a load-path (or maybe just use CLASSPATH?).
First seach for loaded files in directory where current file was found.

OTHER:

Provide a way to compile a Scheme program into an Applet class (with
init/start/stor/pain/etc methods).  Also provide a stripped down
"kawa-run.zip", without eval, load, or compiler.

Implement modules.

Update to match kawa-tour:
  Vector -> FVector
  Quote -> quote  (also Lambda -> lambda)
  SyntaxRule.match should use Pattern.

Should SyntaxRule inherit from Pattern?

Move readSchemeObject readSchemeNumber etc from InPort
to new class(es) Parser:
	class Parser;
	class SchemeReader extends Parser;  // Provides read
	class SchemeParser extends SchemeReader;  // Provides read+rewrite
Move Interpreter.syntaxError to Parser.
Treat ReadError as SyntaxError.
Support warning, error, fatal.
Parser accumulates list of syntax errors.
When done, if errors or warnings, throw SyntaxErrors.
Printing SyntaxError prints error log.

Make it easier to plug in other source languages.
Implement Emacs Lisp reader and primitives.

Implement heapFrame, static link etc as references to objects,
not arrays.  Make consistent with JDK1.1 inner classes extension.
Better naming convention for inner lambdas. (I.e. fix kawa.lib.lambda.)

Make #!null more robust.  Allow (global) variables to be bound to #!null
without being considered to be undefined.

Optionally issue a warning if a symbol is rebound.

Make kawa.repl -f FILE (or something) work for compiled FILEs.

Use primitive types for expressions when declared/inferred.  Inline arithmetic
when possible.  Integrate native numeric types into numeric tower.
Native ints would have "modular" semantics.  32-bit int would be
converted to an Object as a java.lang.Int, and would overflow by
wrapping around, while gnu.math.IntNum would not wrap around.
Need specification and implementation of mixed modular and
infinite-precision integers.

Inline calls to simple methods, especially builtins.
Ties in with module specifications (to determine which bindings are builtin).

Load should take an optional environment argument.

Quantities:
Arithmetic involving Units should return Units.
Printing a Unit should return something readable, maybe:
  (quantity->unit 1cm) -> "1cm". while 1cm -> "1.0cm".

EVENT CALLBACKS - Proposed design

Syntax:  (listener (EXTRA-INTERFACE ...)
           ((METHOD-NAME+ [EVENT-TYPE])+ ARG ACTIONS ...) ...)

Example:  (invoke component 'addMouseListener
	    (listener ((mousePressed mouseReleases) evt
              (display (list "mouse pressed or released:" evt))))

This creates a new "listener" instance.  The instance has one
method for each METHOD-NAME; the method takes a single argument
of the specified EVENT-TYPE.  The EVENT-TYPE can be left out
in the case of standard java METHOD-NAMES;  for example
if the METHOD-NAME is mousePressed, the implied EVENT-TYPE
is <java.awt.event.MouseEvent>.  When the method is executed,
the actual Event is bound to ARG, and the ACTIONS executed.
(The type is ARG is the least common super-type of all
the explicit or implicit EVENT-TYPES for corresponding METHOD-NAMES.)
The allocated listener instance implements all the interfaces
listed in the EXTRA-INTERFACE list;  if addition, if an EVENT-TYPE
was implied, the corresponding Listener interface is also implied.
(For example a METHOD-NAME of mousePressed implies an EVENT-TYPE
of <java.awt.event.MouseEvent>, and hence an interface of
<java.awt.event.MouseListener>.)
