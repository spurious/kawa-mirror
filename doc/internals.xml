<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V4.1//EN"
 "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">
<!--<!DOCTYPE article PUBLIC "-//Davenport//DTD DocBook V3.0//EN">-->
<article id="Root">
<artheader>
<title>Kawa internals: Compiling Scheme to Java</title>
<authorgroup>
<author>
<firstname>Per </firstname><surname>Bothner</surname>
<affiliation>
<address>
<email>per@bothner.com</email>
</address>
</affiliation>
</author>
</authorgroup>
</artheader>
<abstract>
<para>
Kawa is a set of Java classes useful for implementing dynamic languages,
such as those in the Lisp family.  Kawa is also an implementation
of near-R5RS Scheme using these classes, and which compiles Scheme
to the bytecode instructions of the Java Virtual Machine.
This paper discusses the various issues involved in implementing
Scheme using an abstract machine designed for a very different language.
and how Kawa solves these problems.
</para>
<!--
<para>
Many are interested in Java for its portable bytecodes
and extensive libraries, but prefer a different language, especially
for scripting.
People have implemented other languages using an interpreter (which
is slow), or by translating into Java source
(with poor responsiveness for <literal>eval</literal>).
Kawa uses an interpreter only for <quote>simple</quote> expressions;
all non-trivial expressions (such as function
definitions) are compiled into Java bytecodes, which are emitted into an
in-memory byte array.  This can be saved for later, or quickly loaded
using the Java <classname>ClassLoader</classname>.</para>
<para>
Kawa is intended to be a framework that supports multiple
source languages.
Currently, it only supports Scheme, which
is a lexically-scoped language in the Lisp family.
The Kawa dialect of Scheme implements almost all of the current
Scheme standard (R5RS), with a number of extensions, and is
written in a efficient object-oriented style.
It includes the full <quote>numeric tower</quote>,
with complex numbers, exact infinite-precision rational arithmetic,
and units.  A number of extensions provide
access to Java primitives, and some Java methods provide
convenient access to Scheme.  Since all Java objects are Scheme values
and vice versa, this makes for a very powerful hybrid Java/Scheme
environment.</para>
<para>
An implementation of ECMAScript (the standardized <quote>core</quote>
of JavaScript) is under construction.  Other languages, including
Emacs Lisp, are also being considered.</para>
-->
<para>
For information on getting and using Kawa, see the
<ulink url="http://www.gnu.org/software/kawa/">Kawa home page</ulink>.
</para>
<para>
This document is based on a paper presented November 1998.
Kawa has seen many changes since then, but alas, this document
has not kept pace.
</para>
<!-- Old abstract:
Kawa is an implementation of the Scheme programming language
written entirely in Java.  It compiles Scheme procedures
into Java bytecode classes, either on-the-fly, or in
batch mode for later use.  Kawa also includes a full Scheme run-time
environment written in an object-oriented style, with class
hierarchies for collections, procedures, and the full numeric <quote>tower.</quote>

This paper gives an overview of the features of Kawa.
It concentrates on the compiler, and how Scheme values are
represented by Java objects.  The paper is structured
as a <quote>tour</quote> of the Java classes used in the implementation.
-->
</abstract>
<sect1 id="Introduction"><title>Introduction</title>
<para>
While Java is a decent programming language, 
the reason for the <quote>Java explosion</quote> is largely
due to the Java Virtual Machine.  The JVM allows
programs to be distributed easily and efficiently in the form of
portable bytecodes, which can run on a wide variety of architectures
and in web browsers.  These advantages are largely
independent of the Java language, which is why there have been a
number of efforts to run other languages on the JVM, even though the
JVM is very clearly designed and optimized for Java.
Kawa is both a toolkit for compiling other languages into Java
bytecodes, and an implementation of the Scheme language
implemented in Java.
<!--
Many are especially interested in more high-level, dynamic
<quote>scripting</quote> languages to use in a project in conjunction
with Java.
A language implemented on top of Java gives
programmers many of the extra-linguistic
benefits of Java, including libraries, portable bytecodes,
web applets, and the existing efforts to improve Java
implementations and tools.
-->
</para>
<para>
The benefits of this hybrid Scheme/Java environment include:
<itemizedlist>
<listitem><para>
Provides a higher-level, more dynamic
programming interface than Java, with support for <quote>scripting</quote>
and interactive read-eval-print loops.</para></listitem>
<listitem><para>
Extends the Java benefits of "write once run anywhere" to Scheme programs,
including portable bytecode distribution and web applets,
though the use of standard Java bytecodes.</para></listitem>
<listitem><para>
Full integration between Java and Scheme:  Scheme programs can call
Java methods, and Java methods can call Scheme procedures.</para></listitem>
<listitem><para>
Scheme programs benefit from the extensive efforts in improved
Java implementations, optimizations, environments, and tools.</para></listitem>
<listitem><para>
Scheme programs get access to the large library of standard Java classes.
</para></listitem>
</itemizedlist>
</para>
<para>
Kawa is intended to be a multi-langauge implementation toolkit.
While only Scheme is currently supported, an implementation of
ECMAScript (JavaScript) is coming along.
Emacs Lisp is also planned.</para>
<!--
<para>
Scheme <citation>R5RS</citation> is a simple yet powerful language.
It is a non-pure functional
language (<foreignphrase><abbrev>i.e.</abbrev></foreignphrase> it has
first-class functions, lexical scoping, non-lazy evaluation, and side
effects).  It has dynamic typing, and usually has an
interactive read-evaluate-print interface.  The dynamic
nature of Scheme (run-time typing, immediate expression
evaluation) may be a better match for the dynamic Java
environment (interpreted bytecodes, dynamic loading) than Java is!</para>
<para>
ECMAScript is the name of the dialect of JavaScript defined
by ECMA standard 262 <citation>ECMAScript</citation>,
which standardizes JavaScript's core language only,
with no input/output or browser/document interface. 
It defines a very dynamic object-based language
based on prototype inheritance, rather than classes.
A number of new or proposed Web standards are based on ECMAScript.</para>
-->
<para>
<!--Information and source code will be available
from <ulink url="http://www.cygnus.com/~bothner/kawa.html">here</ulink>.-->
(Note that Kawa is also the name of an unrelated commercial Java
development environment.)</para>
</sect1>

<sect1 id="History"><title>History</title>
<para>
Starting in 1995 Cygnus (on behalf of the Free Software Foundation)
developed Guile, an implementation of Scheme suitable as a general
embedding and extension language.  Guile was based on
Aubrey Jaffar's SCM interpreter;  the various Guile enhancements
were initially done by Tom Lord.  In 1995 we got a major contract
to enhance Guile, and with our client we added
more features, including threads (primarily done by Anthony Green),
and internationalization.</para>
<para>
The contract called for a byte-code
compiler for Guile, and it looked like doing a good job
on this would be a major project.  One option we considered was compiling
Scheme into Java bytecodes and executing them by a Java engine.
The disadvantage would be that such a Scheme system would not
co-exist with Guile (on the other hand, we had run into various
technical and  non-technical problems with Guile that led us to
conclude that Guile would after all not be strategic to Cygnus).
The advantage of a Java solution was leveraging off the
tools and development being done in the Java <quote>space</quote>,
plus that Java was more likely to be strategic long-term.</para>
<para>
The customer agreed to using Java, and I started active development June 1996.
As a base, I used the Kawa Scheme interpreter written
by R. Alexander Milowski.  He needed an object-oriented
Scheme interpreter to implement DSSSL <citation>DSSSL</citation>,
a Scheme-like environment for expressing style, formatting,
and other processing of SGML <citation>SGML</citation> documents.
DSSSL is an subset of <quote>pure</quote> Scheme with some extensions.
<!--  [See http://www.edu.uni-klu.ac.at/~nmikula] -->
Kawa 0.2 was a simple interpreter which was far from
complete.  It provided a useful starting point, but almost all
of the original code has by now been re-written.</para>
<para>
Kawa 1.0 was released to our customer and <quote>the Net</quote>
September 1996. Development has continued since then, at a less intense pace!
The long-term goal is an object-oriented environment that harmoniously
integrates Scheme, Java, ECMAScript, and other languages. </para>
</sect1>

<sect1 id="Basic"><title>Basic implementation strategy</title>
<para>
There are three basic ways one might implement some programming language
X using Java:
<itemizedlist>
<listitem><para>
One could write an interpreter for X in Java.
First parse the source into an internal
<quote>abstract syntax tree</quote>,
and then evaluate it using a recursive <literal>eval</literal> function.
The advantage of using Java rather than C or C++ is having garbage collection,
classes, and the standard Java class library makes it easier.</para>
<para>
The obvious down-side of the interpreter solution is speed.
If your interpreter for language X is written in
Java, which is in turn interpreted by a Java VM, then you
get double interpretation overhead.
</para></listitem>
<listitem><para>
You could write a compiler to translate language X into Java source code.
You need to define a mapping for language X constructs
into equivalent Java constructs, and then write a program that writes
out a parsed X program using corresponding Java constructs.
A number of implementations take this approach,
including NetRexx, and various <quote>extended Java</quote> dialects.</para>
<para>
This only gives you the single a single (Java VM) layer of interpretation.
On the other hand, most of the efforts that people are making
into improving Java performance will benefit your implementation, since
you use standard Java bytecodes.</para>
<para>
The biggest problem with that approach is that it is an inherently batch
process, and has poor responsiveness.  Consider a read-eval-print-loop,
that is the ability for a user to type in an expression,
and have it be immediately read, evaluated, and the result printed.
If evaluating an expression requires
converting it to a Java program, writing it to a disk file, invoking a
separate java compiler, and then loading the resulting class file into the
running environment, then response time will be inherently poor.
This hurts <quote>exploratory programing</quote>, that is the ability to
define and update functions on the fly.
</para><para>
A lesser disadvantage is that Java source code is not quite as expressive
as Java bytecodes.  While bytecodes are very close to Java source,
there are some useful features not available in the Java language, such
as goto.  Debugging information is also an issue.
</para></listitem>
<listitem><para>
Alternatively, you could directly generate Java bytecode.
You can write out a .class file, which can be saved for later.
You also have the option of writing to an internal byte array,
which can be immediately loaded as a class using the
<function>java.lang.ClassLoader.defineClass</function> method.
In that case you can by-pass the file system entirely,
yield a fast load-and-go solution, which enables a very responsive
read-eval-print loop.
</para><para>
This solution is the best of both worlds.  The main problem
is that more code needs to be written.  Fortunately, by using Kawa,
much of that work has already been done.
</para></listitem>
</itemizedlist>
</para>
<para>
I will discuss the compiler later, but first we will give an
overview of the run-time environment of Kawa, and the
classes used to implement Scheme values.</para>
</sect1>
<sect1 id="Objects"><title>Objects and Values</title>
<para>
Java <citation>JavaSpec</citation> has primitive types (such as
32-bit <classname>int</classname>) as well reference types.
If a variable has a reference
type, it means that it can contain references (essentially pointers)
to objects of a class, or it can contain references to objects of
classes that <quote>extend</quote> (inherit from) the named class.
The inheritance
graph is <quote>rooted</quote> (like Smalltalk and unlike C++);
this means that all classes inherit from a distinguished class
<classname>java.lang.Object</classname> (or just
<classname>Object</classname> for short).</para>
<para>
Standard Scheme <citation>R5RS</citation>
has a fixed set of types, with no way of creating new types.  It has
run-time typing, which means that types are not declared, and a
variable can contain values of different types at different times.  The
most natural type of a Java variable that can contain any Scheme value
is therefore <classname>Object</classname>, and all Scheme values must be
implemented using some class that inherits from <classname>Object</classname>.
</para>
<para>
The task then is to map each Scheme type into a Java class.  Whether
to use a standard Java class, or to write our own is a tradeoff.  Using
standard Java classes simplifies the passing of values between Scheme
functions and existing Java methods.  On the other hand, even when Java
has suitable built-in classes, they usually lack functionality needed
for Scheme, or are not organized in any kind of class hierarchy as in
Smalltalk or Dylan.  Since Java lacks standard classes corresponding to
pairs, symbols, or procedures, we <emphasis>have</emphasis> to write
some new classes, so we might as well write new classes whenever the
existing classes lack functionality.
<!--  One extreme would be to define a new
<classname>SchemeObject</classname>
class, and derive from it classes for all Scheme values.  While this
might make implementing Scheme easier, Kawa does not go that far,
partly because we want to allow Scheme variables to contain arbitrary
Java objects.-->
</para>
<para>
The Scheme boolean type is one where we use a standard Java type, in
this case <classname>Boolean</classname> (strictly speaking
<classname>java.lang.Boolean</classname>).  The
Scheme constants <literal>#f</literal> and <literal>#t</literal> are
mapped into static fields (<foreignphrase><abbrev>i.e.</abbrev></foreignphrase>
constants) <literal>Boolean.FALSE</literal> and
<literal>Boolean.TRUE</literal>.</para>
<para>
On the other hand, numbers and collections are reasonably organized
into class hierarchies, which Java does not do well.  So Kawa has its
own classes for those.
The next sections will give skeletal definitions of the classes used to
to represent Scheme values.
</para>
<sect2 id="Collections"><title>Collections</title>
<para>
Kawa has a rudimentary hierarchy of collection classes.
<programlisting>
class <classname>Sequence</classname>
{ ...;
  abstract public int length();
  abstract public Object elementAt(int i);
}
</programlisting>
</para>
<para>
A <classname>Sequence</classname> is the abstract class that includes
lists, vectors, and strings.
<programlisting>
class <classname>FString</classname> extends Sequence
{ ...;
  char[] value;
}
</programlisting>
</para>
<para>    
   Used to implement fixed-length mutable strings (array of Unicode
character).  This is used to represent Scheme strings.
<programlisting>
class <classname>FVector</classname> extends Sequence
{ ...;
  Object[] value;
}
</programlisting>
</para>

<para>
Used to implement fixed-length mutable general one-dimensional array
of <classname>Object</classname>.
This is used to represent Scheme vectors.</para>
<programlisting>
public class <classname>List</classname> extends Sequencw
{ ...;
  protected List () { }
  static public List Empty = new List ();
} 
</programlisting>
<para>
Used to represent Scheme (linked) lists.
The empty list <literal>'()</literal> is the special static
value <literal>List.Empty</literal>.
Non-empty-lists are implemented using <classname>Pair</classname> objects.
</para>
<programlisting>
public class <classname>Pair</classname> extends List
{ ...;
  public Object car;
  public Object cdr;
}
</programlisting>
<para>
Used for Scheme pairs, <foreignphrase><abbrev>i.e.</abbrev></foreignphrase>
all non-empty lists.</para>
<programlisting>
public class <classname>PairWithPosition</classname> extends Pair
{ ...;
}
</programlisting>
<para>
Like <classname>Pair</classname>, but includes the filename and linenumber
in the file from which the pair was read.</para>
<para>
Future plans include more interesting collection classes,
such a sequences implemented as a seekable disk file;
lazily evaluated sequences; hash tables;  APL-style
multi-dimensional arrays; stretchy buffers.
(Many of these ideas were implemented in my earlier experimental
language <literal>Q</literal> -- see <citation>Bothner88</citation> and
<literal>ftp://ftp.cygnus.com/pub/bothner/Q/</literal>.
I will also integrate the Kawa collections into the new JDK 1.2
collections framework.</para>
</sect2>

<sect2 id="Top-level"><title>Top-level environments</title>
<programlisting>
class <classname>Environment</classname>
{ ...;
}
</programlisting>
<para>
An <literal>Environment</literal> is a mapping from symbols to bindings.
It is used for the bindings of the user top-level.
There can be multiple top-level <classname>Environments</classname>, and
an <classname>Environment</classname> can be defined as an extension 
of an existing <classname>Environment</classname>.
The latter feature is used to implement the various standard
environment arguments that can be passed to <literal>eval</literal>,
as adopted for the latest Scheme standard revision, R5RS.
Nested environments were also implemented to support threads,
and fluid bindings (even in the presence of threads).</para>
<para>
Environments will be integrated into a more general name-table interface,
which will also include records and ECMAScript objects.</para>
</sect2>

<sect2 id="Symbols"><title>Symbols</title>
<para>
Symbols represent identifiers, and do not need much functionality.  Scheme
needs to be able to convert them to and from Scheme strings, and they need to
be <quote>interned</quote> (which means that there is a global
table to ensure that there is a unique symbol for a given identifier).
Symbols are immutable and have no accessible internal structure.</para>
<para>Scheme symbols are reprented using interned Java
<classname>String</classname>s.
Note that the Java <classname>String</classname> class implements
immutable strings, and therefore cannot be used to implement
Scheme strings.  However, it makes sense to use it to implement symbols,
since the way Scheme symbols are used is very similar to how
Java <classname>String</classname>s are used.
The method <function>intern</function> in <classname>String</classname>
provides an interned version of a <classname>String</classname>,
which provides the characters-to-<classname>String</classname>
mapping needed for Scheme strings.</para>
</sect2>

</sect1>
<sect1 id="Numbers"><title>Numbers</title>
<para>
Scheme defines a <quote>numerical tower</quote> of numerical types:
number, complex, real, rational, and integer.
Java has primitive <quote>unboxed</quote> number types (such as
<classname>int</classname>), just like C, and also has some
<quote>wrapper</quote> classes that are basically boxed versions
of the unboxed number types.  Specifically, the standard Java
number classes are not organized in any particularly useful hierarchy,
except that they all inherit from <classname>Number</classname>.
Kawa implements the full <quote>tower</quote> of Scheme number types,
using its own set of sub-classes of the abstract
class <classname>Quantity</classname>, a sub-class of
<classname>Number</classname> we will discuss later.
</para>
<programlisting>
public class <classname>Complex</classname> extends Quantity
{ ...;
  public abstract RealNum re();
  public abstract RealNum im();
}
</programlisting>
<para>
<classname>Complex</classname> is the class of abstract complex numbers.
It has three subclasses:  the abstract class <classname>RealNum</classname>
of real numbers;  the general class <classname>CComplex</classname> where the
components are arbitrary <classname>RealNum</classname> fields; and the
optimized <classname>DComplex</classname> where the components
are represented by <classname>double</classname> fields.
</para>
<programlisting>
public class <classname>RealNum</classname> extends Complex
{ ...;
  public final RealNum re()
  { return this; }
  public final RealNum im()
  { return IntNum.zero(); }
  public abstract boolean isNegative();
}
</programlisting>

<programlisting>
public class <classname>DFloNum</classname> extends RealNum
{ ...;
  double value;
}
</programlisting>
<para>
Concrete class for double-precision (64-bit) floating-point real numbers.
</para>
<programlisting>
public class <classname>RatNum</classname> extends RealNum
{ ...;
  public abstract IntNum numerator();
  public abstract IntNum denominator();
}
</programlisting>
<para>
<classname>RatNum</classname>, the abstract class for exact rational numbers,
has two sub-classes:  <classname>IntFraction</classname>
and <classname>IntNum</classname>.</para>
<programlisting>
public class <classname>IntFraction</classname> extends RatNum
{ ...;
  IntNum num;
  IntNum den;
}
</programlisting>
<para>
The <classname>IntFraction</classname> class implements fractions in the
obvious way.  Exact real infinities are identified with the
fractions <literal>1/0</literal> and <literal>-1/0</literal>.</para>
<programlisting>
public class <classname>IntNum</classname> extends RatNum
{ ...;
  int ival;
  int[] words;
}
</programlisting>
<para>
The <classname>IntNum</classname> concrete class implements infinite-precision integers.
The value is stored in the first <literal>ival</literal> elements of <literal>words</literal>,
in 2's complement form (with the low-order bits in <literal>word[0]</literal>).</para>
<para>
There are already many bignum packages, including one that Sun
added for JDK 1.1.  What are the advantages of this one?
<itemizedlist>
<listitem><para>
A complete set of operations, including gcd and lcm;  logical, bit,
and shift operations; power by repeated squaring; all of the
division modes from Common Lisp (floor, ceiling, truncate, and round);
and exact conversion to <classname>double</classname>.</para></listitem>
<listitem><para>Consistency and integration with a complete
<quote>numerical tower.</quote>  Specifically, consistency and integration
with <quote>fixnum</quote> (see below).</para></listitem>
<listitem><para>
Most bignum packages use a signed-magnitude representation,
while Kawa uses 2's complement.  This makes for easier integration
with fixnums, and also makes it cheap to implement
logical and bit-fiddling operations.</para></listitem>
<listitem><para>
Use of all 32 bits of each <quote>big-digit</quote> word, which
is the <quote>expected</quote> space-efficient representation.
More importantly, it is compatible with the <literal>mpn</literal> routines
from the Gnu Multi-Precision library (<literal>gmp</literal>) <citation>gmp</citation>.
The <literal>mpn</literal> routines are low-level algorithms that work
on unsigned pre-allocated bignums;  they have been transcribed
into Java in the <literal>MPN</literal> class.  If better efficiency is
desired, it is straight-forward to replace the <classname>MPN</classname>
methods with native ones that call the highly-optimized <literal>mpn</literal> functions.</para></listitem>
</itemizedlist>
</para>
<para>
If the integer value fits within a signed 32-bit <literal>int</literal>,
then it is stored in <literal>ival</literal> and <literal>words</literal> is null.
This avoids the need for extra memory allocation for the <literal>words</literal>
array, and also allows us to special-case the common case.</para>
<para>
As a further optimization, the integers in the range -100 to 1024
are pre-allocated.</para>

<sect2 id="Arithmetric"><title>Mixed-type arithmetic</title>
<para>
Many operations are overloaded to have different
definitions depending on the argument types.
The classic examples are the functions of arithmetic
such as <quote><literal>+</literal></quote>, which needs to use different
algorithms depending on the argument types.
If there is a fixed and reasonably small set of number types
(as is the case with standard Scheme), then we can just
enumerate each possibility.  However, the Kawa system is
meant to be more extensible and support adding new
number types.</para>
<para>
The solution is straight-forward in the case of a one-operand
function such as <quote>negate</quote>, since we can use method
overriding and virtual method calls to dynamically
select the correct method.  However, it is more difficult
in the case of a binary method like <quote><literal>+</literal>,</quote> since
classic object-oriented languages (including Java) only
support dynamic method selection using the type of the
first argument (<quote><literal>this</literal></quote>).  
Common Lisp and some Scheme dialects support dynamic method
selection using all the arguments, and in fact the
problem of binary arithmetic operations is probably the
most obvious example where <quote>multi-dispatch</quote> is useful.</para>
<para>
Since Java does not have multi-dispatch, we have to solve
the problem in other ways.  Smalltalk has the same problems,
and solved it using <quote>coercive generality</quote>:  Each number class
has a generality number, and operands of lower generality are
converted to the class with the higher generality.
This is inefficient because of all the conversions and
temporary objects (see <citation>Budd91Arith</citation>), and it is limited
to what extent you can add new kinds of number types.</para>
<para>
In <quote>double dispatch</quote> <citation>Ingalls86</citation>
the expression <literal>x-y</literal>
is implemented as <literal>x.sub(y)</literal>.  Assuming the (run-time)
class of <literal>x</literal> is <literal>Tx</literal> and that of <literal>y</literal> is <literal>Ty</literal>,
this causes the <literal>sub</literal> method defined in <literal>Tx</literal> to be
invoked, which just does <literal>y.subTx(x)</literal>.  That invokes
the <literal>subTx</literal> method defined in <literal>Ty</literal> which can without
further testing do the subtraction for types <literal>Tx</literal> and <literal>Ty</literal>.</para>
<para>
The problem with this approach is that it is difficult to add
a new <literal>Tz</literal> class, since you have to also add <literal>subTz</literal>
methods in all the existing number classes, not to mention
<literal>addTz</literal> and all the other operations.</para>
<para>
In Kawa, <literal>x-y</literal> is also implemented by <literal>x.sub(y)</literal>.
The <literal>sub</literal> method of <literal>Tx</literal> checks if <literal>Ty</literal> is one
of the types it knows how to handle.  If so, it does the
subtraction and returns the result itself.  Otherwise,
<literal>Tx.sub</literal> does <literal>y.subReversed(x)</literal>.
This invokes <literal>Ty.subReversed</literal> (or
<literal>subReversed</literal> as defined in
a super-class of <literal>Ty</literal>).
Now <literal>Ty</literal> (or one of its
super-classes) gets a chance to see if it knows how to
subtract itself from a <literal>Tx</literal> object.</para>
<para>
The advantage of this scheme is flexibility.  The knowledge of
how to handle a binary operation for types <literal>Tx</literal> and
<literal>Ty</literal> can be in either of <literal>Tx</literal> or
<literal>Ty</literal> or either of their
super-classes.  This makes is easier to add new classes without
having to modify existing ones.</para>
</sect2>

<sect2 id="Quantities"><title>Quantities</title>
<para>
The DSSSL language <citation>DSSSL</citation> is a dialect of Scheme used
to process SGML documents.  DSSSL has <quote>quantities</quote> in addition
to real and integer numbers.  Since DSSSL is used to format documents,
it provides length values that are a multiple of a meter
(<foreignphrase><abbrev>e.g.</abbrev></foreignphrase> <literal>0.2m</literal>),
as well as derived units like <literal>cm</literal> and
<literal>pt</literal> (point).
A DSSSL quantity is a product of a dimension-less number with an integral
power of a length unit (the meter).  A (pure) number is a quantity where
the length power is zero.</para>
<para>
For Kawa, I wanted to merge the Scheme number types with the DSSSL
number types, and also generalize the DSSSL quantities to support
other dimensions (such as mass and time) and units (such as <literal>kg</literal>
and seconds).  Quantities are implemented by the abstract class
<literal>Quantity</literal>.  A <firstterm>quantity</firstterm> is a
product of a <classname>Unit</classname> and a pure number.
The number can be an arbitrary complex number.</para>
<programlisting>
public class <classname>Quantity</classname> extends Number
{ ...;
  public Unit unit()
  { return Unit.Empty; }
  public abstract Complex number();
}
</programlisting>
<programlisting>
public class <classname>CQuantity</classname> extends Quantity
{ ...;
  Complex num;
  Unit unt;
  public Complex number()
  { return num; }
  public Unit unit()
  { return unt; }
}
</programlisting>
<para>
A <literal>CQuantity</literal> is a concrete class that implements general
<literal>Quantities</literal>.  But usually we don't need that much generality,
and instead use <literal>DQuanity</literal>.</para>
<programlisting>
public class <classname>DQuantity</classname> extends Quantity
{ ...;
  double factor;
  Unit unt;
  public final Unit unit()
  { return unt; }
  public final Complex number()
  { return new DFloNum(factor); }
}
</programlisting>

<programlisting>
public class <classname>Unit</classname>
{ ...;
  String name; // Optional.
  Dimensions dims;
  double factor;
}
</programlisting>
<para>
A <classname>Unit</classname> is a product of a floating-point <literal>factor</literal>
and one or more primitive units, combined into a <classname>Dimensions</classname> object.
The <classname>Unit</classname> may have a name (such as <quote><literal>kg</literal></quote>), which is
used for printing, and when parsing literals.</para>
<programlisting>
public class <classname>BaseUnit</classname> extends Unit
{ ...;
  int index;
}
</programlisting>
<para>
A <literal>BaseUnit</literal> is a primitive unit that is not
defined in terms of any other <classname>Unit</classname>, for example the meter.
Each <literal>BaseUnit</literal> has a different <literal>index</literal>, which is used
for identification and comparison purposes.  Two <literal>BaseUnit</literal>s
have the same <literal>index</literal> if and only if they are the same <literal>BaseUnit</literal>.</para>

<programlisting>
public class <classname>Dimensions</classname>
{
  BaseUnit[] bases;
  short[] powers;
}
</programlisting>
<para>
A <classname>Dimensions</classname> object is a product and/or ratio of <literal>BaseUnit</literal>s.
You can think of it as a data structure that maps every <literal>BaseUnit</literal>
to an integer power.  The <literal>bases</literal> array is a list of the <literal>BaseUnit</literal>s
that have a non-zero power, in order of the <literal>index</literal> of the <literal>BaseUnit</literal>.
The <literal>powers</literal> array gives the power (exponent) of the <literal>BaseUnit</literal>
that has the same index in the <literal>bases</literal> array.</para>
<para>
Two <classname>Dimensions</classname> objects are equal if they have the same list of
<literal>bases</literal> and <literal>powers</literal>.  <classname>Dimensions</classname> objects are <quote>interned</quote>
(using a global hash table) so that they are equal only if they are
the same object.  This makes it easy to implement addition and
subtraction:</para>
<programlisting>
public static DQuantity add
  (DQuantity x, DQuantity y)
{
  if (x.unit().dims != y.unit().dims)
     throw new ArithmeticException
       ("units mis-match");
  double r = y.unit().factor
     / x.unit().factor;
  double s = x.factor + r * y.factor;
  return new DQuantity (s, x.unit());
}
</programlisting>
<para>
The <classname>Unit</classname> of the result of an addition or subtraction
is the <classname>Unit</classname> of the first operand.
This makes it easy to convert units:</para>
<programlisting>
(+ 0cm 2.5m)    ==>    250cm
</programlisting>
<para>
Because Kawa represents quantities relative to user-specified units,
instead of representing them relative to primitive base units,
it can display quantities using the user's preferred units,
rather than having to use prmitive units.
However, this does make multiplication and division a problem
The actual calculation (finding the right <classname>Dimensions</classname> and
multiplying the constant factors) is straight-forward.
The difficulty is that we have to generate a new compound
<classname>Unit</classname>, and print it out in a reasonable fashion.
Exactly how this should best be done is not obvious.</para>
</sect2>
</sect1>

<sect1 id="Procedures"><title>Procedures</title>
<para>
Scheme has procedures as first-class values.
Java does not.  However, we can simulate procedure values,
by overriding of virtual methods.</para>
<programlisting>
class <classname>Procedure</classname>
{ ...;
  public abstract Object applyN
    (Object[] args);
  public abstract Object apply0();
  ...;
  public abstract Object apply4
    (Object arg1, ..., Object arg4);
}
</programlisting>
<para>
We represent Scheme procedures using sub-classes of
the abstract class <literal>Procedure</literal>.
To call (apply) a procedure with no arguments,
you invoke its <literal>apply0</literal> method;  to invoke a
procedure, passing it a single argument, you use its
<literal>apply1</literal> method; and so on using <literal>apply4</literal> if
you have 4 arguments.  Alternatively, you can bundle
up all the arguments into an array, and use the <literal>applyN</literal>
method.  If you have more than 4 arguments, you
have to use <literal>applyN</literal>.</para>
<para>
Notice that all <literal>Procedure</literal> sub-classes have to
implement all 6 methods, at least to the extent of
throwing an exception if it is passed the wrong number of
arguments.  However, there are utility classes
<literal>Procedure0</literal> to <literal>Procedure4</literal> and <literal>ProcedureN</literal>:</para>
<programlisting>
class <classname>Procedure1</classname> extends Procedure
{
  public Object applyN(Object[] args)
  {
    if (args.length != 1)
        throw new WrongArguments();
    return apply1(args[0]);
  }
  public Object apply0()
  { throw new WrongArguments();}
  public abstract Object apply1
    (Object arg1);
  public Object apply2
    (Object arg1, Object arg2)
  { throw new WrongArguments();}
  ...;
}
</programlisting>
<para>
Primitive procedures are generally written in Java as
sub-classes of these helper classes. For example:</para>
<programlisting>
class <classname>car</classname> extends Procedure1
{ // Return first element of list.
  public Object apply1(Object arg1)
    { return ((Pair) arg1).car; }
}
</programlisting>

<sect2 id="Program-bodies"><title>Program bodies</title>
<para>
A user-defined Scheme procedure is compiled to a
class that is descended from <literal>Procedure</literal>.
For example, a variable-argument procedure is implemented as a
sub-class of <literal>ProcedureN</literal>, with an <literal>applyN</literal>
method comprising the bytecode compiled from the Scheme procedure
body.  Thus primitive and user-defined procedure have the
same calling convention.</para>
<para>
Top-level forms (including top-level definitions) are
treated as if they were nested inside a dummy procedure.
They are compiled as sub-classes of <literal>ModuleBody</literal>:
</para>
<programlisting>
class <classname>ModuleBody</classname> extends Procedure0
{ ...;
  public Object apply0()
  { return run(Environment.current());}
  public abstract Object run
    (Environment env);
}
</programlisting>
<para>
When a file is <literal>load</literal>ed, the result is a
<literal>ModuleBody</literal>; invoking <literal>run</literal> causes
the top-level actions to be executed.</para>
</sect2>

<sect2 id="Inlining"><title>Inlining</title>
<para>
Kawa has various hooks for inlining procedures.
This can allow substantial speedups, at the cost of some generality
and strict standards-compliance, since it prevents re-assigning
the inlined procedures.  Most of these hooks work by having the
compiler notice that a name in function call position is not lexically
bound, yet it is declared in the (compile-time) global scope.</para>
<para>
The most powerful and low-level mechanism works by having the
compiler note that the procedure implements the
<classname>Inlineable</classname> interface.
That means it implements the specical <function>compile</function> method,
which the compiler calls at code generation time; it can generate
whatever bytecode it wants.  This is a way for special procedues
to generate exotic bytecode instructions.  This hook is only
available for builtin procedures written in Java.</para>
<para>
Another mechanism uses the Java reflective facilities.
If the compiler notices that the class of the procedure
provides a static method with the right name (<function>apply</function>),
and the right number of parameters, then it generates a direct call
to that static method.  This is not inlining
<foreignphrase>per se</foreignphrase>, but it does by-pass the
(currently significant) overhead of looking up the name in the global
symbol-table, casting the value to a procedure, and then making a
virtual function call.  Also, because the procedure is replaced
by a call to a statically known method, that call could actually be
inlined by a Java bytecode optimizer.  Another advantage of calling
a known static method is that the parameter and return types can
be more specific than plain <classname>Object</classname>, or even
be unboxed primitive types.  This can avoid many type conversions.</para>
<para>
The Kawa compiler generates a suitable <function>apply</function>
method for all fixed-arity procedures that do not require a closure,
so this optimization is applicable to a great many procedures.</para>
<para>
Finally, Kawa has preliminary support for true inlining,
where a procedure that is only called in one place except for tail-calls,
is inlined at the call-site.  I plan to add an analysis pass to
detect when this optimization is applicable.  For now, there is a
special case to handle the <function>do</function> special looping form,
and these are now always implemented in the natural way (as inlined
loops).  The <quote>named <function>let</function></quote> cannot always
be implemented as an inlined loop, so implementing that equally
efficiently will need the planned analysis phase.</para>
</sect2>

<sect2 id="Closures"><title>Closures</title>
<para>
Languages that provide first-class nested functions with lexical scoping
have to deal with variables that an inner function <quote>captures</quote>
from surrounding lexical scopes.  The standard solution uses a
<quote>closure</quote> to represent a function together with the
environment of captured variables.
The original Java language definition did not
support nested functions.  However, it did have objects and classes,
and it turns out the objects and first-class functions are similar in power,
since a closure can be represented using an object and vice versa.
The <quote>inner classes</quote> added to Java in JDK 1.1 are
an object-oriented form of first-class functions.  The Java compiler
translates the nested classes into plain objects and non-nested classes,
very much like Kawa represents nested Scheme functions.</para>
<para>
Kawa implements a closure as a <literal>Procedure</literal> object
with a <quote>static link</quote> field that points to the inherited
environment.  Older versions of Kawa represented the environment
as an array.  The most recent version uses the <literal>Procedure</literal>
instance itself as the environment.
Let us look at how this works, starting with a
very simple example:</para>
<programlisting>
(define (f1 a)
  (define (f2 b)
    (list a b))
  (cons a f2))
</programlisting>
<para>
This gets compiled to the bytecode equivalent of:</para>
<programlisting>
class F1 extends Procedure1
{
  public Object apply1(Object a)
  { // body of f1
    F2 heapFrame = new F2();
    heapFrame.a = a;
    return Cons.apply2(heapFrame.a,
                      heapFrame);
  }
}

class F2 extends Procedure1
{
  // F2 closureEnv = this;
  Object a;
  public Object apply1(Object b)
  { // body of f2
    return List.apply2(this.a, b);
  }
}
</programlisting>
<para>
Note that the instance of <classname>F2</classname> that
represents the <function>f2</function> procedure contains both
the code (the <function>apply1</function> methods), and
the captured instance variable <literal>a</literal> as a Java field.
Note also that the parent function <function>f1</function> must
in general use the same field instance when accessing <literal>a</literal>,
in case one or the other function assigned to <literal>a</literal>
using a <function>set!</function>.</para>
<para>
Next, a slightly more complex problem:</para>
<programlisting>
(define (f3 a)
  (define (f4 b)
    (cons a b))
  (define (f5 c)
    (cons a c))
  (cons a f5))
</programlisting>
<para>
In this case all three functions refers to <literal>a</literal>.
However, they must all agree on a single location, in case one of
the functions does a <function>set!</function> on the variable.
We pick <function>f4</function> as the home of <literal>a</literal> (for the
simple but arbitrary reason that the compiler sees it first).</para>
<programlisting>
class F3 extends Procedure1
{
  public Object apply1(Object a)
  { // body of f3
    F4 heapFrame = new F4();
    heapFrame.a = a;
    return Cons.apply2(heapFrame.a,
                      new F5(heapFrame));
  }
}

class F4 extends Procedure1
{
  // F4 closureEnv = this;
  Object a;
  public Object apply1(Object b)
  { // body of f4
    return Cons.apply2(this.a, b);
  }
}

class F5 extends Procedure1
{
  F4 closureEnv;
  public F5 (F4 closureEnv)
  {
    this.closureEnv = closureEnv;
  }
  public Object apply1(Object c)
  { // body of f5
    return Cons.apply2(closureEnv.a, c);
  }
}
</programlisting>
<para>
If a variables is captured through multiple levels of nested functions,
the generated code need to follow a chain of static links, as shown
by the following function.</para>
<programlisting>
(define (f6 a)
  (define (f7 b)
    (define (f8 c)
      (define (f9 d)
        (list a b c d))
      (list a b c f9))
    (list a b f8))
  (list a f7))
</programlisting>
<para>
That gets compiled into bytecodes equivalent to the following.</para>
<programlisting>
class F6 extends Procedure1
{
  public Object apply1(Object a)
  { // body of f6
    F7 heapFrame = new F7();
    heapFrame.a = a;
    return List.apply2(heapFrame.a,
                       heapFrame);
  }
}

class F7 extends Procedure1
{
  Object a;
  public Object apply1(Object b)
  { // body of f7
    F8 heapFrame = new F8(this);
    heapFrame.b = b;
    return List.apply3(this.a,
        heapFrame.b, heapFrame);
  }
}

class F8 extends Procedure1
{
  Object b;
  F7 staticLink;
  public F8(F7 staticLink)
  {
    this.staticLink = staticLink;
  }
  public Object apply1(Object c)
  { // body of f8
    F9 heapFrame = new F9(this);
    heapFrame.c = c;
    return List.apply4(staticLink.a,
        this.b, heapFrame.c, heapFrame);
  }
}

class F9 extends Procedure1
{
  Object c;
  F8 staticLink;
  public F9(F8 staticLink)
  {
    this.staticLink = staticLink;
  }
  public Object apply1(Object d)
  { // body of f9
    return List.apply4
      (staticLink.staticLink.a,
        staticLink.b, this.c, d);
  }
}
</programlisting>
<!--
;; Same but cannot use this for closureEnv:
(define (f6 a)
  (define (x6 b) a)
  (define (f7 b)
    (define (x7 c) b)
    (define (f8 c)
      (define (x8 d) c)
      (define (f9 d)
        (list a b c d))
      (list a b c f9))
    (list a b f8))
  (list a f7))

class F6 extends Procedure1
{
  public Object apply1(Object a)
  {
    X6 heapFrame = new X6();
    heapFrame.a = a;
    return List.apply2(heapFrame.a, new F7(heapFrame));
  }
}

class X6 extends Procedure1
{
  Object a;
  public Object apply1 (Object b) { return a; }
}

class F7 extends Procedure1
{
  final X6 closureEnv;
  public F7(X6 closureEnv)
  {  this.closureEnv = closureEnv; }
  public Object apply1(Object b)
  {
    X7 heapFrame = new X7(closureEnv);
    heapFrame.b = b;
    return List.apply3(closureEnv.a, heapFrame.b, new F8(heapFrame));
  }
}

class X7 extends Procedure1
{
  Object b;
  final X6 staticLink;
  public X7(X6 staticLink)
  { this.staticLink = staticLink; }
  public Object apply1 (Object c) { return b; }
}

class F8 extends Procedure1
{
  final X7 closureEnv;
  public F8(X7 closureEnv)
  {
    this.closureEnv = closureEnv;
  }
  public Object apply1(Object c)
  {
    X8 heapFrame = new X8 (closureEnv);
    heapFrame.c = c;
    return List.apply4(closureEnv.staticLink.a,
		       closureEnv.b, heapFrame.c, new F9(heapFrame));
  }
}

class X8 extends Procedure1
{
  Object c;
  final X7 staticLink;
  public X8 (X7 staticLink)
  { this.staticLink = staticLink; }
  public Object apply1 (Object d) { return c; }
}

class F9 extends Procedure1
{
  final X8 closureEnv;
  public F9(X8 closureEnv)
  {
    this.closureEnv = closureEnv;
  }
  public Object apply1(Object d)
  {
    return List.apply4
      (closureEnv.staticLink.staticLink.a,
       closureEnv.staticLink.b,
       closureEnv.c, d);
  }
}
-->
<para>
Handling tail-recursion is another complication.
The basic idea is to divide the procedure prologue
into the actions before the loop head label, and those after.
(Note that allocating a <literal>heapFrame</literal> has to be
done after the head label.)
Handling inlining also requires care.
</para>
</sect2>
</sect1>

<sect1 id="Overview-of-Compilation"><title>Overview of compilation</title>
<para>
These are the stages of compilation:
<variablelist>
<varlistentry><term>Reading</term>
<listitem><para>
The first compilation stage reads the input
from a file, from a string,
or from the interactive command interpreter.
The result is one or more Scheme forms (S-expressions), usually lists.
If reading commands interactively, only a single form is read;
if reading from a file or string, all the forms are read until
end-of-file or end-of-string;  in either case, the result is treated as the
body of a dummy function (<foreignphrase><abbrev>i.e.</abbrev></foreignphrase>
a <classname>ModuleBody</classname>).</para>
</listitem></varlistentry>
<varlistentry><term>Semantic analysis</term>
<listitem><para>
The source form is rewritten into an
<classname>Expression</classname> object, specifically a <classname>ModuleExp</classname>.
This stage handles macro expansion and lexical name binding.
It figures out which local variables are <quote>captured</quote>
by an inner function, and hence need to be heap-allocated.
(Other variables are stack-allocated in the Java local variable frame.)
Various optimizations are done, including selection of
closure representations.</para>
</listitem></varlistentry>
<varlistentry><term>Code generation</term>
<listitem><para>
The resulting <classname>ModuleExp</classname> is compiled into
one or more byte-coded classes.
This is done by invoking the virtual <literal>compile</literal>
method recursively on the <classname>Expression</classname>s, which generates
instructions (using the <literal>bytecode</literal> package) to evaluate the
expression and leave the result on the Java operand stack.
At the end we ask the <literal>bytecode</literal> package to write out the resulting
classes and methods.  They can be written to a file (for
future use), or into byte arrays in memory.</para>
</listitem></varlistentry>
<varlistentry><term>Loading</term>
<listitem><para>
The compiled bytecodes are loaded into the Kawa
run-time.  In the case of code that is compiled and then
immediately executed, the compiled code can be immediately
turned into Java classes using the Java <classname>ClassLoader</classname> feature.
(That is how the read-eval-print loop works.)
An instance of the compiled sub-class of <classname>ModuleBody</classname>
is created and <literal>run</literal>, which normally produces
various side-effects.</para>
</listitem></varlistentry>
</variablelist></para>
</sect1>

<sect1 id="Expressions"><title>Expressions</title>
<para>
The abstract <literal>Expression</literal> class represents partially processed expressions.
These are in principle independent of the source language,
though there are still some Scheme assumptions wired in.</para>
<programlisting>
class <classname>Expression</classname>
{ ...;
  public abstract Object eval
    (Environment e);
  public abstract void compile
    (Compilation comp, Target targ);
}
</programlisting>
<para>
The <literal>eval</literal> method evaluates the
<classname>Expression</classname> in the given
<classname>Environment</classname>.
The <literal>compile</literal> method is called when we are compiling
the body of a procedure.  It is responsible for generating bytecodes
that evaluate the expression, and leave the result in a result
specified by the <classname>Target</classname> parameter.
This is usually the Java evaluation stack,
but we will go into more detail later.</para>
<programlisting>
class <classname>QuoteExp</classname> extends Expression
{ ...;
  Object value;
  public QuoteExp(Object val)
  { value = val; }
  public Object eval(Environment env)
  { return value; }
  public void compile
    (Compilation comp, Target target)
  { comp.compileConstant (value, target); }
}
</programlisting>
<para>
A <literal>QuoteExp</literal> represents a literal (self-evaluating form),
or a quoted form.</para>
<programlisting>
class <classname>ReferenceExp</classname> extends Expression
{ ...;
  Symbol symbol;
  Declaration binding;
}
</programlisting>
<para>
A <literal>ReferenceExp</literal> is a reference to a named variable.
The <literal>symbol</literal> is the source form identifier.
If <literal>binding</literal> is non-null, it is the lexical
binding of the identifier.</para>
<programlisting>
class <classname>ApplyExp</classname> extends Expression
{ ...;
  Expression func;
  Expression[] args;
}
</programlisting>
<para>
An <literal>ApplyExp</literal> is an application of a procedure <literal>func</literal>
to an argument list <literal>args</literal>.</para>
<programlisting>
class <classname>ScopeExp</classname> extends Expression
{ ...;
  ScopeExp outer;  // Surrounding scope.
  public Declaration add_decl(Symbol name)
  { ...Create new local variable... }
}
</programlisting>
<para>
A <literal>ScopeExp</literal> is a abstract class that represents a lexical
scoping construct.  Concrete sub-classes are <literal>LetExp</literal>
(used for a <literal>let</literal> binding form) and <literal>LambdaExp</literal>.</para>
<programlisting>
class <classname>LambdaExp</classname> extends ScopeExp
{ ...;
  Symbol name; // Optional.
  Expression body;
  int min_args;
  int max_args;
}
</programlisting>
<para>
The Scheme primitive syntax <literal>lambda</literal> is translated
into a <literal>LambdaExp</literal>, which represents anonymous procedures.
Each <literal>LambdaExp</literal> is compiled into a different bytecoded class.
Invoking <literal>eval</literal> causes the <literal>LambdaExp</literal> to be compiled
into a class, the class to be loaded, an instance of the
class to be created, and the result coerced to a <literal>Procedure</literal>.</para>
<para>
Other sub-classes of <literal>Expression</literal> are
<literal>IfExp</literal> (used for conditional expressions);
<literal>BeginExp</literal> (used for compound expressions);
<literal>SetExp</literal> (used for assignments);  and
<literal>ErrorExp</literal> (used where a syntax error was found);</para>
</sect1>

<sect1 id="Semantic-analysis"><title>Semantic analysis</title>
<para>
The translation phase takes a top-level form (or body),
and generates a <literal>ModuleExp</literal>, which is a top-level expression.
This is done using a <literal>Translator</literal>, which keeps track of
lexical bindings and other translation state.</para>
<programlisting>
class <classname>Translator</classname>
{ ...;
  public Expression rewrite(Object exp)
  { ... }
  public Expression syntaxError
   (String message) { ... }
}
</programlisting>
<para>
The <literal>rewrite</literal> method converts a Scheme source form to
an <literal>Expression</literal>.  The <literal>syntaxError</literal>
method is called when a syntax error is seen.
It prints out the current source filename and line number with
the given <literal>message</literal>.</para>

<sect2 id="Syntax-and-Macros"><title>Syntax and Macros</title>
<programlisting>
class <classname>Syntax</classname>
{ ...;
  public abstract Expression rewrite
    (Object obj, Translator tr);
}
</programlisting>
<para>
The <literal>rewrite</literal> method in <literal>Translator</literal> checks for
syntactic keywords and macros.  If the <literal>car</literal> of
a <quote>call</quote> is a <literal>Syntax</literal> or if it is a <literal>Symbol</literal>
that is bound to a <literal>Syntax</literal>, then its <literal>rewrite</literal>
method is called.</para>
<para>
As an example, this trivial class implements <literal>quote</literal>:</para>
<programlisting>
class <classname>quote</classname> extends Syntax
{ ...;
  public Expression rewrite
    (Object obj, Translator tr)
  { // Error-checking is left out.
    return new QuoteExp(((Pair)obj).car);
  }
}
</programlisting>
<para>
Much more complicated is the <literal>Syntax</literal> that implements
<literal>define-syntax</literal>.</para>
<programlisting>
class <classname>define_syntax</classname> extends Syntax
{ ...;
  public Expression rewrite
    (Object obj, Translator tr)
  {  enter (new SyntaxRules (...)); }
}
</programlisting>
<para>
The result is a <literal>SyntaxRules</literal> object, which contains an encoded
representation of the patterns and templates in the <literal>syntax-rules</literal>.
This is in its own right a <literal>Syntax</literal> object.</para>
<programlisting>
class <classname>SyntaxRules</classname> extends Syntax
{ ...;
  SyntaxRule[] rules;
  public Expression rewrite
    (Object obj, Translator tr)
  {
    Object[] v = new Object[maxVars];
    for (int i = 0;  i &lt; rules.length;)
    {
      SyntaxRule r = rules[i++];
      if (r.match (obj, v))
        return r.execute_template(v, tr);
    }
    return tr.syntaxError
      ("no matching syntax-rule");
  }
}
</programlisting>
<para>
Contrast evaluating a procedure definition (<literal>lambda</literal>), which
causes a new <emphasis>sub-class</emphasis> of <literal>Procedure</literal>
to be created and compiled, while evaluating
a <literal>define-syntax</literal> only causes a new
<emphasis>instance</emphasis> of <literal>SyntaxRules</literal> to be created.
</para>
</sect2>
</sect1>

<sect1 id="Eval"><title>Interpretation: Eval</title>
<para>
Many people think of Scheme, Lisp, and ECMAScript as <quote>interpreted</quote>
languages, though many of these languages have compilers.
What these languages do have is <literal>eval</literal> - that is a command
that at run-time takes a source program, and evaluates it.
They may also have an interactive read-eval-print interface.
For such uses a traditional interpreter is easiest and most responsive.
Therefore, high-end Lisp systems traditionally provide both a compiler
and an interpreter.  Such duplication is expensive, in terms of size,
development effort, and testing.  If one has load-and-go capabilities,
that is the abilility to efficiently load a compiled program into
a running application, then one can simply implement <literal>eval</literal>
as a compile followed by a load.</para>
<para>
When we compile to Java bytecodes, we create one or more files in
the <literal>.class</literal> format.  The standard Java class
<classname>java.lang.ClassLoader</classname> has a method
<function>defineClass</function>
that takes a byte array laid out in the format of a <literal>.class</literal>,
and from it dynamically creates a new class in the existing Java run-time.
(This facility is used for <quote>applets</quote> downloaded accross
the Network.)  Kawa uses this scheme to implement <literal>eval</literal>,
and it works well.  Because <function>ClassLoader.defineClass</function>
takes an array, rather than a file, we can compile and load entirely
inside the Kawa run-time, without having to go via the filesystem
for temporary files, as a traditional compiler batch does.  The result
is near-instant response.</para>
<para>
There is a tradeoff, though.  Doing a compile+load is a very heavy-duty
operation, compared to a simply interpreting an expression.  It
creates a lot of temporary objects.  Worse, it also creates some
temporary classes, and some Java implementations do not garbage collect
unused classes.</para>
<para>
Kawa uses a compromise strategy.  If the <classname>Expression</classname>
is <quote>simple</quote>, it is interpreted directly, using
the <function>Expression.eval</function>.  Otherwise, it is compiled.
Simple expressions include literals, (global) variable access,
assignment, and function application.
Implementing <function>eval</function> in those cases is trivial.
Expressions that define new
local bindings (such as lambda expressions and <literal>let</literal> forms)
do not implement <literal>eval</literal>.  If the user types in such an
expression, it is wrapped inside a dummy function,
compiled to bytecodes, and immediately executed.  This is to avoid dealing
with lexical binding in the evaluator.</para>
<para>
A <literal>ModuleExp</literal> represents a top-level form:</para>
<programlisting>
class <classname>ModuleExp</classname> extends LambdaExp
{ ...;
  public Object eval_module
      (Environment env) {
    if (body_is_simple) // Optimization
      return body.eval (env);
    Object v = eval (env);
    return ((ModuleBody) v).run (env);
  }
}
</programlisting>
<para>
<literal>ModuleExp</literal> is a sub-class of <literal>LambdaExp</literal>,
since it is actually a dummy function created by
wrapping the top-level forms in an implicit <literal>lambda</literal>.
The <literal>eval_module</literal> method evaluates the top-level forms.
If the body is not simple, it invokes the <literal>eval</literal>
in <literal>LambdaExp</literal> (which invokes the compiler).
The result of <literal>eval</literal> is a <literal>ModuleBody</literal>,
which we can <literal>run</literal>.</para>
</sect1>

<sect1 id="Code-generation"><title>Code generation</title>
<para>
A <classname>Compilation</classname> object manages the classes, methods, and
temporary state generated as a result of compiling a
single top-level <literal>ModuleExp</literal>.</para>
<programlisting>
class <classname>Compilation</classname>
{ ...;
  ClassType[] classes;
  boolean immediate;
  public ClassType addClass
    (LambdaExp lexp, String name)
  { ... }
  public ClassType(ModuleExp exp, ...)
  { ...; addClass (exp, ...); }
}
</programlisting>
<para>
Each <literal>Compilation</literal> may create one or more <literal>ClassType</literal>
objects, each of which generates
the bytecodes for one class.  Each <literal>ClassType</literal> is generated
from a <literal>LambdaExp</literal>, including the top <literal>ModuleExp</literal>.
The boolean <literal>immediate</literal> is true if we are compiling for immediate loading,
and is false if the target is one or more <literal>.class</literal> files.</para>
<para>
The <literal>addClass</literal> method does all the work to
compile a given <literal>LambdaExp</literal>.  It creates a <literal>ClassType</literal>,
adds it to <literal>Compilation</literal>'s <literal>classes</literal> array,
and generates <literal>Method</literal> objects for the constructor and the
main <literal>apply<replaceable>X</replaceable></literal> method.
Once the <literal>apply<replaceable>X</replaceable></literal>
<literal>Method</literal> has been created, <literal>addClass</literal>
emits some bytecodes to set up the
incoming parameters, and then invokes the virtual <literal>compile</literal>
method on the body of the <literal>LambdaExp</literal>, which generates
the code that does the actual work of the procedure.</para>
<para>
The <literal>Compilation</literal> constructor gets a <literal>ModuleExp</literal>,
which it passes to <literal>addClass</literal>.  The <literal>compile</literal>
method of <literal>LambdaExp</literal> (which gets called for all <literal>lambda</literal>s
except the dummy top-level) also calls <literal>addClass</literal> to generate
the class corresponding to the <literal>lambda</literal>, and then it emits
instructions to create a new instance of the generated <literal>Procedure</literal> class,
and pushes it on the Java stack.</para>

<sect2 id="Targets"><title>Targets</title>
<para>
Most operations in the Java VM leave their result on the VM stack,
where they are available for succeeding operations.
The obvious and general way to compile an expression is therefore to generate
bytecode instructions that leave the result (in the form
of a <classname>Object</classname> reference) on the stack.
This handles most cases quite well, but we can do better.
We specify a <classname>Target</classname> parameter when invoking
the <function>compile</function> method;  the <classname>Target</classname>
specifies where to leave the result.
</para>
<programlisting>
public abstract class <classname>Target</classname>
{ ...;
  public abstract void compileFromStack
    (Compilation comp, Type stackType);
  public static final Target Ignore
  = new IgnoreTarget();
}
</programlisting>
<para>
An <classname>Expression</classname>'s <function>compile</function> method
does not have to handle all the kinds of <classname>Target</classname>s,
as long as it can generate code to leave the result on the VM stack,
and then invoke <function>compileFromStack</function>,
which is responsible for moving the result to the actual target.</para>
<para>
The simplest <classname>Target</classname> is an
<classname>IgnoreTarget</classname>.  It is used when the
result of an expression will be ignored, but we still need to evaluate
it for possible side-effects.  The implementation of
<function>IgnoreTarget.compileFromStack</function> just emits
an instruction to pop a value from the VM stack.
Expressions that have no side-effects can check if the target
is an <classname>IgnoreTarget</classname>, and then immediately
return.  This saves a useless push-pop pair.</para>
<para>
The usual <classname>Target</classname> is an
<classname>StackTarget</classname>.  This specifies that an expression
should leave the result on the VM stack.
Normally, the type of the result is <classname>Object</classname>,
but a <classname>StackTarget</classname> can specify some other
expected type, when that can be determined.
The implementation of <function>StackTarget.compileFromStack</function>
is also trivial:  If the type of the result on the stack is a sub-type
of the expected target type, nothing needs to be done;
otherwise, it generates code to do the type conversion.</para>
<para>
Things get more interesting when we come to
<classname>ConditionalTarget</classname>.</para>
<programlisting>
public class <classname>ConditionalTarget</classname>
    extends Target
{ ...;
  public Label ifTrue, ifFalse;
}
</programlisting>
<para>
A <classname>ConditionalTarget</classname> is used when compiling
the test expression in a conditional.  The expression is
evaluated as a boolean value;  if the result is true,
control transfers to <literal>ifTrue</literal>;  otherwise
control transfers to <literal>ifFalse</literal>.
Using <classname>ConditionalTarget</classname> makes it straight-forward
to generate optimal code for nested conditionals, including
<literal>and</literal> and <literal>or</literal> macros, and
(when inlining) functions such as <literal>not</literal>
and <literal>eq?</literal>.</para>
<!--
<para>
Finally, <classname>TailTarget</classname> is like a
<classname>StackTarget</classname>, but in <quote>tail</quote> position.
(<foreignphrase><abbrev>I.e.</abbrev></foreignphrase> it is the last thing done
in a function.)  It is used to do (restricted) tail-recursion-elimination.
</para>
-->
</sect2>

<sect2 id="bytecode-package"><title>The <literal>bytecode</literal> package</title>
<para>
The <literal>ClassType</literal> and <literal>Method</literal> classes are in a separate
<literal>gnu.bytecode</literal> package, which is an intermediate-level
interface to code generation and Java <literal>.class</literal> files.
It is essentially independent of Scheme or the rest of Kawa.</para>
<programlisting>
class <classname>ClassType</classname> extends Type
{ ...;
  CpoolEntry[] constant_pool;
  Method methods; // List of methods.
  Field fields; // List of fields.
  public Field addField
    (String name, Type type, int flags)
  { ...Create new field... }
  public method addMethod(String name,...)
  { ...Create new method... }
  public void writeToStream
    (OutputStream stream) { ... }
  public void writeToFile(String filename)
  { ... }
  public byte[] writeToArray()
  { ... }
}
</programlisting>
<para>
The <literal>ClassType</literal> class is the main class of the <literal>bytecode</literal> package.
It  manages a list <literal>Field</literal>s, a list of <literal>Method</literal>s,
and the constant pool.
There are utility methods for adding new fields, methods, and constant
pool entries.</para>
<para>
When the <classname>ClassType</classname> has been fully built, the
<function>writeToFile</function> method
can be used to write out the contents into a file.
The result has the format of a <literal>.class</literal> file <citation>JavaVmSpec</citation>.
Alternatively, the class can be written
to an internal byte array (that has the same layout as a <literal>.class</literal>
file) using the <function>writeToArray</function> method.
The resulting byte array may be used by a <literal>ClassLoader</literal>
to define a new class for immediate execution.
Both of the these methods are implemented on top of the more
general <function>writeToStream</function>.</para>
<para>
Each method is represented by a <literal>Method</literal> object.</para>
<programlisting>
class <classname>Method</classname> implements AttrContainer
{ ...;
  Type[] arg_types;
  Type return_type;
  Attribute attributes;
}
</programlisting>
<para>
An <classname>AttrContainer</classname> is an object that
contains zero or more <classname>Attribute</classname>s.
The Java <literal>.class</literal> file format is quite extensible.
Much of the information is stored in named <firstterm>attributes</firstterm>.
There are standard attributes, but an application can also define
new ones (that are supposed to be ignored by applications that
do not understand them).  Each class file may have a set of top-level
attributes.  In addition, each field and method may have attributes.
Some standard attributes may have nested sub-attributes.</para>
<programlisting>
public abstract class <classname>Attribute</classname>
{ ...;
  AttrContainer container;
  String name;
}
</programlisting>
<para>
An <classname>Attribute</classname>'s <literal>container</literal>
specifies who owns the attribute.
The attribute also has a <literal>name</literal>, plus methods
to gets its size, write it out, etc.</para>
<para>
The most interesting (and large) standard <classname>Attribute</classname>
occurs in a method and has the name <literal>"Code"</literal>.  It
contains the actual bytecode instructions of a non-native non-abstract method,
and we represent it using <classname>CodeAttr</classname>.</para>
<programlisting>
class <classname>CodeAttr</classname> extends Attribute
{ ...;
  Variable addLocal(Type t, String name)
  { ... }
  public void emitLoad(Variable var)
  { ... }
  public void emitPushInt(int i)
  { ... }
  public void putLineNumber(int lineno)
  { ... }
}
</programlisting>
<para>
As an example of the level of functionality,
<literal>emitPushInt</literal> compiles code to push an integer
<replaceable>i</replaceable> on stack.
It selects the right instruction, and if <replaceable>i</replaceable> is too
big for one of the instructions that take an inline value,
it will create a constant pool entry for <literal>i</literal>,
and push that.</para>
<para>
The method <literal>addLocal</literal> creates a new local variable
(and makes sure debugging information is emitted for it),
while <literal>emitLoad</literal> pushes the value of
the variable on the stack.</para>
<para>
Kawa calls <literal>putLineNumber</literal> to indicate that the current location
corresponds to a given line number.  These are emitted in the
<literal>.class file</literal>, and most Java interpreters will use them
when printing a stack trace.</para>
<para>
We use <literal>gnu.bytecode</literal> mainly for generating
<literal>.class</literal> files, but it also has classes to
read <literal>.class</literal> files, and also classes to print
a <classname>ClassType</classname> in readable format.
The combination makes for a decent Java dis-assembler.</para>
<para>
There are other toolkits for creating or analyzing
<literal>.class</literal> files, but <literal>gnu.bytecode</literal>
was written to provide a lot of support for code generation
while having little overhead.  For example, some assemblers
represent each instruction using an <classname>Instruction</classname>
instance, whereas <literal>CodeAttr</literal> just stores all
the instruction in a byte array.  Using a linked list of
<classname>Instruction</classname>s may be more <quote>object-oriented</quote>,
and it does make it easier to do peep-hole optimizations,
but the time and space overhead compared to using an array of bytes is huge.
(If you do need to do peephole optimizations, then it makes
sense to use a doubly-linked list of <classname>Instruction</classname>s,
but to use that in conjunction with <literal>CodeAttr</literal>.
You will in any case want a byte-array representation for input and output.)
</para>
</sect2>

<sect2 id="Literals"><title>Literals</title>
<para>
A Scheme quoted form or self-evaluating form expands to a <literal>QuoteExp</literal>.
Compiling a <literal>QuoteExp</literal> would seem a trivial exercise, but it is not.
There is no way to embed (say) a list literal in Java code.
Instead we create a static field in the top-level class
for a each (different) <literal>QuoteExp</literal> in the body we are compiling.
The code compiled for a <literal>QuoteExp</literal> then just needs
to load the value from the corresponding static field.
The tricky part is making sure that the static field gets
initialized when the top-level class is loaded to the
value of the literal.  This is easy when compiling for immediate
execution: after the compiled class has been loaded and initialized, we use
reflection to set the field to the literal value.  When compiling
to a class file, things are harder.</para>
<para>
The basic idea is that for:</para>
<programlisting>
(define (foo) '(3 . 4))
</programlisting>
<para>
we compile the equivalent of:</para>
<programlisting>
class <classname>foo</classname> extends Procedure0
{
  Object static lit1
    = Pair.make(IntNum.make(3),
                IntNum.make(4));
  public Object apply0()
  { return lit1; }
}
</programlisting>
<para>
When the compiled class <literal>foo</literal> is loaded, we do:</para>
<programlisting>
Class fooCl = Class.forName("foo");
Procedure fooPr
  = (Procedure) fooCl.newInstance ();
// Using foo:
Object result = fooPr.apply0 ();
</programlisting>
<para>
How does the Kawa compiler generate the appropriate <literal>Pair.make</literal>
expression as shown above?  In earlier versions of Kawa, a class whose
instances could be literals implemented
the <literal>Compilable</literal> interface.  Then the compiler just called
the methods in <literal>Compilable</literal>, and these would generate the
code needed to re-create the literal.
This had the advantage that the compiler was not limited to a few
classes of literals it knew about.  One problem is that it caused
cross-package dependencies, since any class that could be a literal
has to implement <classname>gnu.expr.Compilable</classname>.
Another problem was that writing the <classname>Compilable</classname>
methods required knowing how <literal>gnu.bytecode</literal> works.</para>
<para>
The key insight is that saving compile-time literals and then restoring
them at run-time is a kind of <quote>object persistence</quote>, similar
to that offered by Java serialization.  One option considered was to
use standard serialization, but that required some way to store the
serialized data in a class file.
The article <ulink
url="http://java.sun.com/products/jfc/tsc/articles/persistence/">Long-Term
Persistence for JavaBeans</ulink> suggested an alternative.
I realized that using <classname>Externalizable</classname> classes provided
the more abstract serialization we needed.</para>
<para>
Let us start with a summary:  An object that can be a literal must implement
the <classname>java.io.Externalizable</classname> interface.  When the
compiler need to generate a reference to a literal value, it calls the
object's <function>writeExternal</function> method.  The
<function>writeExternal</function> method expects an argument that
implements the <classname>java.io.ObjectOutput</classname> interface.
The actual argument is a <classname>LitTable</classname> object owned
by the compiler.  A <function>writeExternal</function> method
can call the standard <classname>ObjectOutput</classname> methods, such
as <function>writeObject</function>, <function>writeInt</function>,
and so on.  The <classname>LitTable</classname> remembers the
values that were passed to it in these <function>writeObject</function>,
<function>writeInt</function>, etc calls, and creates an
<quote>argument list</quote> from those values.  When the
<function>writeExternal</function> returns, the <classname>LitTable</classname>
will take the argument list, and look for a matching constructor in
the literal's class, using reflection.  It will also look for methods named
<function>make</function> or <function>set</function>.
If found, the compiler will generate a call to the matching method.
Simple values in the argument list will be pushed on the JVM stack directly;
object references will use values generated using previous
calls to <function>writeExternal</function>.</para>
<para>
Here are more details on how the compiler selects which method
to invoke to re-create an object.
If the compiler detects a recursive <function>writeObject</function> call
with the object as an argument while <function>writeExternal</function>
is called on the object, then the object cyclically references itself.
In that case, the compiler must take care to construct the object so
that the cycle gets reproduced at run-time.
This is done by first generating a call to the default constructor,
and saving the result in a static field.  The argument list is evaluated,
with recursive references using the saved static field.  Then we
call a method to properly initialize the object using the evaluated
argument list.  The compiler looks for a method named <function>set</function>
with a parameter list matching the argument list.  If there is no such
method, the compiler gives up.  (In the future, we could use JavaBeans
introspection, or look for a Java2 <classname>ObjectStreamField</classname> to
determine how to set the properties.)</para>
<para>
If an object does not have a cycle, the compiler first looks for a
matching static method named <function>make</function>.  If it
does not find one, it looks a matching constructor.  In the latter
case, the compiler must also check to see if there is
a zero-argument <function>readResolve</function> method, which Java 2
serialization uses to replace an object by a canonical object.
(Kawa does not require Java 2, but <classname>LitTable</classname>
does respect this Java 2 extension to serialization.)
As a last resort, the compiler looks for a default constructor
followed by <function>set</function>, as in the cycle case.</para>
<para>The <function>writeExternal</function> method of some classes
may generate a variable number of values.
Therefore, if a constructor or method takes an array parameter, then
<classname>LitTable</classname> will consider it as matching the
argument list if the latter contains an <classname>int</classname>
(written using <function>writeInt</function>) followed by that
number of arguments of the component type of the array.
(One could argue that this feature is an unneeded kludge, since
there is the alternative that <function>writeExternal</function>
could just call <function>writeObject</function>
with a single array argument, instead of calling
<function>writeObject</function> a variable number of times.
However, that would expose the internal array into the externalization
protocol, which is wrong.)</para>
<para>
Advantages of this implementation include:
<itemizedlist>
<listitem>
<para>
No explicit dependency on any class in the the <literal>gnu.expr</literal>
package.  All a class needs to be used in literals is to implement
<classname>Externalizable</classname>, and provide a matching method
for creating object instances.</para>
</listitem>
<listitem>
<para>
No need to write special code to handle literals.</para>
</listitem>
<listitem><para>
Literals are re-created using efficient code at class initialization time.
</para></listitem>
<listitem><para>
Automatically handles cycles and duplicate references.
(Standard Scheme does not
support self-referential constants, but for example Common Lisp does.
See section 25.1.4 <quote>Similarity of Constants</quote> in
<citation>CommonLisp2</citation>.)</para></listitem>
<listitem><para>
Only requires standard JDK 1.1 features.</para></listitem>
</itemizedlist>
</para>
</sect2>
</sect1>

<sect1 id="Declarations"><title>Class, types, and declarations</title>
<para>
Java supports <quote>reflection</quote>, that is the ability to determine
and examine the class of an object, and use the class at run-time
to extract fields and call methods using names specified at run-time.
Kawa, like some other Scheme implementations, also supports reflection.</para>
<para>
It seems plausible to represent a type using a
<classname>java.lang.Class</classname> object, since that is what
the Java reflective facility does.
<!--  (Nine static pseudo-classes
represent the primitive non-object types.)-->
Unfortunately, there are at least
three reasons why Kawa needs a different representation:
<itemizedlist>
<listitem><para>
We may need to refer to classes that do not exist yet, because
we are in the process of compiling them.</para></listitem>
<listitem><para>
We want to be able to specify different high-level types that are
represented using the same Java type.  For example, we might want
to have integer sub-ranges and enumerations (represented using
<classname>int</classname>), or different kinds of function types.
</para></listitem>
<listitem><para>
We want to associate different conversion (coercion) rules for different
types that are represented using the same class.</para></listitem>
</itemizedlist>
</para>
<para>
Kawa represents types using instances of <classname>Type</classname>:</para>
<programlisting>
public abstract class <classname>Type</classname>
{ ...;
  String signature;  // encoded type name
  int size;
  public final String getName() { ... }
  public boolean isInstance(Object obj)
  { ... }
  public void emitIsInstance(CodeAttr c)
  { ... }
}
</programlisting>
<para>
The method <function>isInstance</function> tests if an object
is a member of this type, while <function>emitIsInstance</function>
is called by the compiler to emit a run-time test.
Note that the earlier mentioned <classname>ClassType</classname>
extends <classname>Type</classname>.</para>
<para>
Kawa follows the convention (used in RScheme <citation>RScheme</citation>
and other Scheme dialects) that identifiers of the form
<function>&lt;<replaceable>typename</replaceable>&gt;</function>
are used to name types.  For example Scheme vectors are
members of the type <literal>&lt;vector&gt;</literal>.
This is only a convention and these names are regular identifiers,
expect for one little feature:  If such an identifier is used,
and it is not bound, and <replaceable>typename</replaceable> has the form
of a Java type, then a corresponding <classname>Type</classname> is returned.
For example <classname>&lt;java.lang.String[]&gt;</classname>
evaluates to a <classname>Type</classname> whose values are references to
Java arrays whose elements are references to Java strings.</para>
<para>
As a simple example of using type values, here is the
definition of the standard Scheme predicate <function>vector?</function>,
which returns true iff the argument is a Scheme vector:</para>
<programlisting>
(define (vector? x)
  (instance? x &lt;vector&gt;)
</programlisting>
<para>
The primitive Kawa function <function>instance?</function> implements
the Java <literal>instanceof</literal> operation, using
<classname>Type</classname>'s <function>isInstance</function> method.
(In compiled code, if the second operand is known at compile-time,
then the compiler uses <classname>Type</classname>'s
<function>emitIsInstance</function> method to generate better code.)</para>
<para>
The traditional benefits of adding types to a dynamic language
include better code generation, better error checking, and
machine-checkable interface documentation.  These benefits require either
type inference or (optional) type declarations.  Kawa does allow
the types of parameters to be declared, and does some very simple
local type inference.  In some cases this lets <quote>unboxed</quote>
values (such as raw Java <classname>int</classname>) be passed
from one function to another without having to allocate an object.
While Kawa has a framework for working with types,
it does need a more systematic approach.</para>
<para>
Kawa includes the record extension which
allows a new record type to be specified and created at run-time.
It is implemented by creating a new <classname>ClassType</classname>
with the specified fields, and loading the class
using <classname>ClassLoader.defineClass</classname>.
The record facility consists of a number of functions executed at run-time.
Many people prefer an approach based on declarations
that can be more easily analysed at compile-time.  (This is why
the record facility was rejected for R5RS.)  A more declarative and
general class definition facility is planned but not yet implemented.</para>
<!-- Modules:
<para>
Some kind of module system is desirable.  One reason is to
control names and names clashes;  another reason is so that
the compiler can map global variables references to their
definitions. This makes it easier to do better optimizations.
It is tempting to define a module as a kind of class:
A simple module is a packaging of data and function definitions,
and it is easy to map these into static fields and methods of a class.
Controlling which components are exported is similar to specifying
visibility (<literal>public</literal> or <literal>private</literal>).
What is more challenging is how to model import lists, or module
signature/interfaces.  Perhaps we can use Java interface types.</para>
-->
</sect1>

<sect1 id="Low-level"><title>Low-level Java access</title>
<para>
Many implementations of a high-level language provide an interface
to functions written in a lower-level language, usually C.
Kawa has such a <quote>Foreign Function Interface</quote>,
but the lower-level language it targets is Java.
A <classname>PrimProcedure</classname> is a <classname>Procedure</classname>
that invokes a specified Java method.</para>
<programlisting>
public class PrimProcedure
    extends ProcedureN
{ ...;
  Method method;
  Type retType;
  Type[] argTypes;
}
</programlisting>
<para>
The following syntax evaluates to a <classname>PrimProcedure</classname>
such that when you call it, it will invoke
the static method named <replaceable>method-name</replaceable>
in class <replaceable>class</replaceable>
with the given <replaceable>arg-type</replaceable>s
and <replaceable>result-type</replaceable>:</para>
<programlisting>
(primitive-static-method <replaceable>class</replaceable> <replaceable>method-name</replaceable>
  <replaceable>return-type</replaceable> (<replaceable>arg-type</replaceable> ...))
</programlisting>
<para>
When such a function is called, Kawa makes sure to convert the
arguments and result between the Scheme types and Java types.
For example:</para>
<programlisting>
(primitive-static-method
   &lt;java.lang.Character&gt; "toUpperCase" 
   &lt;char&gt; (&lt;char&gt;))
</programlisting>
<para>
This is a function that converts a Scheme character
(represented using a <literal>&lt;kawa.lang.Char&gt;</literal> object),
to a Java <classname>char</classname>, applies the
standard <function>java.lang.Character.toUpperCase</function> method,
and converts the result back to a Scheme character.
Normally, the Java reflection features are used to call the
specified method.  However, if the <function>primitive-static-method</function>
is used directly in the function position of an application,
then the compiler is able to inline the <classname>PrimProcedure</classname>,
and emit efficient <literal>invokestatic</literal> bytecode operations.
That is the usual style, which is used to define
many of the standard Scheme procedures,
such as here <function>char-upcase</function>:</para>
<programlisting>
(define (char-upcase ch) 
  ((primitive-static-method
    &lt;java.lang.Character&gt; "toUpperCase" 
    &lt;char&gt; (&lt;char&gt;)) 
   ch)) 
</programlisting>
<para>
Similar forms <function>primitive-virtual-method</function> and
<function>primitive-interface-method</function>
are used to generate virtual method calls and interface calls,
while <function>primitive-constructor</function> is used to
create and initialize a new object.</para>
<para>
You can access instance and static fields of an object using
similar macros.  For example, to get the time-stamp from an
<classname>Event</classname>, do:</para>
<programlisting>
((primitive-get-field &lt;java.lang.Event&gt;
  "when" &lt;long&gt;)
 evt)
</programlisting>
<para>
Kawa also has low-level operations for working with Java arrays.
All these primitive operations are inlined to efficient byte code operations
when the compiler knows that the procedure being called is a primitive;
otherwise, the Java reflection features are used.</para>
</sect1>

<sect1 id="complications"><title>Scheme complications</title>
<para>Scheme has a few features that do not map easily into Java.
We discussed closures earlier;  next we will discuss
tail-call-elimination, continuations,
and multiple return values.
</para>

<sect2 id="Multiple-values"><title>Multiple values</title>
<para>
R5RS defines a procedure <function>values</function>, which allows
an expression or a function to yield multiple (or zero) values, rather
then being restricted to a single result.
However, the multiple values can only be passed to the
<function>call-with-values</function> procedure.  There is no automatic
coercion from a multiple values to a single value, as in Common Lisp.
This makes it easy to implement multiple values in a way that does
not slow down code that does not use the feature, which is most
Scheme code.  Kawa uses a helper class <classname>Values</classname>:
</para>
<programlisting>
class <classname>Values</classname>
{ ...
  private Object[] vals;
  public static final Values empty
    = new Values(new Object[0]);
}
</programlisting>
<para>
The <function>values</function> procedure just creates a new
<classname>Values</classname> object using its arguments.
However, if there is only a single value, it returns the value
unchanged.  If there are zero values, <literal>Values.empty</literal>
is returned.  (This value is the same as <literal>#!void</literal>,
which in Kawa is used for the result of a definition or assignment,
and whose print-out is suppressed.)  The <classname>Values</classname>
instance is returned, with no special handling.
The only part of Kawa that needs to know about <classname>Values</classname>
is the <function>call-with-values</function> procedure;  it needs to check
if it was passed a <classname>Values</classname> object, or just
a regular Scheme value.
</para>
<para>
This implementation satisfies the goal of no extra overhead for
programs that do not use multiple values, and the cost is reasonable
for programs that do.  It is not as good a returning the multiple results
on the stack, as some Scheme and Lisp implementations do, but that is not
do-able in a Java context.
</para>
<para>
Another implementation would be needed if we want the Common Lisp
behavior where multiple values are automatically coerced to the first
value in single-value contexts.  One way to implement that would be
move the <function>apply</function> methods to always take an extra
"continuation" parameter.  Then <function>values</function> can
check the kind of continuation it is returning to.  Having the return
context explicitly passed has other uses too, though it adds some
extra overhead to the common case.
</para>
</sect2>

<sect2 id="Continuations"><title>Continuations</title>
<para>
Scheme continuations <quote>capture</quote> the current execution
state.  They can be implemented by copying the stack, but
this requires non-portable native code.  Kawa continuations
are implemented using Java exceptions, and can be used to
prematurely exit (throw), but not to implement co-routines
(which should use threads anyway).</para>
<programlisting>
class <classname>callcc</classname> extends Procedure1
{ ...;
  public Object apply1(Object arg1)
  {
    Procedure proc = (Procedure) arg1;
    Continuation cont
       = new Continuation ();
    try { return proc.apply1(cont); }
    catch (CalledContinuation ex)
      {
        if (ex.continuation != cont)
             throw ex;  // Re-throw.
        return ex.value;
      }
    finally
      {
        cont.mark_invalid();
      }
  }
}
</programlisting>
<para>
This is the <literal>Procedure</literal> that implements
<function>call-with-current-continuation</function>.
It creates <literal>cont</literal>, which is the <quote>current continuation</quote>,
and passes it to the incoming <literal>proc</literal>.
If <literal>callcc</literal> catches a <literal>CalledContinuation</literal> exception it means
that <literal>proc</literal> invoked some <literal>Continuation</literal>.  If it is <quote>our</quote>
continuation, return the value passed to the continuation;  otherwise
re-throw it up the stack until we get a matching handler.</para>
<para>
The method <function>mark_invalid</function> marks a continuation
as invalid, to detect unsupported invocation of <literal>cont</literal>
after <literal>callcc</literal> returns.
(A complete implementation of continuations would instead
make sure the stacks are moved to the heap, so they can be
returned to an an arbitarry future time.)</para>
<programlisting>
class <classname>Continuation</classname> extends Procedure1
{ ...;
  public Object apply1(Object arg1)
  {
    throw new CalledContinuation
	      (arg1, this);
  }
}
</programlisting>
<para>
A <literal>Continuation</literal> is the actual continuation object
that is passed to <literal>callcc</literal>'s argument;
when it is invoked, it throws a <literal>CalledContinuation</literal>
that contains the continuation and the value returned.</para>
<programlisting>
class <classname>CalledContinuation</classname>
    extends RuntimeException
{ ...;
  Object value;
  Continuation continuation;
  public CalledContinuation
    (Object value, Continuation cont)
  {
    this.value = value;
    this.continuation = cont;
  }
}
</programlisting>
<para>
<literal>CalledContinuation</literal> is the exception that is thrown
when the continuation is invoked.</para>
</sect2>
<sect2 id="Tail-calls"><title>Tail-calls</title>
<para>
Scheme requires that tail-calls be implemented without
causing stack growth.
This means that if the last action of a procedure is another
function call, then the called function's activation frame needs to
be discarded before the new function's frame is allocated.
In that case, unbounded tail-recursion does not grow the stack
beyond a bounded size, and iteration (looping) is the same as tail-recursion.
Making this work is easy using a suitable procedure calling convention,
but this is difficult to do
portably in Java (or for that matter in C), since implementing
it efficiently requires low-level procedure stack manipulation.</para>
<para>
Compiler optimizations can re-write many tail-calls into
<literal>goto</literal>s.  The most important case is self-tail-calls
or tail recursion.  Kawa rewrites these to be a simple goto to the
start of the procedure, when it can prove that is safe.  Specifically,
it does optimize Scheme's standard looping forms <literal>do</literal>
and named-<literal>let</literal>.</para>
</sect2>

<sect2 id="General-tail-call"><title>General tail-call elimination</title>
<para>
Implementing general tail-calls and continuations require being
able to manipulate the procedure call stack.  Many environments, including
the Java VM, do not allow direct manipulation of stack frames.
You have the same problem if you want to translate to portable C, without
assembly language kludges.
Hence, you cannot use the C or Java stack for the call stack, but
instead have to explicitly manage the call graph and return
addresses.  Such re-writing has been done before for
ML <citation>MLtoC</citation> and Scheme <citation>RScheme</citation>.
</para>
<para>
In Java we have the extra complication that we do not have function addresess,
and no efficient way to work with labels.  Instead, we can simulate code labels
by using switch labels.  This is more overhead than regular method
calls, so the regular <classname>Procedure</classname> interface
discussed earlier will probably remain the default.
Thus some procedures use the regular calling convention, and
others the <quote>CPS</quote> (Continuation Passing Style) calling convention.
The rest of this section explains the
<emphasis>planned</emphasis> CPS calling convention.</para>
<programlisting>
public abstract class <classname>CpsFrame</classname>
{
  CpsFrame caller;
  int saved_pc;
}
</programlisting>
<para>
Each <classname>CpsFrame</classname> represents a procedure activation.
The <literal>caller</literal> field points to the caller's frame,
while <literal>saver_pc</literal> is a switch label representing
the location in the caller.</para>
<para>
There is a single <quote>global</quote> <classname>CpsContext</classname>
which owns the generalized call <quote>stack</quote>.
There may be many <classname>CpsContext</classname> if there are
multiple threads, and in fact one <classname>CpsContext</classname>
is allocated each time a regular (non-CPS) method calls a procedure that uses
the CPS calling convention.</para>
<programlisting>
public class <classname>CpsContext</classname>
{
  CpsFrame frame;
  int pc;
  Object value;

  Object run()
  {
    while (frame != null)
      frame.do_step(this);
    return value;
  }
}
</programlisting>
<para>
Each <classname>CpsContext</classname> has a <literal>frame</literal>
which points to the currently executing procedure frame,
and <literal>pc</literal> which is a case label for the code to
be executed next in the current procedure.
The result of a function is left in the <literal>value</literal> field.
All of these these fields may be imagined as global (or per-thread)
registers, which is how you would ideally like to implement a CPS
calling convention if you had access to machine registers.
The <literal>frame</literal>, <literal>pc</literal>, and
<literal>value</literal> fields simulate the frame pointer register,
the program counter, and the function result register in a typical
computer. After creating a <classname>CpsContext</classname> with an
initial <literal>frame</literal> and <literal>pc</literal>,
you would call <function>run</function>, which uses the
<function>do_step</function> method to execute each step of a function
until we return from the initial <literal>frame</literal>
with a final <literal>value</literal>.</para>
<para>
Consider a simple Scheme source file,
which defines two functions:</para>
<programlisting>
(define (f)
  (g)
  (h))
(define (g)
  ...)
</programlisting>
<para>
This would get compiled into:</para>
<programlisting>
public foo extends CpsFrame
{
  void do_step(CpsContext context)
  {
    CpsFrame fr;
    switch (context.pc)
    {
      case 0: // top-level code
        define("f", new CpsProc(this, 1);
        define("g", new CpsProc(this, 3);
        return;
      case 1: // beginning of f
        // do a (non-tail) call of g:
        fr = g.allocFrame(context);
        fr.caller = this;
        fr.saved_pc = 2;
        context.frame = fr;
        return;
      case 2:
        // then do a tail call of h:
        fr = h.allocFrame(context);
        fr.caller = this.caller;
        fr.saved_pc = this.saved_pc;
        context.frame = fr;
        return;
      case 3:  /* beginning of g */
        ...;
    }
  }
}
</programlisting>
<para>
The entire code of the Scheme compilation unit is compiled
into one large switch statement.  Case 0 represents
the top-level actions of the program, which defines the
functions <function>f</function> and <function>g</function>.
Next comes the code for <function>f</function>, followed by the
(omitted) code for <function>g</function>.  When <function>f</function>
is called, a new <function>foo</function> frame is allocated,
and the context's <literal>pc</literal> is set to 1,
the start of <function>f</function>.</para>
<para>
The body of <function>f</function> makes two function calls,
one a non-tail function, and finally a tail-call.
Either call allocates a <classname>CpsFrame</classname>
and makes it the current one, before returning to the the main loop
of <classname>CpsContext</classname>'s <function>run</function> method.
The regular (non-tail) call saves the old current frame in the
new frame's return link.  In contrast, the tail call makes the
return link of the new frame be the old frame's return link.
When we return then from do_step, the old frame is not part
of the call chain (unless it has been captured by <function>callcc</function>),
and so it has become garbage that can be collected.</para>
<para>
At the time of writing, the CPS calling convention has not been
implemented, but I am filling in the details.  It has some extra
overhead, but also a few side benefits.  One is that we compile
an entire source file to a single Java class, and it is more convenient
when there is a one-to-one correspondence between source files and
binary files (for example in <literal>Makefile</literal>s).</para>
<para>
Another exciting possibility is that we can write a debugger
in pure Java, because we can run <literal>do_step</literal> until
some condition (break-point), examine the <classname>CpsFrame</classname>
stack, and optionally continue.</para>
</sect2>
</sect1>

<sect1 id="Benchmark"><title>Benchmark Results</title>
<para>
In one sense benchmarking Kawa is meaningless, because performance
will vary so much depending on the underlying Java implementation.
One can even take the compiled bytecode files and translate them
to native code, factoring out the Java interpreter altogether.
For example, my company Cygnus Solutions is implementing a
Java implementation based on Gcc <citation>GccJava</citation>;
it will be able to speed up compiled Kawa code substantially.</para>
<para>
While the goal of Kawa is not maximum performance, it would be
reassuring if its speed is at least comparable to other Scheme
implementations.  So I took three of the old Gabriel benchmarks
(as I found them in the Stalin distribution, by Jeffrey Mark Siskind
<quote>Qobi</quote>).  I ran them on an UltraSparc running Solaris 2.6.
I compared Kawa, running under JavaSoft's JDK 1.1.5,
with two representative Scheme implementations:
Guile is the Free Software Foundation's Scheme implementation.
It is an interpreter based on the heavily-tuned SCM (written
by Aubrey Jaffer).  Scheme48 (written by Richard Kelsey and Jonathan Rees)
compiles to a Scheme-specific bytecode, which is then interpreted 
(Note that Kawa is doing the various inlining optimizations mentioned earlier;
this makes a substantial difference, but could break some unusual programs.)
The Puzzle benchmark is based on the old Forrest Baskett benchmark,
and uses vectors and <function>do</function>-loops extensively.
Traverse creates and traverses a tree structure.
Takl is the Takeuchi function using lists as counters.
</para>
<informaltable frame="all">
      <tgroup cols="4">
	<thead>
	  <row>
	    <entry> </entry>
	    <entry>Kawa</entry>
	    <entry>Scheme48</entry>
	    <entry> Guile </entry>
	  </row>
	</thead>
	<tbody>
	  <row>
	    <entry>Puzzle</entry>
	    <entry>21s</entry>
	    <entry>14s</entry>
	    <entry>67s</entry>
	  </row>
	  <row>
	    <entry>Traverse</entry>
	    <entry>18s</entry>
	    <entry>14s</entry>
	    <entry>46s</entry>
	  </row>
	  <row>
	    <entry>Takl</entry>
	    <entry>81s</entry>
	    <entry>36s</entry>
	    <entry>87s</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>
<para>
These results show Kawa beating Guile on all benchmarks,
the first two substantially.  Scheme48 is faster, but by
less than a factor of two (on average).  It is interesting that Kawa
does as well as it does, using a bytecode designed for Java,
as opposed to Scheme48's bytecodes tailored specifically to Scheme.
</para>
</sect1>

<sect1 id="Future"><title>Current and Future Work</title>
<para>
The main current priorities of Kawa are making it fully compatible
with standard (R5RS) Scheme, implementing debugging facilities, and
making the ECMAScript support usable.
The major tasks for R5RS-compatibility are the rewrite to support
general continuations and tail-calls, plus a redesign of how macros
are implemented.</para>
<!--
<para>
The ECMAScript implementation in May 1998 includes a complete lexer,
and an almost-finished recursive-descent parser (with an optimization
to handle binary operators).  A few operations are implemented, enough
to demonstrate a very limited read-eval-print loop.  ECMAScripts objects
are dynamic mappings from names to properties, and will be implemented
using a framework that generalizes ECMAScript objects, Scheme
environments and records, database records, and more (just like a
collections framework unifies lists and vectors).  Someone else
has an an existing ECMAScript implementation; if the lawyers let us,
I plan to integrate their standard objects and functions,
with my <classname>Expression</classname> and compilation framework.</para>
-->
<para>
Implementing ECMAScript requires moving Scheme-specific code
out of the Kawa core.  We also need a more general interface 
to plug in new parsers, pre-defined functions, data types, and output
formatting.  That will make it easier to add new languages
and dialects.
Of special interest is re-implementing some of the ideas and syntax
from my earlier Q language  <citation>Bothner88</citation>. These include a
line-oriented syntax with fewer parentheses, and high-level
sequence and array operations (as in APL).</para>
<para>
Also of interest is support for Emacs Lisp.
This would require an extensive library to implement the Emacs
data types (such as buffers and windows), in addition to the
challenges of the Emacs Lisp language itself (it has different
data types and name binding rules than Scheme), but may be
a good way to build a next-generation Emacs.</para>
<para>
There is very  preliminary threads support in Kawa.
It provides an interface to Java threads that looks
somewhat like <literal>delay</literal>, except that the delayed expression
is evaluated in a new thread.  (The model is similar to to the
<quote>futures</quote> concept of MultiScheme <citation>Miller87</citation>,
but there is no implicit force, at least yet.)  Some
of the core classes (such <literal>Environment</literal>
and <literal>Translator</literal>) now support threads
with optionally separate top-level environments.</para>
<para>
An interface to graphics primitives is needed.
The new Swing toolkit seems like a more powerful
base then the old Abstract Windowing Toolkit.</para>
<!--
<para>
More sophisticated Scheme code rewriting, optimizations,
and inlining are also on the wishlist.</para>
-->
</sect1>

<sect1 id="Conclusion"><title>Conclusion</title>
<para>
Kawa is a solid implementation of Scheme with many features.
It is portable to any environment that can run Java applications.
It has active use and development, a 75-member mailing list,
and is used for a number of different projects.
Most people seem to be using it as a scripting language
for Java packages.  Other people just prefer to use Scheme,
but have to co-exist with Java.</para>
</sect1>
  
<bibliography id="Bibliography">
<title>Bibliography</title>

<biblioentry>
<abbrev>Bothner88</abbrev>
<authorgroup>
<author><firstname>Per</firstname> <surname>Bothner</surname></author>
</authorgroup>
<title>Efficiently Combining Logical Contraints with Functions</title>
<bibliomisc>Ph.D. thesis,
Department of Computer Science, Stanford University</bibliomisc>
<pubdate>1988</pubdate>
</biblioentry>

<biblioentry>
<abbrev>Budd91Arith</abbrev>
<authorgroup>
<author><firstname>Timothy</firstname> <surname>Budd</surname></author>
</authorgroup>
<title>Generalized arithmetic in C++</title>
<bibliomisc>Journal of Object-Oriented Programming</bibliomisc>
<issuenum>3(6)</issuenum> <pagenums>11-22</pagenums>
<pubdate>February 1996</pubdate>
</biblioentry>

<biblioentry>
<abbrev>CommonLisp2</abbrev>
<authorgroup>
<author><firstname>Guy L.</firstname> <surname>Steele Jr.</surname></author>
</authorgroup>
<title>Common Lisp -- The Language</title>
<bibliomisc>Second edition</bibliomisc>
<bibliomisc>Digital Press and Prentice-Hall</bibliomisc>
<pubdate>1990</pubdate>
</biblioentry>

<biblioentry>
<abbrev>DSSSL</abbrev>
<authorgroup><corpauthor>International Standards Organization</corpauthor></authorgroup>
<title>Document Style Semantics and Specification Language</title>
<pubdate>1996</pubdate>
<bibliomisc>International Standard ISO/IEC 10179:1996(E)</bibliomisc>
</biblioentry>

<biblioentry>
<abbrev>ECMAScript</abbrev>
<authorgroup><corpauthor>ECMA</corpauthor></authorgroup>
<title>ECMAScript Language Specification</title>
<bibliomisc><literal>http://www.ecma.ch/stand/ecma-262.htm</literal></bibliomisc>
</biblioentry>

<biblioentry>
<abbrev>GccJava</abbrev>
<authorgroup>
<author><firstname>Per</firstname> <surname>Bothner</surname></author>
</authorgroup>
<title>A Gcc-based Java Implementation</title>
<bibliomisc>IEEE Compcon 1997 Proceedings</bibliomisc>
<pagenums>174-178</pagenums>
<pubdate>February 1997</pubdate>
<bibliomisc>See also <literal>http://www.cygnus.com/product/javalang</literal></bibliomisc>
</biblioentry>

<biblioentry>
<abbrev>gmp</abbrev>
<authorgroup>
<author><firstname>Torbj&#xf6;rn</firstname> <surname>Granlund</surname>
</author></authorgroup>
<title>The GNU Multiple Precision Arithmetic Library</title>
<pubdate>1996</pubdate>
<bibliomisc>(<literal>Gmp</literal> and its manual are available
on most GNU archives.)</bibliomisc>
</biblioentry>

<biblioentry>
<abbrev>Ingalls86</abbrev>
<authorgroup>
<author><firstname>Daniel</firstname> <surname>Ingalls</surname></author>
</authorgroup>
<title>A Simple Technique for Handling Multiple Polymorphism</title>
<bibliomisc>ACM SIGPLAN Notices</bibliomisc>
<issuenum>21(11)</issuenum> <pagenums>347-349</pagenums>
<pubdate>November 1986</pubdate>
</biblioentry>

<!-- <bookbiblio>
<biblioentry>
<abbrev>Gcc</abbrev>
<authorgroup>
<author><firstname>Richard</firstname> <surname>Stallman</surname></author>
</authorgroup>
<title>Using and Porting GNU CC</title>
<publisher><publishername>Free Software Foundation</publishername></publisher>
<pubdate>1996</pubdate>
</biblioentry>
-->

<biblioentry>
<abbrev>JavaSpec</abbrev>
<!--<bookbiblio>-->
<authorgroup>
<author><firstname>James</firstname> <surname>Gosling</surname></author>
<author><firstname>Bill</firstname> <surname>Joy</surname></author>
<author><firstname>Guy</firstname> <surname>Steele</surname></author>
</authorgroup>
<title>The Java Language Specification</title>
<publisher><publishername>Addison-Wesley</publishername></publisher>
<copyright><year>1996</year></copyright>
<!--</bookbiblio>-->
</biblioentry>

<biblioentry>
<abbrev>JavaVMSpec</abbrev>
<!--<bookbiblio>-->
<authorgroup>
<author><firstname>Tim</firstname> <surname>Lindholm</surname></author>
<author><firstname>Frank</firstname> <surname>Yellin</surname></author>
</authorgroup>
<title>The Java Virtual Machine Specification</title>
<publisher><publishername>Addison-Wesley</publishername></publisher>
<copyright><year>1996</year></copyright>
<!--</bookbiblio>-->
</biblioentry>

<biblioentry>
<abbrev>Kaffe</abbrev>
<authorgroup>
<author><firstname>Tim</firstname> <surname>Wilkinson</surname></author>
</authorgroup>
<title>Kaffe - a free virtual machine to run Java code</title>
<bibliomisc><literal>http://www.kaffe.org/</literal></bibliomisc>
</biblioentry>

<biblioentry>
<abbrev>Kawa</abbrev>
<authorgroup>
<author><firstname>Per</firstname> <surname>Bothner</surname></author>
</authorgroup>
<title>Kawa, the Java-based Scheme System</title>
<bibliomisc><literal>http://www.cygnus.com/~bothner/kawa.html</literal></bibliomisc>
</biblioentry>

<biblioentry>
<abbrev>Miller87</abbrev>
<authorgroup>
<author><firstname>James</firstname> <surname>Miller</surname></author>
</authorgroup>
<title>MultiScheme: A Parallel Processing System based on MIT Scheme</title>
<bibliomisc>Ph.D. thesis,
Department of Electrical Engineering and Computer Science, MIT</bibliomisc>
<pubdate>1987</pubdate>
</biblioentry>

<biblioentry>
<abbrev>MLtoC</abbrev>
<authorgroup>
<author><firstname>David</firstname> <surname>Tarditi</surname></author>
<author><firstname>Peter</firstname> <surname>Lee</surname></author>
<author><firstname>Anurag</firstname> <surname>Acharya</surname></author>
</authorgroup>
<title>No Assembly Required: Compiling Standard ML to C</title>
<bibliomisc>ACM Letters on Programming Languages and Systems</bibliomisc>
<pubdate>1992</pubdate>
<!--<volumenum>1</volumenum> <issuenum>2</issuenum>-->
<issuenum>1(2)</issuenum>
<pagenums>161-177</pagenums>
</biblioentry>

<biblioentry>
<abbrev>R5RS</abbrev>
<title>Revised<superscript>5</superscript> Report on the Algorithmic Language Scheme</title>
<authorgroup>
<!-- <author> should be <editor> -->
<author><firstname>Richard</firstname> <surname>Kelsey</surname></author>
<author><firstname>William</firstname> <surname>Clinger</surname></author>
<author><firstname>Jonathan</firstname> <surname>Rees (editors)</surname></author>
</authorgroup>
<pubdate>1998</pubdate>
</biblioentry>

<biblioentry>
<abbrev>RScheme</abbrev>
<authorgroup>
<author><firstname>Donovan</firstname> <surname>Kolbly</surname></author>
<author><firstname>Paul</firstname> <surname>Wilson</surname></author>
<author><surname>others</surname></author>
</authorgroup>
<bibliomisc><literal>http://www.rscheme.org/</literal></bibliomisc>
</biblioentry>

<biblioentry>
<abbrev>SGML</abbrev>
<authorgroup><corpauthor>International Standards Organization</corpauthor></authorgroup>
<title>SGML (Standard Generalized Markup Language) ISO 8879</title>
</biblioentry>

</bibliography>

</article>
