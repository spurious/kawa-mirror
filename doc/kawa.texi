\input texinfo.tex      @c -*-texinfo-*-
@c %**start of header
@setfilename kawa.info
@settitle Kawa, the Java-based Scheme system
@setchapternewpage off
@c version: %W% %G%
@c %**end of header

@include version.texi

@iftex
@finalout
@end iftex
@titlepage
@title Kawa, the Java-based Scheme system
@subtitle September, 1996
@sp 1
@author Per Bothner
@page
@end titlepage

@ifinfo
@format
START-INFO-DIR-ENTRY
* kawa: (kawa).         Kawa, the Java-based Scheme system
END-INFO-DIR-ENTRY
@end format

@node Top, Features, (dir), (dir)
@top
@unnumbered The Kawa Scheme system, by Per Bothner
@end ifinfo

Kawa is a Scheme environment, written in java,
and that compiles Scheme code into Java byte-codes.

This documents version @value{VERSION}, updated @value{UPDATED}.

@ifhtml
R. Alexander Milowski
<tt>&lt;<a href="mailto:alex@copsol.com">alex@copsol.com</a>&gt;</tt>
wrote the first Kawa releases.
<a href="http://www.cygnus.com/~bothner">Per Bothner</a>
<tt>&lt;<a href="mailto:bothner@cygnus.com">bothner@cygnus.com</a>&gt;</tt>
extensively re-wrote Kawa, and released version 0.3 and up.
@end ifhtml
@ifclear html
R. Alexander Milowski @w{<alex@@copsol.com>} wrote the first Kawa releases.
Per Bothner @w{<bothner@@cygnus.com>} extensively re-wrote Kawa,
and released version 0.3 and up.
@end ifclear

@ifhtml
<a href="http://www.cygnus.com/~bothner/kawa.html">This</a>
is my Kawa home-page.
<p>
<a href="http://www.copsol.com/kawa/index.html">
Copsol's Kawa home-page</a>
is not maintained by Cygnus and so may not be as current.
@end ifhtml
@ifclear html
My Kawa home page (which is currently just an on-line
version of this document) is
@url{http://www.cygnus.com/~bothner/kawa.html}.

Copsol's Kawa home-page (@url{http://www.copsol.com/kawa/index.html})
is not maintained by Cygnus and so may not be as current.
@end ifclear

The name Kawa may change in the future, to avoid confusion
with a proprietary product of the same name.

@ifhtml
The <a href="http://www.cs.indiana.edu/scheme-repository/home.html">
Scheme repository</a> has various useful information on Scheme,
including a pointer to an online copy of
<a href="http://www-swiss.ai.mit.edu/~jaffer/r4rs_toc.html">R4RS</a>.
@end ifhtml
@ifclear html
The Scheme repository
(@url{http://www.cs.indiana.edu/scheme-repository/home.html})
has various useful information on Scheme, including a pointer to
an online copy of R4RS
(@url{http://www-swiss.ai.mit.edu/~jaffer/r4rs_toc.html}).
@end ifclear

@menu
* Features::
* Getting Kawa::
* Installation::         Building and installing Kawa
* Running::              How to start up and run Kawa
* Restrictions::         Features of R4RS not implemented
* Extensions::
* Compiling::            Compiling Scheme code to byte-codes
* Primitive functions::  The Scheme-Java interface
* Reporting Bugs::
* License::              
@end menu

@node Features, Getting Kawa, Top, Top
@section Features

Kawa is a full Scheme implementation.  It implements almost
all of R4RS (for exceptions @pxref{Restrictions}), plus some extensions.
It provide @code{define-syntax} from the R4RS appendex,
and (from the draft R5RS) eval and multiple values.

It is completely written in Java.  Scheme functions and files
are automatically compiled into Java byte-codes, providing
reasonable speed.  (However, Kawa is not an optimizing compiler,
and does not perform major transformations on the code.)

Kawa provides the usual read-eval-print loop, as well as batch modes.

Kawa is written in an object-oriented style.

@node Getting Kawa, Installation, Features, Top
@section Getting Kawa

The current sources release is in
@ifhtml
<a href="ftp://ftp.cygnus.com/pub/bothner/kawa-1.0.tar.gz">here</a>.
@end ifhtml
@ifclear html
@url{ftp://ftp.cygnus.com/pub/bothner/kawa-1.0.tar.gz}.
@end ifclear

The pre-compiled @code{.class} files are in
@ifhtml
<a href="ftp://ftp.cygnus.com/pub/bothner/kawa-1.0-compiled.tar.gz">here</a>.
@end ifhtml
@ifclear html
@url{ftp://ftp.cygnus.com/pub/bothner/kawa-1.0-compiled.tar.gz}.
@end ifclear

A snapshot of the development tree is
@ifhtml
<a href="ftp://ftp.cygnus.com/pub/bothner/kawa-1.1alpha.tar.gz">here</a>.
@end ifhtml
@ifclear html
@url{ftp://ftp.cygnus.com/pub/bothner/kawa-1.1alpha.tar.gz}.
@end ifclear

@node Installation, Running, Getting Kawa, Top
@section Building and installing Kawa

Before installing Kawa, you must have Java working on your
system.

You can compile Kawa from the source distribution.
Alternatively, you can install the pre-compiled binary distribution.

@menu
* Running Java::                Getting and running Java
* Binary distribution::         Installing and using the binary distribution
* Source distribution::         Installing and using the source distribution
@end menu

@node Running Java, Binary distribution, Installation, Installation
@subsection Getting and running Java

You will need a working Java system.
The discussion below assumes you are using the Java Developer's Kit
(JDK) version 1.0.x from JavaSoft (Sun).
(@emph{Note:} Kawa is @emph{not} supported on JDK 1.1 beta3,
due to bugs in the latter!)
You can download free copies of
@ifhtml
<a href="http://java.sun.com:80/java.sun.com/products/JDK/1.0.2/index.html">
@end ifhtml
JDK 1.0.2
@ifhtml
</a>.
for Sparc/Solaris, x86/Solaris, MS-Windows 95/NT, and MacOS.
@end ifhtml
@ifclear html
for Sparc/Solaris, x86/Solaris, MS-Windows 95/NT, and MacOS
from @url{http://java.sun.com:80/java.sun.com/products/JDK/1.0.2/index.html}.
@end ifclear

The program 'java' is the Java interpreter.
The program 'javac' is the Java compiler,
and is needed if you want to compile the source release yourself.
Both programs must be in your @code{PATH}.

You also need to set @code{CLASSPATH} so it includes both the
current directory, and the standard Java library.
After you have installed Kawa, the @code{CLASSPATH} needs to
include wherever you installed Kawa.

If you have the JDK in directory @code{$JDK},
and you are using a Bourne-shell compatible shell
(/bin/sh, ksh, bash, or other) you can set both variables thus:
@example
PATH=$JDK/bin:$PATH
CLASSPATH=.:$JDK/lib/classes.zip
export PATH CLASSPATH
@end example

@node Binary distribution, Source distribution, Running Java, Installation
@subsection Installing and using the binary distribution

The binary release includes only the binary compiled @samp{.class}
versions of the same @samp{.java} source files in the source release.
It does not include any documentation, so you probably want the
source release in addition to the binary release.  The purpose
of the binary release is just to save you time and trouble of
compiling the sources.

The binary release comes as a gzip-compressed tar file named
@samp{kawa-@value{VERSION}-compiled.tar.gz}.

You need to decide where you want to put the Kawa @samp{.class} files.
Assuming it is @samp{/usr/local/java} (the default), you can do:
@example
gunzip -c <kawa-@value{VERSION}-compiled.tar.gz|(cd /usr/local/java; tar xf -)
@end example

Then, before you can actually run Kawa, you need to set @code{CLASSPATH}
so it includes the Kawa files.  For example:
@example
export CLASSPATH=.:/usr/local/java:$JDK/lib/classes.zip
@end example

Then to run Kawa do:
@example
java kawa.repl
@end example

@node Source distribution,  , Binary distribution, Installation
@subsection Installing and using the source distribution
The Kawa release normally comes as a gzip-compressed tar file named
@samp{kawa-@value{VERSION}.tar.gz}.

In your build directory do:
@example
tar xzf kawa-@value{VERSION}.tar.gz
cd kawa-@value{VERSION}
@end example

Then you must configure the sources.  This you can do
the same way you configure most other GNU software.  Normally
you can just run the configure script with no arguments:

@example
./configure
@end example

This will specify that a later @code{make install} will install the
compiled @samp{.class} files into @code{/usr/local/java}.  If you want them
to be installed someplace else, such as @code{$PREFIX/java}, then
specify that when you run configure:
@example
./configure -- prefix $PREFIX
@end example

Thus you need to compile all the .java source files.
Just run make:
@example
make
@end example

You can now test the system by running Kawa in place:
@example
java kawa.repl
@end example

or you can run the test suite:
@example
(cd testsuite;  make check)
@end example

or you can install the compiled files:
@example
make install
@end example

This will install your classes into @code{$PREFIX/java} (and its
sub-directories).  Here @code{$PREFIX} is the directory you specified
to configure with the @code{--prefix} option, or @code{/usr/local} if you
did not specify a @code{--prefix} option.

To use the installed files, you need to set @code{CLASSPATH} so
that @code{$PREFIX/java} is on the path:
@example
export CLASSPATH=.:$PREFIX/java:$JDK/lib/classes.zip
@end example

@node Running, Restrictions, Installation, Top
@section How to start up and run Kawa

To run Kawa, you must start a Java interpreter.
This depends on the Java interpreter.
For JavaSoft's JDK, you must have the Java interpreter
in your @code{PATH}.
You must also make sure that the @code{kawa.class} file,
the rest of the Kawa packages, and the standard Java
packages can be found by searching CLASSPATH.
@xref{Running Java}.

Then you do:
@example
java kawa.repl
@end example

If you running Kawa on a Unix-like system, you can
use the @code{kawa} shell script.  If you have installed
it in your @code{PATH} (i.e. @code{$PREFIX/bin} is in your @code{$PATH}),
just do:
@example
kawa
@end example

In either case, you will then get the @samp{kawa>} prompt, which means you are
in the Kawa read-eval-print-loop.  If you type a Scheme
expression, Kawa will evaluate it.  Kawa will then print the
result (if there is a non-"void" result).

To exit Kawa, type the end-of-file character (normally ctrl/D),
or call the @code{exit} procedure (with 0 or 1 integer arguments).

You can pass various flags to Kawa, for example:
@example
java kawa.repl -e '(display (+ 12 4))(newline)'
@end example
This causes Kawa to print @samp{16}, and then exit.

@table @samp
@item -c @var{expr}
Kawa evaluates @var{expr}, which contains one or more Scheme expressions.
@item -e @var{expr}
Same as @samp{-c @var{expr}}.
@item -f @var{filename}
Kawa reads and evaluates expressions from the file named by @var{filename}.
If @var{filename} is @samp{-}, standard input is read (with no prompting).
@item -s
@itemx --
The global variable @samp{command-line-arguments} is set to the remaining
arguments (if any), and an interactive read-eval-print loop is started.
@end table

If there are further command-line arguments after the options
have been processed, then the first remaining argument names a
file that is read and evaluated.  If there is no such argument,
then Kawa enters an interactive read-eval-print loop,
but only if none of the @samp{-c}, @samp{-e}, @samp{-f}, @samp{-s},
or @samp{--} options were specified.

@defvar command-line-arguments
The remaining arguments (following any switches processed by Kawa itself)
are assigned to the global variable @samp{command-line-arguments},
which is a vector of strings.
@end defvar

@node Restrictions, Extensions, Running, Top
@section Features of R4RS not implemented

The file Compliance.html specifies which functions and syntax
have been implemented so far.

The entire "numeric tower" is implemented.
However, some transcendental function only work on reals.
Integral function do not necessarily work on
inexact (floating-point) integers.
(The whole idea of "inexact integer" in R4RS seems rather pointless ...)

Also, call-with-current-continuation is only "upwards" (?).
I.e. once a continuation has been exited, it cannot be invoked.
These restricted continuations can be used to implement catch/throw
(such as the examples in R4RS), but not co-routines or backtracking.

Kawa does not do general tail-call elimination.  However, if the
compiler can prove that the procedure being called is the current
function, then the tail call will be replaced by a jump.
This means the procedure must be defined using a letrec, not a
define (because the compiler does not know if someone might
re-define a global definition), and there must be no assignments
(using @code{set!}) to the procedure binding.

The @code{define-syntax} primitive is provided, but has some bugs
making it not properly hygienic.  Neither @code{let-syntax}
nor @code{letrec-syntax} are implemented.

@node Extensions, Compiling, Restrictions, Top
@section Extensions

@subsection Multiple values

@defun values object ...
Delivers all of its arguments to its continuation.
@end defun

@defun call-with-values thunk receiver
Call its @var{thunk} argument with a continuation that,
when passed some values, calls the @var{receiver} procedure
with those values as arguments.
@end defun

@subsection Logical Number Operations

These functions operate on the 2's complement binary representation
of an exact integer.

@defun logand i ...
Returns the bit-wise logical "and" of the arguments.
If no argument is given, the result is -1.
@end defun

@defun logior i ...
Returns the bit-wise logical "(inclusive) or" of the arguments.
If no argument is given, the result is 0.
@end defun

@defun logxor i ...
Returns the bit-wise logical "exclusive or" of the arguments.
If no argument is given, the result is 0.
@end defun

@defun lognot i
Returns the bit-wise logical inverse of the argument.
@end defun

@defun logop op x y
Perfoam one of the 16 bitwise operations of @var{x} and @var{y},
depending on @var{op}.
@end defun

@defun bittest i j
Returns true if the arguments have any bits in common.
Same as @code{(not (zero? (logand @var{i} @var{j})))},
but is more efficient.
@end defun

@defun logbit? i pos
Returns @code{#t} iff @var{i} has a one in the bit numbered @var{pos}.
@end defun

@defun arithmetic-shift i j
Shifts @var{i} by @var{j}.
It is a "left" shift if @code{@var{j}>0}, and
a "right" shift if @code{@var{j}<0}.

The result is equal to @code{(floor (* @var{i} (expt 2 @var{j})))}.
@end defun

@defun ash i j
Alias for @code{arithmetic-shift}.
@end defun

@defun logcount i
Count the number of 1-bits in @var{i}, if it is non-negative.
If @var{i} is negative, count number of 0-bits.
@end defun

@defun integer-length i
Return number of bits needed to represent @var{i} if @var{i} is unsigned.
Regardless of the sign of @var{i}, return one less than the number of bits
needed for a field that can represent @var{i} as a two's complement integer.
@end defun

@defun bit-extract n start end
Return the integer formed from the (unsigned) bit-field
starting at @var{start} and ending just before @var{end}.
Same as @code{(arithmetic-shift (bitand n (bitnot (arithmetic-shift -1 end))) (- start))}.
@end defun

@subsection Ports

@defun call-with-input-string string proc
Create an input port that gets its data from @var{string},
call @var{proc} with that port as its one argument, and return
the result from the call of @var{proc}
@end defun

@defun call-with-output-string proc
Create an output port that writes its data to a @var{string},
and call @var{proc} with that port as its one argument.
Return a string consisting of the data written to the port.
@end defun

@subsection Eval and Environments

@defun eval expression [environment-specifier]
@code{eval} evaluates @var{expression} in the environment indicated
by @var{environment-specifier}.

The default for @var{environment-specifier} is the result
of @code{(interaction-environment)}.
@end defun

@defun null-environment
This procedure returns an environment that contains no variable bindings,
but contains (syntactic) bindings for all the syntactic keywords.

The effect of assigning to a variable in this environment (such
as @code{let}) is undefined.
@end defun

@defun scheme-report-environment version
The @var{version} must be an exact non-negative inetger corresponding to
a version of one of the Revised@var{version} Reports on Scheme.
The procedure returns an environment that contains exactly the set of
bindings specified in the corresponding report.

This implementation supports @var{version} that is 4 or 5.

The effect of assigning to a variable in this environment (such
as @code{car}) is undefined.
@end defun

@defun interaction-environment
This procedure return an environment that contains implementation-defined
bindings, as well as top-level user bindings.
@end defun

@subsection Quantities

As a super-class of numbers, Kawa also provides quantities.
A @dfn{quantity} is a product of a @dfn{unit} and a pure number.
The number part can be an arbitrary complex number.
The unit is a product of integer powers of base units,
such as meter or second.

Kawa quantities are a generalization of the quantities in DSSSL,
which only has length-derived quantities.

The precise syntax of quantity literals may change,
but some examples are @code{10pt} (10 points), @code{5s} (5 seconds),
and @code{4cm2} (4 square centimeters).

@defun quantity? object
True iff @var{object} is a quantity.  Note that all numbers are
quantities, but not the other way round.
@end defun

@defun quantity->number q
Returns the pure number part of the quantity @var{q}, relative to
primitive (base) units.
If @var{q} is a number, returns @var{q}.
If @var{q} is a unit, yields the magitude of @var{q} relative to base units.
@end defun

@defun quantity->unit q
Returns the unit of the quantity @var{q}.
If @var{q} is a number, returns the empty unit.
@end defun

@defun make-quantity x unit
Returns the product of @var{x} (a pure number) and @var{unit}.
You can specify a string instead of @var{unit}, such as @code{"cm"}
or @code{"s"} (seconds).
@end defun

@subsection Threads

There is a very preliminary interface to create parallel threads.
The interface is similar to the standard @code{delay}/@code{force},
where a thread is basically the same as a promise, except that
evaluation may be in parallel.

So far, little or no effort has been made into makeing Kawa
thread-safe.  There are no per-thread bindings, and
the current input and output parts are global.
That need to change.

@defmac future expression
Creates a new thread that evaluates @var{expression}.
@end defmac

@defun force thread
The standard @code{force} function has generalized to also work
on thraeds.  If waits for the threads @var{expression} to finish
executing, and return the result.
@end defun

@defun sleep time
Suspends the current thread for the specified time.
The @var{time} can be either a pure number (in secords),
or a quantity whose unit is a time unit (such as @code{10s}).
@end defun

@subsection Miscellaneous

@defun exit [code]
Exits the Kawa interpreter, and ends the Java session.
The integer value @var{code} is returned to the operating
system.  If @var{code} is not specified, zero is returned,
indicating normal (non-error) termination.
@end defun

@defmac when condition form...
If @var{condition} is true, evaluate each @var{form} in order,
returning the value of the last one.
@end defmac

@defmac unless condition form...
If @var{condition} is false, evaluate each @var{form} in order,
returning the value of the last one.
@end defmac

@defun vector-append @var{arg}...
Creates a new vector, containing the elements from all the @var{arg}s
appended together.   Each @var{arg} may be a vector or a list.
@end defun

@node Compiling, Primitive functions, Extensions, Top
@section Compiling Scheme code to byte-codes

All Scheme functions and source files are invisibly compiled
into internal Java byte-codes.
A traditional evaluator is only used for top-level directly entered
expressions @emph{outside} a lambda.  (It would have been simpler
to also byte-compile top-level expressions by surrounding them
by a dummy lambda.  However, this would create a new Class object
in the Java VM for every top-level expression.  This is undesirable
unless you have a VM that can garbage collect Class objects.
Sun's VM currently does not, but that is planned for JDK 1.1.)

To save speed when loading large Scheme source files, you probably
want to pre-compile them and save them on your local disk.
There are two ways to do this.

You can compile a Scheme source file to a single archive file.
You do this using the @code{compile-file} function.
The result is a single file that you can move around and @code{load}
just like the @code{.scm} source file.  You just specify the name
of the archive file to the @code{load} procedure.
Currently, the archive is a "zip" archive and has extension ".zip";
a future release will probably use "Java Archive" (jar) files,
once support from that has been released from JavaSoft.
The advantage of compiling to an archive is that it is simple
and transparent.  A disadvantage is that it causes the
Java "verifier" to be run when functions are loaded from it,
which takes a little extra time.

Alternatively, you can compile a Scheme source file to a
collection of @samp{.class} files using the stand-alone
@samp{kawac} application.
You then use the standard Java class loading mechanism to load the code.
The Java "verifier" does not need to get run, which makes
loading a little faster.
The compiled class files do have to be installed be installed somewhere
in the @code{CLASSPATH}.

@menu
* Archive compilation::         Compiling Scheme to an archive file
* Files compilation::           Compiling Scheme to a set of .class files
@end menu

@node Archive compilation, Files compilation, Compiling, Compiling
@subsection Compiling Scheme to an archive file

To byte-compile a file @samp{foo.scm} do:
@example
(compile-file "foo.scm" "foo")
@end example

This will create @samp{foo.zip}, which contains byte-compiled "j-code"
that implements @samp{foo.scm}.

You can later do:
@example
(load "foo")
@end example

This will load @samp{foo.zip}, which should have the same effect as
loading @samp{foo.scm}, except you will get the byte-compiled versions.

@node Files compilation,  , Archive compilation, Compiling
@subsection Compiling Scheme to a set of .class files

The @samp{kawac} application will compile a @samp{.scm} source file into one or
more @samp{.class} files.

You run it as follows:
@example
java kawac @var{infile} [-d @var{outdirectory}] [@var{prefix} [@var{topname}]]
@end example

Here:
@table @var
@item infile
The Scheme source file we want to compile.
@item @samp{-d} outdirectory
The directory under which the resulting @samp{.class} files will be.
The default is the current directory.
@item prefix
A string to prepend to the generated class names.
The default is the empty string.
@item topname
The name of the "top" class - i.e. the one that contains the code
for the top-level expressions and definitions.
The default is generated from the @var{infile} and @var{prefix}.
@end table

When you actually want to load the classes, the @var{outdirectory}
must be in your @samp{CLASSPATH}.
You can use the standard @code{load} function to load the code,
by specifying the top-level class, either as a file name
(relative to @var{outdirectory}) or a class name.
E.g. if you did:
@example
java kawac foosrc.scm -d /usr/local/java my.lib. foo     
@end example
you can use either:
@example
(load "my.lib.foo")
@end example
or:
@example
(load "my/lib/foo.class")
@end example

@node Primitive functions, Reporting Bugs, Compiling, Top
@section The Scheme-Java interface

@subsection Scheme types in Java

All Scheme values are implemented by sub-classes of @samp{java.lang.Object}.

Scheme symbols are implemented by @code{kawa.lang.Symbol}.
Use the @samp{make} static method to create a new (interned) symbol.
(It is likely that Scheme Symbols will be represented by java.lang.String
values after JDK 1.1 is released.)

Scheme integers are implemented by @code{kawa.math.IntNum}.
Use the make static function to create a new IntNum from an int or a long.
Use the intValue or longValue methods to get the int or long value of
an IntNum.  There is partial support for bignums.

A Scheme "flonum" is implemented by @code{kawa.math.DFloNum}.

A Scheme pair is implemented by @code{kawa.lang.Pair}.

A Scheme vector is implemented by @code{kawa.lang.Vector}.

Scheme characters are implemented using @code{kawa.lang.Char}.

Scheme strings are @emph{currently} implemented using
@code{java.lang.StringBuffer}.  This will probably be
changed to use a new sub-class of @code{kawa.lang.Sequence}.

Scheme procedures are all sub-classes of @code{kawa.lang.Procedure}.
Normally each function (lambda expression) in the source code is
compiled to a separate sub-class of @samp{Procedure}.
The "action" of a @samp{Procedure} is invoked by using one of
the @samp{apply*} methods:  @samp{apply0}, @samp{apply1},
@samp{apply2}, @samp{apply3}, @samp{apply4}, or @samp{applyN}.
Various sub-class of @samp{Procedure} provide defaults
for the various @samp{apply*} methods.  For example,
a @samp{Procedure2} is used by 2-argument procedures.
The @samp{Procedure2} class provides implementations of all
the @samp{apply*} methods @emph{except} @samp{apply2},
which must be provided by any class that extends @code{Procedure2}.

@subsection Loading a ModuleBody

The "top" class created by @code{kawac} (@pxref{Files compilation})
extends the @code{ModuleBody} class.  It is actually fairly
easy to write a @code{ModuleBody} by hand in Java, and you can
then use the Scheme @code{load} procedure to cause arbitrary
actions.  Here is an example.
@emph{(Note that the details are subject to change!)}

@example
package MyDev;
import kawa.lang.*;
class MyDevFunc extends Procedure2
@{
  public Object apply2 (Object arg1, Object arg2)
  @{
    ... stuff to control my device ...;
  @}
@}

public class MyDevice extends ModuleBody
@{
  public Object run (Environment env)
    throws WrongArguments, WrongType, GenericError, UnboundSymbol
  @{
    ... initialize my device here ...;

    // Declare (handle-my-device x y) to call MyDevFunc.apply2 (x, y):
    env.define ("handle-my-device", new MyDevFunc ());

    // Return the void value (i.e. no value).
    return Interpreter.voidObject;
  @}
@}
@end example

If this text is in the file @code{MyDev/MyDevice.java}, and you compile
it with @code{javac}, you will get @code{MyDev/MyDevice.class}
and @code{MyDev/MyDevFunc.class}.  Assuming the current directory
is in your @code{CLASSPATH}, you can now do the following in Kawa:
@example
(load "MyDev/MyDevice.class")
@end example
or:
@example
(load "MyDev.MyDevice")
@end example

This will cause the actions in @code{MyDevice.run} to be executed.
The current environment is passed in as the parameter @code{env}.
One of those actions is to define the procedure @code{handle-my-device}.

@subsection Evaluating Scheme expressions from Java

The following methods are recommended if you need to evaluate a
Scheme expression from a Java method.
Some details (such as the @samp{throws} lists) may changes,
someting will continue to be supported. 

@deftypefn {Static method} Object Scheme.eval (InPort @var{port}, Environment @var{env})
Read expressions from @var{port}, and evaluate them in the
@var{env} environment, until end-of-file is reached.
Return the value of the last expression,
or @code{Interpreter.voidObject} if there is no expression.
@end deftypefn

@deftypefn {Static method} Object Scheme.eval (String @var{string}, Environment @var{env})
Read expressions from @var{string}, and evaluate them in the
@var{env} environment, until the end of the string is reached.
Return the value of the last expression,
or @code{Interpreter.voidObject} if there is no expression.
@end deftypefn

@deftypefn {Static method} Object Scheme.eval (Object @var{sexpr}, Environment @var{env})
The @var{sexpr} is an S-expression (as may be returned by @code{read}).
Evaluate it in the @var{env} environment, and return the result.
@end deftypefn

For the @code{Environment} in most cases you could use
@samp{Environment.current()}.

@node Reporting Bugs, License, Primitive functions, Top
@section Reporting Bugs

If you have a problem installing or using Kawa,
send mail to @code{kawa@@cygnus.com}

This mailing list is used for reporting bugs, patches, discussing
changes to Kawa, and announcing snapshots.  If you wish to subscribe
(or later unsubscribe), send a request to @code{kawa-request@@cygnus.com}.

@node License,  , Reporting Bugs, Top
@section License

@include license.terms

@bye
