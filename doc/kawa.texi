\input texinfo.tex      @c -*-texinfo-*-
@c %**start of header
@setfilename kawa.info
@settitle Kawa, the Java-based Scheme system
@setchapternewpage off
@c version: %W% %G%
@c %**end of header

@include version.texi

@iftex
@finalout
@end iftex
@titlepage
@title Kawa, the Java-based Scheme system
@subtitle @value{UPDATED}
@sp 1
@author Per Bothner
@page
@end titlepage

@ifinfo
@format
START-INFO-DIR-ENTRY
* kawa: (kawa).         Kawa, the Java-based Scheme system
END-INFO-DIR-ENTRY
@end format

@node Top, Features, (dir), (dir)
@top
@unnumbered The Kawa Scheme system, by Per Bothner
@end ifinfo

Kawa is a Scheme environment, written in Java,
and that compiles Scheme code into Java byte-codes.

This documents version @value{VERSION}, updated @value{UPDATED}.

The author of Kawa is
@ifhtml
<a href="http://www.cygnus.com/~bothner">Per Bothner</a>
<tt>&lt;<a href="mailto:bothner@cygnus.com">bothner@cygnus.com</a>&gt;</tt>.
It is a re-write of Kawa 0.2, which was written by R. Alexander Milowski
<tt>&lt;<a href="mailto:alex@copsol.com">alex@copsol.com</a>&gt;</tt>.
@end ifhtml
@ifclear html
Per Bothner @w{<bothner@@cygnus.com>}.
It is a re-write of Kawa 0.2, which was written by
R. Alexander Milowski @w{<alex@@copsol.com>}.
@end ifclear

@ifhtml
<a href="http://www.cygnus.com/~bothner/kawa.html">This</a>
is the Kawa home-page.
<a href="http://www.copsol.com/kawa/index.html">
Copsol's Kawa home-page</a>
is not maintained by Cygnus and so may not be as current.
@end ifhtml
@ifclear html
The Kawa home page (which is currently just an on-line
version of this document) is
@url{http://www.cygnus.com/~bothner/kawa.html}.
Copsol's Kawa home-page (@url{http://www.copsol.com/kawa/index.html})
is not maintained by Cygnus and so may not be as current.
@end ifclear

The name Kawa may change in the future, to avoid confusion
with a proprietary product of the same name.

@ifhtml
The <a href="http://www.cs.indiana.edu/scheme-repository/home.html">
Scheme repository</a> has various useful information on Scheme,
including a pointer to an online copy of
<a href="http://www-swiss.ai.mit.edu/~jaffer/r4rs_toc.html">R4RS</a>.
@end ifhtml
@ifclear html
The Scheme repository
(@url{http://www.cs.indiana.edu/scheme-repository/home.html})
has various useful information on Scheme, including a pointer to
an online copy of R4RS
(@url{http://www-swiss.ai.mit.edu/~jaffer/r4rs_toc.html}).
@end ifclear

For copyright information on the software and documentation,
see @ref{License}.

@menu
* Features::
* Getting Kawa::
* Installation::         Building and installing Kawa
* Running::              How to start up and run Kawa
* Restrictions::         Features of R4RS not implemented
* Extensions::           Kawa features not in standard Scheme
* Compiling::            Compiling Scheme code to byte-codes
* Low-level functions::  The Scheme-Java interface
* Reporting Bugs::
* License::              
@end menu

@node Features, Getting Kawa, Top, Top
@chapter Features

Kawa is a full Scheme implementation.  It implements almost
all of R4RS (for exceptions @pxref{Restrictions}), plus some extensions.
It provides @code{define-syntax} from the R4RS appendix,
and (from the draft R5RS) eval and multiple values.
By default, symbols are case sensitive.

It is completely written in Java.  Scheme functions and files
are automatically compiled into Java byte-codes, providing
reasonable speed.  (However, Kawa is not an optimizing compiler,
and does not perform major transformations on the code.)

Kawa provides the usual read-eval-print loop, as well as batch modes.

Kawa is written in an object-oriented style.

Kawa implements most of the features of the expression language of DSSSL,
the Scheme-derived ISO-standard Document Style Semantics and Specification
Language for SGML.  Of the core expression language, the only features
missing are character properties, @code{external-procedure},
the time-relationed procedures, and character name escapes in
string literals.  Also, Kawa is not generally tail-recursive.
From the full expression language, Kawa additionally is missing
@code{format-number}, @code{format-number-list}, and language objects.
Quantities, keyword values, and the expanded @code{lambda} form
(with optional and keyword parameters) are supported.

@node Getting Kawa, Installation, Features, Top
@chapter Getting Kawa

The current sources release is in
@ifhtml
<a href="ftp://ftp.cygnus.com/pub/bothner/kawa-current.tar.gz">here</a>.
@end ifhtml
@ifclear html
@url{ftp://ftp.cygnus.com/pub/bothner/kawa-current.tar.gz}.
@end ifclear

A ready-to-run @code{.zip} archive of the pre-compiled classes is in
@ifhtml
<a href="ftp://ftp.cygnus.com/pub/bothner/kawa-current-compiled.zip">here</a>.
@end ifhtml
@ifclear html
@url{ftp://ftp.cygnus.com/pub/bothner/kawa-current-compiled.zip}.
@end ifclear

A snapshot of the development tree is in
@ifhtml
<a href="ftp://ftp.cygnus.com/pub/bothner/kawa-newest.tar.gz">here</a>.
@end ifhtml
@ifclear html
@url{ftp://ftp.cygnus.com/pub/bothner/kawa-newest.tar.gz}.
@end ifclear

@node Installation, Running, Getting Kawa, Top
@chapter Building and installing Kawa

Before installing Kawa, you must have Java working on your
system.

You can compile Kawa from the source distribution.
Alternatively, you can install the pre-compiled binary distribution.

@menu
* Running Java::                Getting and running Java
* Binary distribution::         Installing and using the binary distribution
* Source distribution::         Installing and using the source distribution
@end menu

@node Running Java, Binary distribution, Installation, Installation
@section Getting and running Java

You will need a working Java system.
The discussion below assumes you are using the Java Developer's Kit
(JDK) version 1.1.x from JavaSoft (Sun).
(Kawa has also been reported to work with Kaffe, Symantec Cafe, J++,
and JDK 1.2beta.)
You can download free copies of
@ifhtml
<a href="http://java.sun.com/products/jdk/1.1/index.html">
@end ifhtml
JDK 1.1.x
@ifhtml
</a>
for various platforms.
@end ifhtml
@ifclear html
for various platforms
from @url{http://java.sun.com/products/jdk/1.1/index.html/index.html}.
@end ifclear

The program @code{java} is the Java interpreter.
The program @code{javac} is the Java compiler,
and is needed if you want to compile the source release yourself.
Both programs must be in your @code{PATH}.

You also need to set @code{CLASSPATH} so it includes both the
current directory, and the standard Java library.
After you have installed Kawa, the @code{CLASSPATH} needs to
include wherever you installed Kawa.

If you have the JDK in directory @code{$JDK},
and you are using a Bourne-shell compatible shell
(/bin/sh, ksh, bash, and some others) you can set both variables thus:
@example
PATH=$JDK/bin:$PATH
CLASSPATH=.:$JDK/lib/classes.zip
export PATH CLASSPATH
@end example

@node Binary distribution, Source distribution, Running Java, Installation
@section Installing and using the binary distribution

The binary release includes only the binary compiled @samp{.class}
versions of the same @samp{.java} source files in the source release.
It does not include any documentation, so you probably want the
source release in addition to the binary release.  The purpose
of the binary release is just to save you time and trouble of
compiling the sources.

The binary release comes as a @code{.zip} archive
@samp{kawa-@value{VERSION}-compiled.zip}.

You can unzip the archive, or you can use it as is.
Assuming the latter, copy the archive to some suitable location,
such as @code{/usr/local/lib/kawa-compiled.zip}.

Then, before you can actually run Kawa, you need to set @code{CLASSPATH}
so it includes the Kawa archive.  On Unix, using a Bourne-style shell:
@example
CLASSPATH=/usr/local/lib/kawa-compiled.zip
export CLASSPATH
@end example

On Windows95/WindowsNT, you need to set @code{classpath} in a DOS console.
For example:
@example
set classpath=\kawa\kawa-compiled.zip
@end example

Then to run Kawa do:
@example
java kawa.repl
@end example

@node Source distribution,  , Binary distribution, Installation
@section Installing and using the source distribution
The Kawa release normally comes as a gzip-compressed tar file named
@samp{kawa-@value{VERSION}.tar.gz}.

In your build directory do:
@example
tar xzf kawa-@value{VERSION}.tar.gz
cd kawa-@value{VERSION}
@end example

Then you must configure the sources.  This you can do
the same way you configure most other GNU software.  Normally
you can just run the configure script with no arguments:

@example
./configure
@end example

This will specify that a later @code{make install} will install the
compiled @samp{.class} files into @code{/usr/local/share/java}.
If you want them
to be installed someplace else, such as @code{$PREFIX/share/java}, then
specify that when you run configure:
@example
./configure --prefix $PREFIX
@end example

Thus you need to compile all the .java source files.
Just run make:
@example
make
@end example
This assume that @samp{java} and @samp{javac} are the java interpreter
and compiler, respectively.
If you are using the Kaffe free Java interpreter,
you need to instead say:
@example
make JAVA=kaffe
@end example

You can now test the system by running Kawa in place:
@example
java kawa.repl
@end example

or you can run the test suite:
@example
(cd testsuite;  make check)
@end example

or you can install the compiled files:
@example
make install
@end example

This will install your classes into @code{$PREFIX/share/java} (and its
sub-directories).  Here @code{$PREFIX} is the directory you specified
to configure with the @code{--prefix} option, or @code{/usr/local} if you
did not specify a @code{--prefix} option.

To use the installed files, you need to set @code{CLASSPATH} so
that @code{$PREFIX/share/java} is on the path:
@example
CLASSPATH=$PREFIX/share/java
export CLASSPATH
@end example
This is done automatically if you use the @samp{kawa} script.

I have not yet tried to build Kawa from source on Windows95, though I
understand others have done so.  (If you know how, let me know!)

@node Running, Restrictions, Installation, Top
@chapter How to start up and run Kawa

The easiest way to start up Kawa is to run the @samp{kawa}
script.  This finds your java interpreter, and sets up @samp{CLASSPATH}
correctly.
If you have installed Kawa such @code{$PREFIX/bin} is in your @code{$PATH},
just do:
@example
kawa
@end example
However, @samp{kawa} only works if you have a Unix-like environment.

To run Kawa manually, you must start a Java interpreter.
How you do this depends on the Java interpreter.
For JavaSoft's JDK, you must have the Java interpreter
in your @code{PATH}.
You must also make sure that the @code{kawa/repl.class} file,
the rest of the Kawa packages, and the standard Java
packages can be found by searching CLASSPATH.
@xref{Running Java}.

Then you do:
@example
java kawa.repl
@end example

In either case, you will then get the @samp{#|kawa:1|#} prompt,
which means you are
in the Kawa read-eval-print-loop.  If you type a Scheme
expression, Kawa will evaluate it.  Kawa will then print the
result (if there is a non-"void" result).

@menu
* Options::      Command-line arguments
* New-Window::   Running a Command Interpreter in a new Window
* Exiting::      Exiting Kawa
@end menu

@node Options, New-Window, , Running
@section Command-line arguments

You can pass various flags to Kawa, for example:
@example
kawa -e '(display (+ 12 4))(newline)'
@end example
or:
@example
java kawa.repl -e '(display (+ 12 4))(newline)'
@end example
Either causes Kawa to print @samp{16}, and then exit.

At startup, Kawa executes an init file from the user's home
directory.
The init file is named @code{.kawarc.scm} on Unix-like systems
(those for which the file separator is @code{'/'}),
and @code{kawarc.scm} on other systems.
This is done before the read-eval-print loop
or before the first @code{-f} or @code{-c} argument.  (It is not run
for a @code{-e} command, to allow you to set options to override
the defaults.)

@table @samp
@item -e @var{expr}
Kawa evaluates @var{expr}, which contains one or more Scheme expressions.
Does not cause the @code{~/.kawarc.scm} init file to be run.
@item -c @var{expr}
Same as @samp{-e @var{expr}}, except that it
does cause the @code{~/.kawarc.scm} init file to be run.
@item -f @var{filename}
Kawa reads and evaluates expressions from the file named by @var{filename}.
If @var{filename} is @samp{-}, standard input is read (with no prompting).
@item -s
@itemx --
The global variable @samp{command-line-arguments} is set to the remaining
arguments (if any), and an interactive read-eval-print loop is started.
This uses the same "console" as where you started up Kawa;
use @samp{-w} to get a new window.
@item -w
Creates a new top-level window, and runs an interactive read-eval-print
in the new window.  See @ref{New-Window}.
Same as @code{-e (scheme-window #t)}.
You can specify multiple @samp{-w} options, but if you mix @samp{-w}
with @samp{s}, the new windows will not repaint until
the read-eval-print-loop in the original "console" is done.
@item --version
Prints out the Kawa version number, and then exits.
@end table

The options @samp{-C}, @samp{-d}, @samp{-T} and @samp{-P}
are used to compile a Scheme file; see @ref{Files compilation}.

If there are further command-line arguments after the options
have been processed, then the first remaining argument names a
file that is read and evaluated.  If there is no such argument,
then Kawa enters an interactive read-eval-print loop,
but only if none of the @samp{-c}, @samp{-e}, @samp{-f}, @samp{-s},
@samp{-C}, or @samp{--} options were specified.

@node New-Window, Exiting, Options,Running
@section Running a Command Interpreter in a new Window

An alternative interface runs the Java read-eval-print-loop
inside a new window. This is in some ways nicer.  One reason
is that it provides better editing.  You can also create
new windows.  They can either have different top-level
environments or they can share environments.  To try it, do:
@example
java kawa.repl -w
@end example

@node Exiting, , New-Window, Running
@section Exiting Kawa
Kawa normally keeps running as long as there is an active
read-eval-print loop still awaiting input or there is an unfinished
other computation (such as requested by a @samp{-e} of @samp{-f} option).

To close a read-eval-print-loop, you type an end-of-file character
(normally ctrl/D until Unix).  (If the read-eval-print-loop
is in a new window, you can select @samp{Close} from the @samp{File} menu.)

To exit the entire Kawa session, call the
@code{exit} procedure (with 0 or 1 integer arguments).

@node Restrictions, Extensions, Running, Top
@chapter Features of R4RS not implemented

Kawa implements all the required and optional features of R4RS,
with the following exceptions.

The entire "numeric tower" is implemented.
However, some transcendental function only work on reals.
Integral function do not necessarily work on
inexact (floating-point) integers.
(The whole idea of "inexact integer" in R4RS seems rather pointless ...)

Also, call-with-current-continuation is only "upwards" (?).
I.e. once a continuation has been exited, it cannot be invoked.
These restricted continuations can be used to implement catch/throw
(such as the examples in R4RS), but not co-routines or backtracking.

Kawa does not do general tail-call elimination.  However, if the
compiler can prove that the procedure being called is the current
function, then the tail call will be replaced by a jump.
This means the procedure must be defined using a letrec, not a
define (because the compiler does not know if someone might
re-define a global definition), and there must be no assignments
(using @code{set!}) to the procedure binding.

The @code{define-syntax} primitive is provided, but has some bugs
making it not properly hygienic.  Neither @code{let-syntax}
nor @code{letrec-syntax} are implemented.

@node Extensions, Compiling, Restrictions, Top
@chapter Extensions

@menu
* Multiple values::
* Keywords::
* Special named constants::
* Optional and keyword lambda parameters::
* Logical Number Operations::
* Records::
* Files:: File System Interface
* Ports::
* Exceptions:: Signalling and recovering from exceptions
* Eval and Environments::
* Quantities::
* Threads::
* Standard Types::
* Miscellaneous::
@end menu

@node Multiple values, Special named constants, Extensions, Extensions
@section Multiple values

The multiple-value feature will be in R5RS.

@defun values object ...
Delivers all of its arguments to its continuation.
@end defun

@defun call-with-values thunk receiver
Call its @var{thunk} argument with a continuation that,
when passed some values, calls the @var{receiver} procedure
with those values as arguments.
@end defun

@node Special named constants, Keywords, Multiple values, Extensions
@section Special named constants

@defvr Constant #!optional
Special self-evaluating literal used in lambda parameter lists
before optional parameters.
@end defvr

@defvr Constant #!rest
Special self-evaluating literal used in lambda parameter lists
before the rest parameter.
@end defvr

@defvr Constant #!key
Special self-evaluating literal used in lambda parameter lists
before keyword parameters.
@end defvr

@defvr Constant #!eof
The end-of-file object.
@end defvr

@defvr Constant #!void
The void value.  Same as @code{(values)}.
If this is the value of an expression in a read-eval-print loop,
nothing is printed.
@end defvr

@defvr Constant #!null
The Java @code{null} value.  This is not really a Scheme value,
but is useful when interfacing to low-level Java code.
@end defvr

@node Keywords, Optional and keyword lambda parameters, Special named constants, Extensions
@section Keywords

Keywords are similar to symbols.  The main difference is that keywords are
self-evaluating and therefore do not need to be quoted in expressions.
They are used mainly for specifying keyword arguments.

@display
@var{keyword} = @var{identifier}:
@end display

A keyword is a single token; therefore no whitespace is allowed between
the @var{identifier} and the colon (which is not considered part
of the name of the keyword).

@defun keyword? obj
Return @code{#t} if @var{obj} is a keyword, and otherwise returns @code{#f}.
@end defun

@defun keyword->string keyword
Returns the name of @var{keyword} as a string.
The name does not include the final @code{#\:}.
@end defun

@defun string->keyword string
Returns the keyword whose name is @var{string}.
(The @var{string} does not include a final @code{#\:}.)
@end defun

@node Optional and keyword lambda parameters, Logical Number Operations, Keywords, Extensions
@section Optional and keyword lambda parameters

Kawa borrows the extended formal argument list of DSSSL:

@display
@var{lambda-expression} = (lambda (@var{formal-arguments}) @var{body})
@end display
You can of course also use the extended format in a @code{define}:
@display
(define (@var{name} @var{formal-arguments}) @var{body})
@end display

@display
@var{formal-arguments} =
@var{req-opt-args} . @var{rest-arg} @var{or:}
@var{req-opt-args} @var{rest-key-args}
@end display
@display
@var{req-opt-args} = @var{req-arg}* (#!optional @var{opt-arg}*)?
@var{rest-key-args} = (#!rest @var{rest-arg})? (#!key @var{key-arg}*)?
@var{opt-arg} = @var{variable} | (@var{variable} @var{initializer})
@var{req-arg} = @var{variable}
@var{key-arg} = @var{variable} | (@var{variable} @var{initializer})
@var{rest-arg} = @var{variable}
@end display

When the procedure is applied to a list of actual arguments, the formal and
actual arguments are processed from left to right as follows:

@itemize @bullet
@item
The @var{req-arg}s are bound to actual arguments starting with the
first actual argument.  It shall be an error if there are fewer actual
arguments then there are @var{req-arg}s.
@item
Next the @var{opt-arg}s are bound to remaining actual arguemnts.
If there are fewer remaining actual arguments than there are
@var{opt-arg}s, then the remaining @var{variable}s are bound
to the corresponding @var{initializer}, if one was specified, and
otherwise to @code{#f}.  The @var{initializer} is evaluated in an
environment in which all the previous formal parameters have been bound.
@item
If there is a @var{rest-arg}, it is bound to a list of all the
remaining actual arguments.  These remaining actual arguments are also
eligible to be bound to keyword arguments.   If there is no
@var{rest-arg} and there are no @var{key-arg}s, then it shall
be an error if there are any remaining actual arguments.
@item
If @code{#!key} was specified, then there shall be an even number of
remaining actual arguments.  These are interpreted as a series of pairs,
where the first member of each pair is a keyword specifying the argument name,
and the second is the corresponding value.  It shall be an error if the first
member of a pair is not a keyword.  It shall be an error if the argument name
is not the same as a variable in a @var{key-arg}s, unless there
is a @var{rest-arg}.  If the same argument name occurs more than once
in the list of actual arguments, then the first value is used.
If there is no actual argument for a particular @var{key-arg},
then the variable is bound
to the corresponding @var{initializer}, if one was specified, and
otherwise to @code{#f}.  The @var{initializer} is evaluated in an
environment in which all the previous formal parameters have been bound.
@end itemize

@node Logical Number Operations, Records, Optional and keyword lambda parameters, Extensions
@section Logical Number Operations

These functions operate on the 2's complement binary representation
of an exact integer.

@defun logand i ...
Returns the bit-wise logical "and" of the arguments.
If no argument is given, the result is -1.
@end defun

@defun logior i ...
Returns the bit-wise logical "(inclusive) or" of the arguments.
If no argument is given, the result is 0.
@end defun

@defun logxor i ...
Returns the bit-wise logical "exclusive or" of the arguments.
If no argument is given, the result is 0.
@end defun

@defun lognot i
Returns the bit-wise logical inverse of the argument.
@end defun

@defun logop op x y
Perform one of the 16 bitwise operations of @var{x} and @var{y},
depending on @var{op}.
@end defun

@defun bittest i j
Returns true if the arguments have any bits in common.
Same as @code{(not (zero? (logand @var{i} @var{j})))},
but is more efficient.
@end defun

@defun logbit? i pos
Returns @code{#t} iff the bit numbered @var{pos} in @var{i} is one.
@end defun

@defun arithmetic-shift i j
Shifts @var{i} by @var{j}.
It is a "left" shift if @code{@var{j}>0}, and
a "right" shift if @code{@var{j}<0}.

The result is equal to @code{(floor (* @var{i} (expt 2 @var{j})))}.
@end defun

@defun ash i j
Alias for @code{arithmetic-shift}.
@end defun

@defun logcount i
Count the number of 1-bits in @var{i}, if it is non-negative.
If @var{i} is negative, count number of 0-bits.
@end defun

@defun integer-length i
Return number of bits needed to represent @var{i} in an unsigned field.
Regardless of the sign of @var{i}, return one less than the number of bits
needed for a field that can represent @var{i} as a two's complement integer.
@end defun

@defun bit-extract n start end
Return the integer formed from the (unsigned) bit-field
starting at @var{start} and ending just before @var{end}.
Same as @code{(arithmetic-shift (bitand n (bitnot (arithmetic-shift -1 end))) (- start))}.
@end defun

@node Records, Files, Logical Number Operations, Extensions
@section Records

The Record package provides a facility for user to define their own
record data types.  A record type is implemented as Java Class
object, and records are extensions of the class @code{Record}.
These procedures use the Java 1.1 reflection facility.

@defun make-record-type type-name field-names
Returns a @dfn{record-type descriptor}, a value representing a new data
type disjoint from all others.  The @var{type-name} argument must be a
string, but is only used for debugging purposes (such as the printed
representation of a record of the new type).  The @var{field-names}
argument is a list of symbols naming the @dfn{fields} of a record of the
new type.  It is an error if the list contains any duplicates.

In Kawa, returns a newly-created @code{Class} object that extends
the @code{Record} class.  Each record field is implemented as
a public Java instance field.
@end defun

@c @defun make-record-sub-type type-name field-names rtd
@c Returns a @dfn{record-type descriptor}, a value representing a new data
@c type, disjoint from all others.  The @var{type-name} argument must be a
@c string.  The @var{field-names} argument is a list of symbols naming the
@c additional @dfn{fields} to be appended to @var{field-names} of
@c @var{rtd}.  It is an error if the combinded list contains any
@c duplicates.@refill
@c
@c Record-modifiers and record-accessors for @var{rtd} work for the new
@c record-sub-type as well.  But record-modifiers and record-accessors for
@c the new record-sub-type will not neccessarily work for @var{rtd}.@refill
@c @end defun

@defun record-constructor rtd [field-names]
Returns a procedure for constructing new members of the type represented
by @var{rtd}.  The returned procedure accepts exactly as many arguments
as there are symbols in the given list, @var{field-names}; these are
used, in order, as the initial values of those fields in a new record,
which is returned by the constructor procedure.  The values of any
fields not named in that list are unspecified.  The @var{field-names}
argument defaults to the list of field names in the call to
@code{make-record-type} that created the type represented by @var{rtd};
if the @var{field-names} argument is provided, it is an error if it
contains any duplicates or any symbols not in the default list.

In Kawa, @var{rtd} may be any @code{Class} that has a public default
constructor, as long as the @var{field-names} are public instance
fields.  (The fields should have type @code{Object} -- unless you
know what you are doing!)
@end defun

@defun record-predicate rtd
Returns a procedure for testing membership in the type represented by
@var{rtd}.  The returned procedure accepts exactly one argument and
returns a true value if the argument is a member of the indicated record
type; it returns a false value otherwise.

In Kawa, the returned procedure checks if the argument is an instance
of @var{rtd} or one of its sub-classes.
@end defun

@c @defun record-sub-predicate rtd
@c Returns a procedure for testing membership in the type represented by
@c @var{rtd} or its parents.  The returned procedure accepts exactly one
@c argument and returns a true value if the argument is a member of the
@c indicated record type or its parents; it returns a false value
@c otherwise.@refill
@c @end defun

@defun record-accessor rtd field-name
Returns a procedure for reading the value of a particular field of a
member of the type represented by @var{rtd}.  The returned procedure
accepts exactly one argument which must be a record of the appropriate
type; it returns the current value of the field named by the symbol
@var{field-name} in that record.  The symbol @var{field-name} must be a
member of the list of field-names in the call to @code{make-record-type}
that created the type represented by @var{rtd}.  (In Kawa,
the @var{field-name} can be any public non-final Object field
of the @code{Class} @var{rtd}.)
@end defun


@defun record-modifier rtd field-name
Returns a procedure for writing the value of a particular field of a
member of the type represented by @var{rtd}.  The returned procedure
accepts exactly two arguments: first, a record of the appropriate type,
and second, an arbitrary Scheme value; it modifies the field named by
the symbol @var{field-name} in that record to contain the given value.
The returned value of the modifier procedure is unspecified.  The symbol
@var{field-name} must be a member of the list of field-names in the call
to @code{make-record-type} that created the type represented by
@var{rtd}.  (In Kawa,
the @var{field-name} can be any public non-final Object field
of the @code{Class} @var{rtd}.)
@end defun

@defun record? obj
Returns a true value if @var{obj} is a record of any type and a false
value otherwise.

In Kawa, this is true if @var{obj} is an instance of @code{kawa.lang.Record}.
@end defun

@defun record-type-descriptor record
Returns a record-type descriptor representing the type of the given
record.  That is, for example, if the returned descriptor were passed to
@code{record-predicate}, the resulting predicate would return a true
value when passed the given record.  In Kawa, @var{record} may be any object,
and the value returned is the class of the object.
@end defun

@defun record-type-name rtd
Returns the type-name associated with the type represented by rtd.  The
returned value is @code{eqv?} to the @var{type-name} argument given in
the call to @code{make-record-type} that created the type represented by
@var{rtd}.@refill
@end defun

@defun record-type-field-names rtd
Returns a list of the symbols naming the fields in members of the type
represented by @var{rtd}.  The returned value is @code{equal?} to the
field-names argument given in the call to @code{make-record-type} that
created the type represented by @var{rtd}.@refill
@end defun

@node Files, Ports, Records, Extensions
@section File System Interface

@defun file-exists? filename
Returns true iff the file named @var{filename} actually exists.
@end defun

@defun file-directory? filename
Returns true iff the file named @var{filename} actually exists
and is a directory.
@end defun

@defun file-readable? filename
Returns true iff the file named @var{filename} actually exists
and can be read from.
@end defun

@defun file-writable? filename
Returns true iff the file named @var{filename} actually exists
and can be writen to.
(Undefined if the @var{filename} does not exist,
but the file can be created in the directory.)
@end defun

@defun delete-file filename
Delete the file named @var{filename}.
@end defun

@defun rename-file oldname newname
Renames the file named @var{oldname} to @var{newname}.
@end defun

@defun copy-file oldname newname-from path-to
Copy the file named @var{oldname} to @var{newname}.
The return value is unspecified.
@end defun

@defun create-directory dirname
Create a new directory named @var{dirname}.
Unspecified what happens on error (such as exiting file with the same name).
(Currently returns @code{#f} on error, but may change to be more compatible
with scsh.)
@end defun

@node Ports, Exceptions, Files, Extensions
@section Ports

@defun call-with-input-string string proc
Create an input port that gets its data from @var{string},
call @var{proc} with that port as its one argument, and return
the result from the call of @var{proc}
@end defun

@defun call-with-output-string proc
Create an output port that writes its data to a @var{string},
and call @var{proc} with that port as its one argument.
Return a string consisting of the data written to the port.
@end defun

@defun force-output [port]
Forces any pending output on @var{port} to be delivered to the output
device and returns an unspecified value.  If the @var{port} argument is
omitted it defaults to the value returned by @code{(current-output-port)}.
@end defun

An interactive input port has a prompt procedure associated with it.
The prompt procedure is called before a new line is read.  It is passed
the port as an argument, and returns a string, which gets printed as a prompt.

@defun input-port-prompter port
Get the prompt procedure associated with @var{port}.
@end defun

@defun set-input-port-prompter! port prompter
Set the prompt procedure associated with @var{port} to @var{prompter},
which must be a one-argument procedure taking an input port,
and returning a string.
@end defun

@defun default-prompter port
The default prompt procedure.  It returns @code{"#|kawa:@var{L}|# "}, where
@var{L} is the current line number of @var{port}.
When reading a continuation line, the result
is @code{"#|@var{C}---:@var{L}|# "}, where @code{C} is the character returned
by @code{(input-port-read-state @var{port})}.
The prompt has the form of a comment to make it easier to cut-and-paste.
@end defun

@defun input-port-line-number port
Get the line number of the current line of @var{port},
which must be a (non-binary) input port.
The initial line is line 1.
@end defun

@defun set-input-port-line-number! port num
Set line number of the current line of @var{port} to @var{num}.
@end defun

@defun input-port-column-number port 
Get the column number of the current line of @var{port}, 
which must be a (non-binary) input port.
The initial column is column 1.
@end defun

@defun input-port-read-state port
Returns a character indicating the current @code{read} state of the @var{port}.
Returns @code{#\Return} if not current doing a @var{read},
@code{#\"} if reading a string;  @code{#\|} if reading a comment;  @code{#\(}
if inside a list; and @code{#\Space} when otherwise in a @code{read}.
The result is intended for use by prompt prcedures, and is not necessarily
correct except when reading a new-line.
@end defun

@defvar symbol-read-case
A symbol that controls how @code{read} handles letters when reading a symbol.
If the first letter is @samp{U}, then letters in symbols are upper-cased.
If the first letter is @samp{D} or @samp{L}, then letters
in symbols are down-cased.
If the first letter is @samp{I}, then the case of letters in symbols
is inverted.
Otherwise (the default), the letter is not changed.
(Letters following a @samp{\} are always unchanged.)
@end defvar

@defvar port-char-encoding
Controls how bytes in external files are converted to/from internal
Unicode characters.  Can be either a symbol or a boolean.
If @code{port-char-encoding} is @code{#f}, the file is assumed
to be a binary file and no conversion is done.
Otherwise, the file is a text file.  The default is @code{#t}, which
uses a locale-dependent conversion.  If @code{port-char-encoding}
is a symbol, it must be the name of a character encoding known to Java.
For all text files (that is if @code{port-char-encoding} is not @code{#f}),
on input a @code{#\Return} character or
a @code{#\Return} followed by @code{#\Newline}
are converted into plain @code{#\Newline}.
@end defvar

@node Exceptions, Eval and Environments, Ports, Extensions
@section Signalling and recovering from exceptions

@defun catch key thunk handler
Invoke @var{thunk} in the dynamic context of @var{handler} for
exceptions matching @var{key}.  If thunk throws to the symbol @var{key},
then @var{handler} is invoked this way:

@example
(handler key args ...)
@end example

@var{key} may be a symbol.  The @var{thunk} takes no
arguments.  If @var{thunk} returns normally, that is the return value of
@code{catch}.

Handler is invoked outside the scope of its own @code{catch}.  If
@var{handler} again throws to the same key, a new handler from further
up the call chain is invoked.

If the key is @code{#t}, then a throw to @emph{any} symbol will match
this call to @code{catch}.
@end defun

@defun throw key &rest args ...
Invoke the catch form matching @var{key}, passing @var{args} to the
@var{handler}.  

If the key is a symbol it will match catches of the same
symbol or of #t.

If there is no handler at all, an error is signaled.
@end defun

@deffn procedure error message args ...
Raise an error with key @code{misc-error} and a message constructed by
displaying @var{msg} and writing @var{args}.
This normally prints a stack trace, and brings you back to
the top level, or exits kawa if you are not running interactively.
@end deffn

@defun primitive-throw exception
Throws the @var{exception}, which must be an instance of a sub-class
of @code{<java.lang.Throwable>}.
@end defun

@deffn Syntax try-finally body handler
Evaluate @var{body}, and return its result.
However, before it returns, evaluate @var{handler}.
Even if @var{body} returns abnormally (by throwing an exception),
@var{handler} is evaluated.

(This is implemented just like Java's @code{try}-@code{finally}.)
@end deffn

@deffn Syntax try-catch body handler ...
Evaluate @var{body}, in the conect of the given @var{handler-spec}s.
Each @var{handler} has the form:
@example
@var{var} @var{type} @var{exp} ...
@end example
If an exception is thrown in @var{body}, the first @var{handle-spec}
is selected such that the thrown exception is an instance of
the @var{handler}'s @var{type}. If no @var{handler} is selected,
the exception is propagated through the dynamic execution context
until a matching @var{handler} is found.  (If no matching @var{handler}
is found, then an error message is printed, and the computation terminated.)

Once a @var{handler} is selected,
the @var{var} is bound to the thrown exception, and the @var{exp} in
the @var{handler} are executed.  The result of the @code{try-catch}
is the result of @var{body} if no exception is thrown, or the
value of the last @var{exp} in the selected @var{handler} if an
exception is thrown.

(This is implemented just like Java's @code{try}-@code{catch}.)
@end deffn

@defun dynamic-wind in-guard thunk out-guard
All three arguments must be 0-argument procedures.
First calls @var{in-guard}, then @var{thunk}, then @var{out-guard}.
The result of the expression is that of @var{thunk}.
If @var{thunk} is exited abnormally (by throwing an exception or
invoking a continuation), @var{out-guard} is called.

If the continuation of the dynamic-wind is re-entered (which
is not yet possible in Kawa), the @var{in-guard} is called again.

This function will be in R5RS.
@end defun

@node Eval and Environments, Quantities, Exceptions, Extensions
@section Eval and Environments

@defun eval expression [environment]
@code{eval} evaluates @var{expression} in the environment indicated
by @var{environment}.

The default for @var{environment} is the result
of @code{(interaction-environment)}.
@end defun

@defun null-environment
This procedure returns an environment that contains no variable bindings,
but contains (syntactic) bindings for all the syntactic keywords.

The effect of assigning to a variable in this environment (such
as @code{let}) is undefined.
@end defun

@defun scheme-report-environment version
The @var{version} must be an exact non-negative inetger corresponding to
a version of one of the Revised@var{version} Reports on Scheme.
The procedure returns an environment that contains exactly the set of
bindings specified in the corresponding report.

This implementation supports @var{version} that is 4 or 5.

The effect of assigning to a variable in this environment (such
as @code{car}) is undefined.
@end defun

@defun interaction-environment
This procedure return an environment that contains implementation-defined
bindings, as well as top-level user bindings.
@end defun

@defun environment-bound? environment symbol
Return true @code{#t} if there is a binding for @var{symbol}
in @var{environment};  otherwise returns @code{#f}.
@end defun

@deffn Syntax fluid-let ((variable init) ...) body ...
Evaluate the @var{init} expressions.
Then modify the dynamic bindings for the @var{variables} to the
values of the @var{init} expressions, and evaluate the @var{body} expressions.
Return the result of the last expression in @var{body}.
Before returning, restore the original bindings.
The temporary bindings are only visible in the current thread, and its
descendent threads.
@end deffn

@node Quantities, Threads, Eval and Environments, Extensions
@section Quantities

As a super-class of numbers, Kawa also provides quantities.
A @dfn{quantity} is a product of a @dfn{unit} and a pure number.
The number part can be an arbitrary complex number.
The unit is a product of integer powers of base units,
such as meter or second.

Kawa quantities are a generalization of the quantities in DSSSL,
which only has length-derived quantities.

The precise syntax of quantity literals may change,
but some examples are @code{10pt} (10 points), @code{5s} (5 seconds),
and @code{4cm2} (4 square centimeters).

@defun quantity? object
True iff @var{object} is a quantity.  Note that all numbers are
quantities, but not the other way round.
@end defun

@defun quantity->number q
Returns the pure number part of the quantity @var{q}, relative to
primitive (base) units.
If @var{q} is a number, returns @var{q}.
If @var{q} is a unit, yields the magitude of @var{q} relative to base units.
@end defun

@defun quantity->unit q
Returns the unit of the quantity @var{q}.
If @var{q} is a number, returns the empty unit.
@end defun

@defun make-quantity x unit
Returns the product of @var{x} (a pure number) and @var{unit}.
You can specify a string instead of @var{unit}, such as @code{"cm"}
or @code{"s"} (seconds).
@end defun

@deffn Syntax define-unit unit-name expression
Define @var{unit-name} as a unit (that can be used in literals)
equal to the quantity @var{expression}.
@end deffn

@node Threads, Standard Types, Quantities, Extensions
@section Threads

There is a very preliminary interface to create parallel threads.
The interface is similar to the standard @code{delay}/@code{force},
where a thread is basically the same as a promise, except that
evaluation may be in parallel.

So far, little or no effort has been made into making Kawa
thread-safe.  There are no per-thread bindings, and
the current input and output parts are global.
That needs to change.

@deffn Syntax future expression
Creates a new thread that evaluates @var{expression}.
@end deffn

@defun force thread
The standard @code{force} function has generalized to also work
on threads.  If waits for the thread's @var{expression} to finish
executing, and returns the result.
@end defun

@defun sleep time
Suspends the current thread for the specified time.
The @var{time} can be either a pure number (in secords),
or a quantity whose unit is a time unit (such as @code{10s}).
@end defun

@node Standard Types, Miscellaneous, Threads, Extensions
@section Standard Types

Kawa has first-class types, that you can use in various ways.
Currently, these are mainly useful for interfacing with primitive Java methods
(such as @code{primitive-virtual-function}, but they will be useful
for other purposes (such as declarating variables) later.

These types are bound to identifiers having the form @code{<TYPENAME>}.
(This syntax and most of the names are as in RScheme.)

To find which Java classes these types map into, look in
@code{kawa/lang/PrimProcedure.java}.

@defvar <object>
An arbitrary Scheme value - and hence an arbitrary Java object.
@end defvar

@defvar <integer>
The type of Scheme integers.
@end defvar

@defvar <symbol>
The type of Scheme symbols.
@end defvar

@defvar <keyword>
The type of keyword values.  @xref{Keywords}.
@end defvar

@defvar <list>
The type of Scheme lists (pure and impure, including the empty list).
@end defvar

@defvar <pair>
The type of Scheme pairs.  This is a sub-type of @code{<list>}.
@end defvar

@defvar <string>
The type of (mutable) Scheme strings.
This is @emph{not} the same as (non-mutable) Java strings
(which happen to be the same as @code{<symbol>}).
@end defvar

@defvar <vector>
The type of Scheme vectors.
@end defvar

@defvar <function>
The type of Scheme procedures.
@end defvar

More will be added later.

In addition, any Java type can be named using this syntax.
For example @code{<java.lang.StringBuffer[]>} represents
an array of references to @code{java.lang.StringBuffer} objects.

@node Miscellaneous,  , Standard Types, Extensions
@section Miscellaneous

@defun scheme-implementation-version
Returns the Kawa version number as a string.
@c (Compatible with slib.)
@end defun

@defun gentemp
Returns a new (interned) symbol each time it is called.
The symbol names are implementation-dependent.
@end defun

@deffn Syntax defmacro name lambda-list form ...
Defines an old-style macro a la Common Lisp,
and installs @code{(lambda @var{lambda-list} @var{form} ...)}
as the expansion function for @var{name}.
When the translator sees an application of @var{name},
the expansion function is called with the rest of the application
as the actual arguments.  The resulting object must be a Scheme
source form that is futher processed (it may be repeatedly macro-expanded).

If you define a macro with @code{defmacro}, you (currently) cannot use
the macro in the same compilation as the definition.
This restriction does not apply to macros defined by @code{define-syntax}.
@end deffn

@defvar command-line-arguments
Any command-line arguments (following flags processed by Kawa itself)
are assigned to the global variable @samp{command-line-arguments},
which is a vector of strings.
@end defvar

@defvar home-directory
A string containing the home directory of the user.
@end defvar

@defun exit [code]
Exits the Kawa interpreter, and ends the Java session.
The integer value @var{code} is returned to the operating
system.  If @var{code} is not specified, zero is returned,
indicating normal (non-error) termination.
@end defun

@defun scheme-window [shared]
Create a read-eval-print-loop in a new top-level window.
If @var{shared} is true, it uses the same environment as the
current @code{(interaction-environment)};  if not (the default),
a new top-level environment is created.

You can create multiple top-level window that can co-exist.
These run in separate threads.  However, because of some unknown
thread dependency, these windows will not work if you started an
non-window command-loop.
@end defun

@defun apply proc [arg1 ...] args
@var{Args} must be a sequence (list, vector, or string) or a
primitive Java array.
(This is an extension over standard Scheme, which requires that
@var{args} be a list.)
Calls the @var{proc} (which must be a procedure), using as arguments
the @var{arg1}... values plus all the elements of @var{args}.
@end defun

@deffn Syntax when condition form...
If @var{condition} is true, evaluate each @var{form} in order,
returning the value of the last one.
@end deffn

@deffn Syntax unless condition form...
If @var{condition} is false, evaluate each @var{form} in order,
returning the value of the last one.
@end deffn

@defun vector-append @var{arg}...
Creates a new vector, containing the elements from all the @var{arg}s
appended together.   Each @var{arg} may be a vector or a list.
@end defun

@defun instance? value type
Returns @code{#t} iff @var{value} is an instance of type @var{type}.
(Undefined if @var{type} is a primitive type, such as @code{<int>}.)
@end defun

@defun as type value
Converts or coerces @var{value} to a value of type @var{type}.
Throws an exception if that cannot be done.
@end defun

@node Compiling, Low-level functions, Extensions, Top
@chapter Compiling Scheme code to byte-codes

All Scheme functions and source files are invisibly compiled
into internal Java byte-codes.
A traditional evaluator is only used for top-level directly entered
expressions @emph{outside} a lambda.  (It would have been simpler
to also byte-compile top-level expressions by surrounding them
by a dummy lambda.  However, this would create a new Class object
in the Java VM for every top-level expression.  This is undesirable
unless you have a VM that can garbage collect Class objects.)

To save speed when loading large Scheme source files, you probably
want to pre-compile them and save them on your local disk.
There are two ways to do this.

You can compile a Scheme source file to a single archive file.
You do this using the @code{compile-file} function.
The result is a single file that you can move around and @code{load}
just like the @code{.scm} source file.  You just specify the name
of the archive file to the @code{load} procedure.
Currently, the archive is a "zip" archive and has extension ".zip";
a future release will probably use "Java Archive" (jar) files.
The advantage of compiling to an archive is that it is simple
and transparent.  A minor disadvantage is that it causes the
Java "verifier" to be run when functions are loaded from it,
which takes a little extra time.

Alternatively, you can compile a Scheme source file to a
collection of @samp{.class} files.
You then use the standard Java class loading mechanism to load the code.
The Java "verifier" does not need to get run, which makes
loading a little faster.
The compiled class files do have to be installed be installed somewhere
in the @code{CLASSPATH}.

@menu
* Archive compilation::         Compiling Scheme to an archive file
* Files compilation::           Compiling Scheme to a set of .class files
* Application compilation::     Compiling Scheme to a standalone application
@end menu

@node Archive compilation, Files compilation, Compiling, Compiling
@section Compiling Scheme to an archive file

To byte-compile a file @samp{foo.scm} do:
@example
(compile-file "foo.scm" "foo")
@end example

This will create @samp{foo.zip}, which contains byte-compiled "j-code"
that implements @samp{foo.scm}.

You can later do:
@example
(load "foo")
@end example

This will load @samp{foo.zip}, which should have the same effect as
loading @samp{foo.scm}, except you will get the byte-compiled versions.

@node Files compilation,  Application compilation, Archive compilation, Compiling
@section Compiling Scheme to a set of .class files

Invoking @samp{kawa} (or @samp{java kawa.repl}) with
the @samp{-C} flag will compile
a @samp{.scm} source file into one or more @samp{.class} files.

You run it as follows:
@example
kawa [-d @var{outdirectory}] [-P @var{prefix}] [-T @var{topname}] [--main] -C @var{infile}
@end example

Note the @samp{-C} must come last, because @samp{Kawa} processes the
arguments and options in order,

Here:
@table @samp
@item -C @var{infile}
The Scheme source file we want to compile.
@item -d @var{outdirectory}
The directory under which the resulting @samp{.class} files will be.
The default is the current directory.
@item -P @var{prefix}
A string to prepend to the generated class names.
The default is the empty string.
@item -T @var{topname}
The name of the "top" class - i.e. the one that contains the code
for the top-level expressions and definitions.
The default is generated from the @var{infile} and @var{prefix}.
@item --main
Generate a @code{main} method so that the resulting "top" class can
be used as a stand-alone application. @xref{Application compilation}.
@end table

When you actually want to load the classes, the @var{outdirectory}
must be in your @samp{CLASSPATH}.
You can use the standard @code{load} function to load the code,
by specifying the top-level class, either as a file name
(relative to @var{outdirectory}) or a class name.
E.g. if you did:
@example
kawa -d /usr/local/share/java -P my.lib. -T foo -C foosrc.scm
@end example
you can use either:
@example
(load "my.lib.foo")
@end example
or:
@example
(load "my/lib/foo.class")
@end example

If you are compiling a Scheme source file (say @samp{foosrc.scm})
that uses macros defined in some other file (say @samp{macs.scm}),
you need to make sure the definitions are visible to the compiler.
One way to do that is with the @samp{-f}:
@example
kawa -f macs.scm -C foosrc.scm
@end example

@node Application compilation, , Files compilation, Compiling
@section Compiling Scheme to a standalone application

A Java application is a Java class with a special method
(whose name is @code{main}).  The application can be invoked directly
by naming it in the Java command.
If you want to generate an application from a Scheme program,
create a Scheme source file with the definitions you need, plus
the top-level actions that you want the application to execute.
You can compile in the regular way decribed in the previous section, but add
the @code{--main} option.  For example,
assuming your Scheme file is @code{MyProgram.scm}:
@example
kawa --main -C MyProgram.scm
@end example
This will create a @code{MyProgram.class} which you can either @code{load}
(as decribed in the previous section), or invoke as an application:
@example
java MyProgram @var{[args]}
@end example
Your Scheme program can access the command-line arguments @var{args}
by using the global variable @samp{command-line-arguments}.

@node Low-level functions, Reporting Bugs, Compiling, Top
@chapter The Scheme-Java interface

Kawa has extensive features so you can work with Java objects
and call Java methods,

@menu
* Scheme types in Java::
* Method operations::     Calling Java methods from Scheme
* Field operations::      Low-level operations on object fields
* Array operations::      Low-level operations on Java arrays
* Loading a ModuleBody::
* Evaluating Scheme expressions from Java::
@end menu

@node Scheme types in Java, Method operations, , Low-level functions
@section Scheme types in Java

All Scheme values are implemented by sub-classes of @samp{java.lang.Object}.

Scheme symbols are implemented using @code{java.lang.String}.
(Don't be confused by the fact the Scheme sybols are represented
using Java Strings, while Scheme strings are represented by
@code{kawa.lang.Scheme}.  It is just that the semantics of Java strings
match Scheme symbols, but do not match mutable Scheme strings.)
Interned symbols are presented as interned Strings.
(Note that with JDK 1.1 string literals are automatically interned.)

Scheme integers are implemented by @code{kawa.math.IntNum}.
Use the make static function to create a new IntNum from an int or a long.
Use the intValue or longValue methods to get the int or long value of
an IntNum.

A Scheme "flonum" is implemented by @code{kawa.math.DFloNum}.

A Scheme pair is implemented by @code{kawa.lang.Pair}.

A Scheme vector is implemented by @code{kawa.lang.Vector}.

Scheme characters are implemented using @code{kawa.lang.Char}.

Scheme strings are implemented using @code{kawa.lang.FString}.

Scheme procedures are all sub-classes of @code{kawa.lang.Procedure}.
Normally each function (lambda expression) in the source code is
compiled to a separate sub-class of @samp{Procedure}.
The "action" of a @samp{Procedure} is invoked by using one of
the @samp{apply*} methods:  @samp{apply0}, @samp{apply1},
@samp{apply2}, @samp{apply3}, @samp{apply4}, or @samp{applyN}.
Various sub-class of @samp{Procedure} provide defaults
for the various @samp{apply*} methods.  For example,
a @samp{Procedure2} is used by 2-argument procedures.
The @samp{Procedure2} class provides implementations of all
the @samp{apply*} methods @emph{except} @samp{apply2},
which must be provided by any class that extends @code{Procedure2}.

@node Method operations, Field operations, Scheme types in Java, Low-level functions
@section Calling Java methods from Scheme

Kawa provides a simple yet powerful "Foreign Function Interface",
which allows you to call any (virtual or static) Java method
as if it were a Scheme procedure.

These primitives require you to specify the parameter and return types.
Type specifications are currently required to be string literals
or one of the standard types (@pxref{Standard Types}).
A type specifier can be a fully-qualified Java class name
(for example @code{<java.lang.StringBuffer>}).  In that case,
the actual argument is cast at run time to the named class.
The specification @code{<String>} is an exception:
It causes the @code{toString} method of the actual
argument to be invoked.

A type specifier can also be one of the primitive Java types.
The numeric types @code{<long>}, @code{<int>}, @code{<short>},
@code{<byte>}, @code{<float>}, and @code{<double>} are converted from the
corresponding Scheme number classes.  Similarly, @code{<char>}
can be converted to and from Scheme characters.  The type
@code{boolean} matches any object, and the result is @code{false}
if and only if the actual argument is @code{#f}.
The return type @code{<void>} indicates that no value is returned.

@deffn Syntax primitive-constructor class (argtype ...)
Returns a new anonymous procedure, which when called will create
a new object of the specified class, and will then call the
constructor matching the specified argument types.
@end deffn

@deffn Syntax primitive-virtual-method class method rtype (argtype ...)
Returns a new anonymous procedure, which when called will
invoke the instance method whose name is the string @var{method}
in the class whose name is @var{class}.
@end deffn

@deffn Syntax primitive-static-method class method rtype (argtype ...)
Returns a new anonymous procedure, which when called will
invoke the static method whose name is the string @var{method}
in the class whose name is @var{class}.
@end deffn

@deffn Syntax primitive-interface-method interface method rtype (argtype ...)
Returns a new anonymous procedure, which when called will
invoke the matching method from the interface whose name is @var{interface}.
@end deffn

The macros return procedure values, just like @code{lambda}.
If the macros are used directly as the procedure of a procedure call,
then kawa can inline the correct bytecodes to call the specified methods.
(Note also that neither macro
checks that there really is a method that matches the specification.)
Otherwise, the Java reflection facility is used.

Some examples using these primitives are @samp{vectors.scm}
and @samp{characters.scm} the directory @samp{kawa/lib} in
the Kawa sources.

@node Field operations, Array operations, Method operations, Low-level functions
@section Low-level Operations on Object Fields

The following macros evaluate to procedures that can be used to
access or change the fields of objects or static fields.
The compiler can inline each to a single bytecode instruction
(not counting type conversion).

@deffn Syntax primitive-get-field class fname ftype
Use this to access a field named @var{fname} having type @var{type} in
class @var{class}.  Evaluates to a new one-argument procedure,
whose argument is a reference to an object of the specified @var{class}.
Calling that procedure returns the value of the specified field.
@end deffn

@deffn Syntax primitive-set-field class fname ftype
Use this to change a field named @var{fname} having type @var{type} in
class @var{class}.  Evaluates to a new two-argument procedure,
whose first argument is a reference to an object of the
specified @var{class}, and the second argument is the new value.
Calling that procedure sets the field to the specified value.
(This macro's name does not end in a @samp{!}, because it does not actually
set the field.  Rather, it returns a function for setting the field.)
@end deffn

@deffn Syntax primitive-get-static class fname ftype
Like @code{primitive-get-field}, but used to access static fields.
Returns a zero-argument function, which when called returns
the value of the static field.
@end deffn

@deffn Syntax primitive-set-static class fname ftype
Like @code{primitive-set-field}, but used to modify static fields.
Returns a one-argument function, which when called sets the
value of the static field to the argument.
@end deffn

@node Array operations, Loading a ModuleBody, Field operations, Low-level functions
@section Low-level Operations on Java Arrays

The following macros evaluate to procedures that can be used to
manipulate primitive Java array objects.
The compiler can inline each to a single bytecode instruction
(not counting type conversion).

@deffn Syntax primitive-array-new element-type
Evaluates to a one-argument procedure.  Applying the resulting procedure to
an integer count allocates a new Java array of the specified length,
and whose elements have type @var{element-type}.
@end deffn

@deffn Syntax primitive-array-set element-type
Evaluates to a three-argument procedure.  The first argument of
the resulting procedure must be an array whose elements have type
@var{element-type};  the second argument is an index;  and the third
argument is a value (coercible to @var{element-type}) which replaces
the value specified by the index in the given array.
@end deffn

@deffn Syntax primitive-array-set element-type
Evaluates to a two-argument procedure.  The first argument of
the resulting procedure must be an array whose elements have type
@var{element-type};  the second argument is an index.
Applying the procedure returns the element at the specified index.
@end deffn

@deffn Syntax primitive-array-new element-type
Evaluates to a one-argument procedure.  The argument of
the resulting procedure must be an array whose elements have type
@var{element-type}.
Applying the procedure returns the length of the array.
@end deffn

@node Loading a ModuleBody, Evaluating Scheme expressions from Java, Array operations, Low-level functions
@section Loading a ModuleBody

The "top" class created by @code{kawa -C} (@pxref{Files compilation})
extends the @code{ModuleBody} class.  It is actually fairly
easy to write a @code{ModuleBody} by hand in Java, and you can
then use the Scheme @code{load} procedure to cause arbitrary
actions.  Here is an example.
@emph{(Note that the details are subject to change!)}

@example
package MyDev;
import kawa.lang.*;
class MyDevFunc extends Procedure2
@{
  public Object apply2 (Object arg1, Object arg2)
  @{
    ... stuff to control my device ...;
  @}
@}

public class MyDevice extends ModuleBody
@{
  public Object run (Environment env)
    throws WrongArguments, WrongType, GenericError, UnboundSymbol
  @{
    ... initialize my device here ...;

    // Declare (handle-my-device x y) to call MyDevFunc.apply2 (x, y):
    env.define ("handle-my-device", new MyDevFunc ());

    // Return the void value (i.e. no value).
    return Interpreter.voidObject;
  @}
@}
@end example

If this text is in the file @code{MyDev/MyDevice.java}, and you compile
it with @code{javac}, you will get @code{MyDev/MyDevice.class}
and @code{MyDev/MyDevFunc.class}.  Assuming the current directory
is in your @code{CLASSPATH}, you can now do the following in Kawa:
@example
(load "MyDev/MyDevice.class")
@end example
or:
@example
(load "MyDev.MyDevice")
@end example

This will cause the actions in @code{MyDevice.run} to be executed.
The current environment is passed in as the parameter @code{env}.
One of those actions is to define the procedure @code{handle-my-device}.

@node Evaluating Scheme expressions from Java, , Loading a ModuleBody, Low-level functions
@section Evaluating Scheme expressions from Java

The following methods are recommended if you need to evaluate a
Scheme expression from a Java method.
(Some details (such as the @samp{throws} lists) may change.)

@deftypefn {Static method} Object Scheme.eval (InPort @var{port}, Environment @var{env})
Read expressions from @var{port}, and evaluate them in the
@var{env} environment, until end-of-file is reached.
Return the value of the last expression,
or @code{Interpreter.voidObject} if there is no expression.
@end deftypefn

@deftypefn {Static method} Object Scheme.eval (String @var{string}, Environment @var{env})
Read expressions from @var{string}, and evaluate them in the
@var{env} environment, until the end of the string is reached.
Return the value of the last expression,
or @code{Interpreter.voidObject} if there is no expression.
@end deftypefn

@deftypefn {Static method} Object Scheme.eval (Object @var{sexpr}, Environment @var{env})
The @var{sexpr} is an S-expression (as may be returned by @code{read}).
Evaluate it in the @var{env} environment, and return the result.
@end deftypefn

For the @code{Environment} in most cases you could use
@samp{Environment.current()}.

@node Reporting Bugs, License, Low-level functions, Top
@chapter Reporting Bugs

If you have a problem installing or using Kawa,
send mail to @code{kawa@@cygnus.com}

This mailing list is used for reporting bugs, patches, discussing
changes to Kawa, and announcing snapshots.  If you wish to subscribe
(or later unsubscribe), send a request to @code{kawa-request@@cygnus.com}.

Messages to the mailing list are archived
at @url{http://www.cygnus.com/ml/kawa/}.

@node License,  , Reporting Bugs, Top
@chapter License

This is the license for the Kawa software:

Note that the Kawa distribution includes two packages @code{gnu.bytecode}
and @code{gnu.math} which have different terms than Kawa itself
(but which impose no restrictions as long as you do not modify
those two packages).

In general, If the license of Kawa or asociated packages causes
difficulties, let me know.

@include license.terms

Here is the license for this manual:

Copyright @copyright{} 1996, 1997 Per Bothner
@*Parts of this manual were derived from the SLIB manual,
copyright @copyright{} 1993, 1994 Todd R. Eigenschink and Aubrey Jaffer.
@*Parts of this manual were derived from ISO/EIC 10179:1996(E)
(Document Style and Specifical Language) - unknown copyright.

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation approved
by the author.


@bye
