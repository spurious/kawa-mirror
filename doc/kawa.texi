\input texinfo.tex      @c -*-texinfo-*-
@c %**start of header
@setfilename kawa.info
@documentencoding UTF-8
@settitle The Kawa language framework
@setchapternewpage off
@syncodeindex fn cp
@syncodeindex vr cp
@syncodeindex pg cp
@c version: %W% %G%
@c %**end of header

@macro false{}
@code{#f}
@end macro

@macro true{}
@code{#t}
@end macro

@macro func{NAME}
@code{@sc{\NAME\}}
@end macro

@macro stxdef{NAME}
@findex @i{\NAME\}
@anchor{meta-\NAME\}@var{\NAME\} @t{::=}
@end macro

@ifnotinfo
@macro stxref{NAME}
@ref{meta-\NAME\, @var{\NAME\}}
@end macro
@end ifnotinfo
@ifinfo
@macro stxref{NAME}
@var{\NAME\}
@end macro
@end ifinfo

@macro stxlit{TEXT}
@t{@b{\TEXT\}}
@end macro
@macro stxlitlbrace
@t{@b{@{}}
@end macro
@macro stxlitat
@t{@b{@@}}
@end macro

@macro arbno{THING}
\THING\*
@end macro

@macro atleastone{THING}
\THING\+
@end macro

@macro meta{THING}
@var{\THING\}
@end macro

@macro vari{THING}
@var{\THING\1}
@end macro

@macro varii{THING}
@var{\THING\2}
@end macro

@macro variii{THING}
@var{\THING\3}
@end macro

@macro variv{THING}
@var{\THING\4}
@end macro

@include version.texi

@iftex
@finalout
@end iftex
@titlepage
@title The Kawa language framework
@subtitle @value{UPDATED}
@sp 1
@author Per Bothner
@page
@end titlepage

@ifinfo
@format
START-INFO-DIR-ENTRY
* kawa: (kawa).         The Kawa language framework
END-INFO-DIR-ENTRY
@end format
@end ifinfo

@ifnottex
@node Top, Installation, (dir), (dir)
@top The Kawa language framework
@end ifnottex

Kawa is:
@itemize
@item
A framework written in Java for implementing
high-level and dynamic languages, compiling them into Java bytecodes.
@item
An implementation of @uref{http://www.schemers.org/,Scheme}, which
is in the Lisp family of programming languages.
Kawa is a featureful dialect in its own right,
and additionally provides very useful integration with Java.
It can be used as a ``scripting language'', but includes a compiler
and all the benefits of a ``real'' programming language, including
optional static typing.
@item
Implementations of other programming languages,
including @uref{../qexo/index.html, XQuery (Qexo)}
and @uref{http://JEmacs.sourceforge.net/,Emacs Lisp (JEmacs)}.
@end itemize

This documents version @value{VERSION}, updated @value{UPDATED}.
See the summary
of @uref{http://www.gnu.org/software/kawa/news.html,recent changes}.

@c Old versions of makeinfo don't support: @ifnotdocbook
The Kawa home page (which is currently just an on-line
version of this document) is @uref{http://www.gnu.org/software/kawa/}.

@c (blank line needed above) @end ifnotdocbook

For lots of Scheme resources, see
@uref{http://www.schemers.org/,www.schemers.org},
including an online copy of the
@uref{http://www.schemers.org/Documents/Standards/,R6RS standard}.
A nice quick introduction to Scheme can be found in
@uref{http://www.cs.washington.edu/education/courses/341/99su/lectures/scheme/,Greg Badros's lecture notes}.  A more in-depth tutorial which also
discusses Scheme implementation is
@uref{ftp://ftp.cs.utexas.edu/pub/garbage/cs345/schintro-v14/schintro_toc.html, Paul Wilson's "An Introduction to Scheme and its Implementation"}.

For a technical overview of Kawa, see these
@uref{http://www.gnu.org/software/kawa/internals/index.html}.
Javadoc generated @uref{http://www.gnu.org/software/kawa/api/,documentation of the Kawa classes} is also available.
The packages
@uref{http://www.gnu.org/software/kawa/api/gnu/bytecode/package-summary.html,@code{gnu.bytecode}},
@uref{http://www.gnu.org/software/kawa/api/gnu/math/package-summary.html,@code{gnu.math}},
@uref{http://www.gnu.org/software/kawa/api/gnu/lists/package-summary.html,@code{gnu.lists}},
@uref{http://www.gnu.org/software/kawa/api/gnu/xml/package-summary.html,@code{gnu.xml}},
@uref{http://www.gnu.org/software/kawa/api/gnu/expr/package-summary.html,@code{gnu.expr}},
@uref{http://www.gnu.org/software/kawa/api/gnu/mapping/package-summary.html,@code{gnu.mapping}},
and
@uref{http://www.gnu.org/software/kawa/api/gnu/text/package-summary.html,@code{gnu.text}},
are used by Kawa, and distributed with it, but may be independently useful.

For copyright information on the software and documentation,
see @ref{License}.

The author of Kawa is
@uref{http://per.bothner.com/,Per Bothner}
@email{per@@bothner.com}.
Thanks to @uref{http://www.brainfood.com/,Brainfood}
and @uref{http://www.mercedsystems.com/,Merced Systems} for support in
developing Kawa.
Kawa is a re-write of Kawa 0.2, which was written by
R. Alexander Milowski @email{alex@@milowski.com}.

This package has nothing to do with the defunct Kawa commercial Java IDE.

@menu
* Installation::         Building and installing Kawa
* Running::              Invoking, Running, and Using Kawa
* Features::             Summary of Kawa Scheme Features
* Syntax::
* Multiple values::
* Symbols and namespaces::
* Procedures::
* Numbers::              Quantities and Numbers
* Characters and text::
* Data structures::
* Exceptions::           Exception handling
* Eval and Environments::
* Debugging::
* Threads::
* Processes::
* Miscellaneous::
* Input-Output::         Input, output, and file handling
* Types::
* Objects Classes and Modules::
* XML tools::            XML, HTML, and the web
* Low-level functions::  Deprecated low-level functions
* FAQs:: Frequently Asked Questions
* Community::
* License::
* Overall Index::	 Index of functions, macros, concepts, and more.
@end menu

@node Installation, Running, Top, Top
@chapter Getting and installing Kawa

@menu
* Getting Kawa::
* Running Java::                Getting and running Java
* Binary distribution::         Installing and using the binary distribution
* Source distribution::         Installing and using the source distribution
@end menu

@node Getting Kawa, Running Java, , Installation
@section Getting Kawa

You can compile Kawa from the source distribution.
Alternatively, you can install the pre-compiled binary distribution.

You can get Kawa sources and binaries from the Kawa ftp site
@uref{ftp://ftp.gnu.org/pub/gnu/kawa/},
or from a @uref{http://www.gnu.org/order/ftp.html,mirror site}.

The latest release of the Kawa source code is
@uref{ftp://ftp.gnu.org/pub/gnu/kawa/kawa-@value{VERSION}.tar.gz}.
(To unpack @code{.tar.gz} files Windows users can use
@uref{http://www.7-zip.org/,7-Zip}, which is Free Software.)

A ready-to-run @code{.jar} archive of the pre-compiled classes is in
@uref{ftp://ftp.gnu.org/pub/gnu/kawa/kawa-@value{VERSION}.jar}.

@subsection Getting the development sources using SVN

The Kawa sources are managed using a
@uref{http://subversion.apache.org/,Subversion (svn)} repository.
If you want the very latest version grab
@uref{http://subversion.apache.org/download/,an svn client},
and then check out the source using this command:
@example
svn -q checkout svn://sourceware.org/svn/kawa/trunk kawa
@end example

Some corporate firewalls may block outgoing Subversion
connections.  If that case you should be able to access the
Kawa Subversion repository using HTTP.  (If you need
to use an HTTP proxy, you can edit
@code{http-proxy-host} and @code{http-proxy-port}
in @code{~/.subversion/servers} as described
@uref{http://subversion.apache.org/faq.html#proxy, here}.)
Use this command instead:
@example
svn -q checkout http://sourceware.org/svn/kawa/trunk kawa
@end example

Once you have it checked out, you can keep it up-to-date with @code{svn update}.

You can also
@uref{http://sourceware.org/viewvc/kawa/,browse the svn archive} via viewvc.

@node Running Java, Binary distribution, Getting Kawa, Installation
@section Getting and running Java

Before installing Kawa, you will need a working Java system.
Kawa has been reported to
work with JDK from 1.1 through 1.6, Kaffe, Symantec Cafe, J++, and GCJ.
The released Kawa jar file assumes JDK 1.5 or equivalent functionality.
If those features are missing, you may need to build Kawa from source.

The discussion below assumes you are using the Java Developer's Kit
(JDK) from Sun.  You can download free copies of
@uref{http://java.sun.com/javase/downloads/index.jsp, JDK 1.6} for various platforms.

If you want to run Kawa on a Macintosh, see
@uref{http://rdsathene.org/scheme/mackawa.html}.

The program @code{java} is the Java interpreter.
The program @code{javac} is the Java compiler,
and is needed if you want to compile the source release yourself.
Both programs must be in your @code{PATH}.
If you have the JDK in directory @code{$JDK},
and you are using a Bourne-shell compatible shell
(/bin/sh, ksh, bash, and some others) you can set @code{PATH} thus:
@example
PATH=$JDK/bin:$PATH
export PATH
@end example

@node Binary distribution, Source distribution, Running Java, Installation
@section Installing and using the binary distribution

The binary release includes only the binary compiled @samp{.class}
versions of the same @samp{.java} source files in the source release.
It does not include any documentation, so you probably want the
source release in addition to the binary release.  The purpose
of the binary release is just to save you the time and trouble of
compiling the sources.

The binary release requires Java 5 (JDK 1.5) or later.
It does include support for certain Java 6 features
(@code{HttpServer}, @code{javax.script}, and Unicode normalization),
but these feature only work if you use Java 6, not Java 5.
If you have an older Java implementation, or build for a mobile
environment like Android, or optimize for Java 6,
then you will need to get the source distribution.

The binary release comes as a @code{.jar} archive
@samp{kawa-@value{VERSION}.jar}.
Copy this archive to some suitable location,
such as @code{/usr/local/lib/kawa.jar}.

Then, before you can actually run Kawa, you need to set @code{CLASSPATH}
so it includes the Kawa archive.  On Unix, using a Bourne-style shell:
@example
CLASSPATH=/usr/local/lib/kawa.jar
export CLASSPATH
@end example

On Windows you need to set @code{classpath} in a DOS console.
For example:
@example
set classpath=\kawa\kawa-@value{VERSION}.jar
@end example

Then to run Kawa do:
@example
java kawa.repl
@end example

To run Kawa in a fresh window, you can do:
@example
java kawa.repl -w
@end example

@node Source distribution,  , Binary distribution, Installation
@section Installing and using the source distribution
The Kawa release normally comes as a gzip-compressed tar file named
@samp{kawa-@value{VERSION}.tar.gz}.
@c The same sources are available as a zip file
@c @samp{kawa-@value{VERSION}-src.zip}.
Two methods are supporting for compiling the Kawa sources;
choose whichever is most convenient for you.

One method uses the traditional GNU @code{configure} script,
followed by running @code{make}.  This works well on Unix-like
systems, such as GNU/Linux.
You can also use this method on Microsoft Windows,
as long as use @uref{http://www.cygwin.org/. Cygwin}.

The other method uses the @code{ant} command, a Java-based
build system released by Apache's Jakarta project.  This uses
an @code{build.xml} file in place of @code{Makefile}s, and
works on non-Unix systems such as Microsoft Windows.  However,
the @code{ant} method does not support all
the features of the @code{configure}+@code{make} method.

@subsection Build Kawa using @code{configure} and @code{make}

In your build directory do:
@example
tar xzf kawa-@value{VERSION}.tar.gz
cd kawa-@value{VERSION}
@end example

Then you must configure the sources.  This you can do
the same way you configure most other GNU software.  Normally
you can just run the configure script with no arguments:

@example
./configure
@end example

This will specify that a later @code{make install} will install the
compiled @samp{.class} files into @code{/usr/local/share/java}.
If you want them
to be installed someplace else, such as @code{$PREFIX/share/java}, then
specify that when you run configure:
@example
./configure --prefix $PREFIX
@end example

If you have the GNU @samp{readline} library installed, you might try
adding the @samp{--enable-kawa-frontend} flag.  This will build the
@samp{kawa} front-end program, which provides input-line editing
and an input history.  You can get @samp{readline} from archives
of GNU programs, including @uref{ftp://www.gnu.org/}.

If you have Swing installed, and want to use JEmacs (Emacs in Java),
also pass the @code{--with-swing} flag to @code{configure}.

If you have installed Kawa before, make sure your @code{CLASSPATH}
does not include old versions of Kawa, or other classes that may
conflict with the new ones.

As-distributed, the Kawa source code requires Java 6.
If you only have Java 5, use the @code{--with-have-source} option:
@example
./configure --with-java-source=5
@end example

If you want to add support for certain Java 6 features,
but produce a @code{.jar} file that will execute under Java 5 do:
@example
./configure --with-java-source=6compat5
@end example
Note this requires that you build Kawa with Java 6.

In theory Kawa supports older versions of Java (such as JDK 1.4
or even 1.1), though this has not been tested in a while.
You use the appropriate @code{--with-java-source} option,
but you still need a Java 5 or later version of @code{javac}
to build Kawa.  You then need to use a tool
like @uref{http://retroweaver.sourceforge.net/, Retroweaver}
on the Kawa @code{.jar} to fix up Java 5 dependencies.
Contact the Kawa author if you want to be a tester for this.

Then you need to compile all the .java source files.
Just run make:
@example
make
@end example
This assumes that @samp{java} and @samp{javac} are the java interpreter
and compiler, respectively.
For example, if you are using the Kaffe Java interpreter,
you need to instead say:
@example
make JAVA=kaffe
@end example

It has been reported that parallel make doesn't work,
so don't use the @code{-j2} or above options.

If you configured with @code{--enable-kawa-frontend}, you
may need to specify @code{READLINE_INCLUDE_PATH} or @code{READINE_LIB_PATH}.
For example on OS/X you need to do:
@example
make READLINE_INCLUDE_PATH=-I/usr/local/unix/readline/include \
     READLINE_LIB_PATH=-L/usr/local/unix/readline/lib
@end example

You can now test the system by running Kawa in place:
@example
java kawa.repl
@end example

or you can run the test suite:
@example
make check
@end example

or you can install the compiled files:
@example
make install
@end example

This will install your classes into @code{$PREFIX/share/java} (and its
sub-directories).  Here @code{$PREFIX} is the directory you specified
to configure with the @code{--prefix} option, or @code{/usr/local} if you
did not specify a @code{--prefix} option.

To use the installed files, you need to set @code{CLASSPATH} so
that @code{$PREFIX/share/java/kawa.jar} is in the path:
@example
CLASSPATH=$PREFIX/share/java/kawa.jar
export CLASSPATH
@end example
This is done automatically if you use the @samp{kawa} script.

@subsection Build Kawa using @code{ant}

Kawa now includes an Ant buildfile (@code{build.xml}).
@uref{http://ant.apache.org, Ant} is a part of the Apache
Jakarta project.
If you don't hava Ant installed,
get it from @uref{http://ant.apache.org/bindownload.cgi}.
The build is entirely Java based and works equally well on *nix, Windows,
and presumably most any other operating system.

Once Ant has been installed and configured (you may need to set the
@code{JAVA_HOME}, and @code{ANT_HOME} environment variables), you should
be able to change to the directory containing the @code{build.xml} file,
and invoke the @samp{ant} command.  With the default settings, a
successful build will result in a @code{kawa-@value{VERSION}.jar} in the
current directory.

There are a few Ant "targets" of interest (they can be supplied on the
Ant command line):

@table @code
@item all
This is the default, it does @code{classes} and @code{jar}.
@item classes
Compiles all the files into @code{*.class} files into the directory
specified by the @code{build.dir} property.
@item jar
Builds a jar into into the directory
specified by the @code{dist.dir} property.
@item runw
Run Kawa in a GUI window.
@item clean
Deletes all files generated by the build, including the jar.
@end table

There is not yet a @code{test} target for running the testsuite.

The are various "properties" that control what @code{ant} does.  You can
override the on the command line or by editing the
@code{build.properties} file in the same directory as @code{build.xml}.
For example the @code{build.dir} directory tells @code{ant} where to
build temporary files, and where to leave the resulting @code{.jar}
file.  For example, to leave the generated files in the sub-directory
named @code{BUILD} do:
@example
ant -Dbuild.dir=BUILD
@end example
A sample @code{build.properties} is provided and it contains
comments explaining many of the options.

Here are a few general properties that help to customize your build:
@table @code
@item build.dir
Path to put the temporary files used for building.
@item dist.dir
Path to put the resulting jar file.
@item version.local
A suffix to add to the version label for your customized version.
@item debug
Whether (true/false) the Javac "-g" option is enabled.
@item optimize
Whether (true/false) the Javac "-O" option is enabled.
@end table

Here are some Kawa-specific ones (all @code{true}/@code{false}):
@code{with-collections}, @code{with-references}, @code{with-awt},
@code{with-swing}, @code{enable-jemacs}, and @code{enable-servlet}>
See the sample @code{build.properties} for more information on these.

If you change any of the build properties, you will generally want to do
an @samp{ant clean} before building again as the build is often not able to
notice that kind of change.  In the case of changing a directory path,
you would want to do the @code{clean} before changing the path.

A special note for NetBeans users:
For some reason the build-tools target which compiles an Ant task won't
compile with the classpath provided by NetBeans.
You may do @samp{ant build-tools} from the command line outside of NetBeans,
in which case you will not want to use the @code{clean} target as that
will delete the tool files as well.
You can use the @code{clean-build} and/or @code{clean-dist}
targets as appropriate.  Alternatively you can add @code{ant.jar} to the
@code{build-tools} classpath by copying or linking it into a @code{lib/ext}
directory in Kawa's source directory (the one containing the @code{build.xml}
file).

@subsection Compiling Kawa to native code with GCJ

The GNU Compiler for the Java(tm) Programming Language
(@uref{http://gcc.gnu.org/java/,GCJ}) is part of the
GNU Compiler Collection (@uref{http://gcc.gnu.org/,GCC}).
It can compile Java source or bytecode
files into native code on supported systems.
Version 4.1 or later of GCC is recommended,
and only Intel x86-based Linux/GNU system have been tested with Kawa.

First, get and install GCC.  Set @code{PREFIX} to where
you want to install GCJ, and configure it with these options:
@example
./configure --enable-threads --enable-languages=c++,java --prefix $PREFIX
make bootstrap
make install
@end example
Make sure @code{gcj} is in your path and refers to the newly-installed
version, and if needed, set @code{LD_LIBRARY_PATH} to point to the
directory where @code{libgcj.so} was installed:
@example
PATH=$PREFIX/bin:$PATH
LD_LIBRARY_PATH=$PREFIX/lib
export LD_LIBRARY_PATH
@end example

To build Kawa, you need to specify @code{--with-gcj} to
@code{configure} which tells it to use GCJ.
@example
./configure --with-gcj --prefix $PREFIX
@end example
Then as before:
@example
make
make install
@end example

Alternatively, you can use configure option
@code{--with-gcj-dbtool}.  This allows gcj to automatically
find the kawa shared libraries from the @code{.jar} file.

@subsection Building Kawa under MS-Windows

Using the @code{ant} method is recommended for building
Kawa under Microsoft Windows.
You may get an error message "@code{Out of environment space}."
See @uref{http://support.microsoft.com/support/kb/articles/Q230/2/05.ASP}
for a solution.  Alternatively you can run
the class @code{org.apache.tools.ant.Main} directly from the Ant jar.

The Kawa @code{configure} and @code{make} process assumes a Unix-like
environment.  If you want to build Kawa from source under Windows,
you could use a Unix empulation package, such
as the free @uref{http://sourceware.org/cygwin/,Cygwin}.
However, there are some problems with filenames that make this
more complicated than it should be.  It should be possible
to build Kawa under Cygwin using @code{gcj} as descibed above.

@node Running, Features, Installation, Top
@chapter How to start up and run Kawa

The easiest way to start up Kawa is to run the @samp{kawa} program.
This finds your java interpreter, and sets up @samp{CLASSPATH} correctly.
If you have installed Kawa such @code{$PREFIX/bin} is in your @code{$PATH},
just do:
@example
kawa
@end example
However, @samp{kawa} only works if you have a Unix-like environment.
On some platforms, @samp{kawa} is a program that uses the GNU
@samp{readline} library to provide input line editing.

To run Kawa manually, you must start a Java interpreter.
How you do this depends on the Java interpreter.
For Sun's JDK s and some other implementations, you must have the
Java interpret (usually named @code{java}) in your @code{PATH}.
You must also make sure that the @code{kawa/repl.class} file,
the rest of the Kawa packages, and the standard Java
packages can be found by searching CLASSPATH.
@xref{Running Java}.

Then you do:
@example
java kawa.repl
@end example

In either case, you will then get the @samp{#|kawa:1|#} prompt,
which means you are
in the Kawa read-eval-print-loop.  If you type a Scheme
expression, Kawa will evaluate it.  Kawa will then print the
result (if there is a non-"void" result).

@menu
* Options::      Command-line arguments
* Scripts::      Running Command Scripts
* New-Window::   Running a Command Interpreter in a new Window
* Exiting::      Exiting Kawa
* Compiling::    Compiling to byte-code or an executable
@end menu

@node Options, Scripts, Running, Running
@section Command-line arguments

@cindex options
You can pass various flags to Kawa, for example:
@example
kawa -e '(display (+ 12 4))(newline)'
@end example
or:
@example
java kawa.repl -e '(display (+ 12 4))(newline)'
@end example
Either causes Kawa to print @samp{16}, and then exit.

At startup, Kawa executes an init file from the user's home
directory.
The init file is named @code{.kawarc.scm} on Unix-like systems
(those for which the file separator is @code{'/'}),
and @code{kawarc.scm} on other systems.
This is done before the read-eval-print loop
or before the first @code{-f} or @code{-c} argument.  (It is not run
for a @code{-e} command, to allow you to set options to override
the defaults.)

If there are further command-line arguments after the options
have been processed, then the first remaining argument names a
file that is read and evaluated.  If there is no such argument,
then Kawa enters an interactive read-eval-print loop,
but only if none of the @samp{-c}, @samp{-e}, @samp{-f}, @samp{-s},
@samp{-C}, or @samp{--} options were specified.

@subsection General options

@table @code
@item -e @var{expr}
Kawa evaluates @var{expr}, which contains one or more Scheme expressions.
Does not cause the @code{~/.kawarc.scm} init file to be run.
@item -c @var{expr}
Same as @samp{-e @var{expr}}, except that it
does cause the @code{~/.kawarc.scm} init file to be run.
@item -f @var{filename-or-url}
Kawa reads and evaluates expressions from the file named
by @var{filename-or-url}.  If the latter is @samp{-},
standard input is read (with no prompting).  Otherwise,
it is equivalent to evaluating @samp{(load "@var{filename-or-url}")}.
The @var{filename-or-url} is interpreted as a URL
if it is absolute - it starts with a "URI scheme" like @code{http:}.
@item -s
@itemx --
The global variable @samp{command-line-arguments} is set to the remaining
arguments (if any), and an interactive read-eval-print loop is started.
This uses the same "console" as where you started up Kawa;
use @samp{-w} to get a new window.
@item --script @var{filename-or-url}
@itemx --script@var{N} @var{filename-or-url}
The global variable @samp{command-line-arguments} is set to the remaining
arguments (if any).
Kawa reads and evaluates expressions from the file named
by @var{filename-or-url}.
If @code{script} is followed by an integer @var{N},
then @var{N} lines are skipped first.

Skipping some initial lines is useful if you want to have a non-Kawa
preamble before the actual Kawa code.
One use for this is for Kawa shell scripts (@pxref{Scripts}).

@item -w
Creates a new top-level window, and runs an interactive read-eval-print
in the new window.  See @ref{New-Window}.
Same as @code{-e (scheme-window #t)}.
You can specify multiple @samp{-w} options, and also use @samp{-s}.
@item --help
Prints out some help.
@item --version
Prints out the Kawa version number, and then exits.
@item --server @var{portnum}
Start a server listening from connections on the specified @var{portnum}.
Each connection using the Telnet protocol causes a new read-eval-print-loop
to started.  This option allows you to connect using any
Telnet client program to a remote "Kawa server".
@end table

@subsection Options for language selection

@table @code
@item --scheme
Set the default language to Scheme.
(This is the default unless you select another language,
or you name a file with a known extension on the command-line.)
@item --elisp
@itemx --emacs
@itemx --emacs-lisp
Set the default language to Emacs Lisp.
(The implementation is quite incomplete.)
@item --lisp
@itemx --clisp
@itemx --clisp
@itemx --commonlisp
@itemx --common-lisp
Set the default language to CommonLisp.
(The implementation is @emph{very} incomplete.)
@item --krl
Set the default language to KRL.  See @ref{KRL}.
@item --brl
Set the default language to KRL, in BRL-compatibility mode.  See @ref{KRL}.
@item --xquery
Set the default language to the draft XML Query language.
See the @uref{http://www.gnu.org/software/qexo/,Kawa-XQuery page}
for more information.
@item --xslt
Set the default language to XSLT (XML Stylesheet Language Transformations).
(The implementation is @emph{very} incomplete.)
See the @uref{http://www.gnu.org/software/qexo/xslt.html,Kawa-XSLT page}
for more information.
@item --pedantic
Try to follow the approprate language specification to the letter,
even in corner cases, and even if it means giving up some
Kawa convenience features.  This flags so far only affects
the XQuery parser, but that will hopefully change.
@end table

@subsection Options for setting variables

@table @code
@item @var{name}=@var{value}
Set the global variable with the specified @var{name} to the given @var{value}.
The type of the @var{value} is currently unspecified; the plan is for it
to be like XQuery's @dfn{untyped atomic} which can be coerced as needed.
@item @{@var{namespace-uri}@}@var{local-name}=@var{value}
Set the global variable with the specified namespace uri and
namespace-local name to the given value.
@end table

These options are processed when invoking the @code{kawa}
application (i.e. the @code{kawa.repl} application).
If you want a Kawa application compiled with @code{--main}
to process these these assignments, call the
@code{process-command-line-assignments} utility function.

@subsection Options for controlling output formatting

@table @code
@item --output-format @var{format}
@itemx --format @var{format}
Change the default output format to that specified by @var{format}.
See @ref{Named output formats} for more information and a list.
@end table

@table @code
@item out:base=@var{integer}
The number base (radix) to use by default when printing rational numbers.
Must be an integer between 2 and 36, and the default is of course 10.
For example the option @code{out:base=16} produces hexadecimal output.
Equivalent to setting the @code{*print-base*} variable.
@item out:radix=no|yes
If true, prints an indicator of the radix used when printing rational numbers.
The default is @code{no}.
Equivalent to setting the @code{*print-radix*} variable.
@item out:doctype-system=@var{system-identifier}
If @code{out:doctype-system} is specified then a @code{DOCTYPE} declaration
is written before writing a top-level XML element, using
the specified @var{system-identifier}.
@item out:doctype-public=@var{public-identifier}
Ignored unless  @code{out:doctype-system} is also specified,
in which case the @var{public-identifier} is written
as the public identifiers of the @code{DOCTYPE} declaration.
@item out:xml-indent=@var{kind}
Controls whether extra line breaks and indentation are added
when printing XML.
If @var{kind} is @code{always} or @code{yes} then newlines and
appropriate indentation are added before and after each element.
If @var{kind} is @code{pretty} then the pretty-printer is used
to only add new lines when an element otherwise won't fit on a single line.
If @var{kind} is @code{no} (the default) then no extra line breaks
or indentation are added.
@item out:line-length=@var{columns}
@itemx out:right-margin=@var{columns}
Specifies the maximum number of number of columns in a line
when the pretty-printer decides where to break a line.
(The two options are equivalent.)
@end table

@subsection Options for compiling and optimizing

The following options control which calling conventions are used:
@table @code
@item --full-tailcalls
Use a calling convention that supports proper tail recursion.
@item --no-full-tailcalls
Use a calling convention that does not support proper tail recursion.
Self-tail-recursion (i.e. a recursive call to the current function)
is still implemented correctly, assuming that the called function
is known at compile time.
@item --no-inline
Disable inlining of known functions and methods.
The generated code runs slower, but you can more reliably trace procedures.
Normally Kawa will assume that a procedure @code{fn}
declared using a @code{(define (fn args) body)} form is constant,
assuming it isn't modified in the current module.  However, it is
possible some other module might modify the binding of @code{fn}.
You can use the @code{--no-inline} to disable the assumption that @code{fn}
is constant.
@end table

The default is currently @code{--no-full-tailcalls} because
it is usually faster.
It is also closer to the Java call model, so may be better for people
primarily interested in using Kawa for scripting Java systems.

Both calling conventions can co-exist:  Code compiled
with @code{--full-tailcalls} can call code compiled
with @code{--no-full-tailcalls} and vice versa.

@table @code
@item --target @var{version}
The @var{version} can be a JDK or Java specification version:
@code{1.1}, @code{1.2}, @code{1.3}, @code{1.4},
@code{5}, @code{6}, or @code{7}.
The JDK versions @code{1.5} and @code{1.6} are equivalent to @code{5}
or @code{6}, respectively.
Specify a JVM (classfile) version to target.  This is useful
if (for example) you use Java 6, but want to create @code{.class} files
that can run on Java 5.  In that case specify @code{--target 5}.
@end table

The options @samp{-C}, @samp{-d}, @samp{-T}, @samp{-P}, @samp{--main}
@samp{--applet}, and @code{--servlet} are used to compile a Scheme file;
see @ref{Files compilation}.
The option @samp{--connect @var{portnum}} is only used by
the @samp{kawa} front-end program.

@subsection Options for debugging

The following options are useful if you want to debug or understand
how Kawa works.
@table @code
@item --debug-dump-zip
Normally, when Kawa loads a source file, or evaluates a non-trivial expression,
it generates new internal Java classes but does not write them out.  This
option asks it to write out generated classes in a @samp{.zip} archive
whose name has the prefix @samp{kawa-zip-dump-}.
@item --debug-print-expr
Kawa translates source language forms into an internal @code{Expression}
data structure.  This option causes that data structure to be written out
in a readable format to the standard output.
@item --debug-print-final-expr
Similar to the previous option, but prints out the @code{Expression} after
various transformations and optimizations have been done, and just before
code generation.
@item --debug-error-prints-stack-trace
Prints a stack trace with any error found during compilation.
@item --debug-warning-prints-stack-trace
Prints a stack trace with any warning found during compilation.
@end table

@subsection Options for web servers

JDK 6, the standard Java 6 distribution by Sun/Oracle,
includes a complete web server library.

@table @code
@item --http-auto-handler @var{context-path} @var{appdir}
Register a web application handler that uses files
in the directory @var{appdir} to handle HTTP (web) requests
containing the given @var{context-path}.  That is it handles
requests that start with @code{http://localhost:@var{port}@var{context-path}}.
(This assumes the @var{context-path} starts with a @code{/}.)
@xref{Self-configuring page scripts}.
@item --http-start @var{port}
Start the web server, listing on the specified @var{port}.
@end table

@node Scripts, New-Window, Options, Running
@section Running Command Scripts

Unix-like systems support a mechanism where a @dfn{script} can
specify a program that should execute it.  The convention
is that the first line of the file should start with the two characters
@samp{#!} followed by the absolute path of the program that should
process (interpret) the script.

This is convention works well for script languages that use @samp{#}
to indicate the start of a comment, since the interpreter will
automatically ignore the line specifying the interpreter filename.
Scheme, however, uses @samp{#} for various special objects,
and Kawa specifically uses @samp{#!} as a prefix for
various @ref{Special named constants} such as @code{#!optional}.

Kawa does recognize the three-character sequence @samp{#!/} at the
beginning of a file as special, and ignores it.  So you can
specify command interpreters, as long as you don't put a space
between the @samp{#!} and the interpreter filename.
Here is an example:
@example
#!/usr/local/bin/kawa
(format #t "The time is ~s~%" (make <java.util.Date>))
@end example

If this file has the execute permission set and is in your @code{PATH},
then you can execute it just by naming it on command line.  The
system kernel will automatically execute @code{kawa}, passing it the
filename as an argument.

Note that the full path-name of the @code{kawa} interpreter
must be hard-wired into the script.  This means you may have to edit
the script depending on where Kawa is installed on your system.
Another possible problem is that the interpreter must be an
actual program, not a shell script. Depending on how you configure
and install Kawa, @code{kawa} can be a real program or a script.
You can avoid both problems by the @code{env} program, available on
most modern Unix-like systems:

@example
#!/usr/bin/env kawa
(format #t "The time is ~s~%" (make <java.util.Date>))
@end example

If you need to specify extra arguments to @code{kawa},
you can use the following trick:
@example
#!/bin/sh
exec kawa --commonlisp out:base=16 --script2 "$0" "$@@"
(setq xx 20) (display xx) (newline)
@end example
This causes the shell to invoke the @code{kawa} program.
This assumes @code{kawa} is in the command path;
if not replace @code{kawa} by the appropriate incantation,
which can be multiple words (for example @code{java kawa.repl}).
The @code{exec} tells the shell to @emph{replace} itself by @var{kawa};
this is important so the shell doesn't continue with this file
when done with @code{kawa}.
The rest of the line can contain whatever commands and options you
want when executing Kawa.  The important part is @code{--script2 "$0"}.
The shell replaces the @code{"$0"} by the name the script, and
replaces the @code{"$@@"} by the remaining arguments passed to the script.
So what Kawa sees is the @code{--script2} option followed the script name,
followed by remaining command-line arguments.
The @code{--script2} tells Kawa to execute the script, after ignoring
the initial two lines, which would confuse it terribly.

@node New-Window, Exiting, Scripts, Running
@section Running a Command Interpreter in a new Window

An alternative interface runs the Java read-eval-print-loop
inside a new window. This is in some ways nicer.  One reason
is that it provides better editing.
(Mouse selection, arrow keys, and ``standard'' control keys should all work.)

You can also create new windows.  They can either have different top-level
environments or they can share environments.  To try it, do:
@example
java kawa.repl -w
@end example

@node Exiting,  , New-Window, Running
@section Exiting Kawa
Kawa normally keeps running as long as there is an active
read-eval-print loop still awaiting input or there is an unfinished
other computation (such as requested by a @samp{-e} of @samp{-f} option).

To close a read-eval-print-loop, you can type the special
literal @code{#!eof} at top level.  This is recognized as end-of-file.
Unfortunately, due to thread-related complications, just typing
an end-of-file character (normally ctrl/D until Unix), will not work.

If the read-eval-print-loop
is in a new window, you can select @samp{Close} from the @samp{File} menu.

To exit the entire Kawa session, call the
@code{exit} procedure (with 0 or 1 integer arguments).

@node Compiling, , , Running
@section Compiling to byte-code or an executable

All Scheme functions and source files are invisibly compiled
into internal Java byte-codes.
(A traditional interpreter is used for macro-expansion.
Kawa used to also interpret ``simple'' expressions in interactive mode,
but always compiling makes things more consistent, and allows for
better stack traces on errors.)

To save speed when loading large Scheme source files, you probably
want to pre-compile them and save them on your local disk.
There are two ways to do this.

You can compile a Scheme source file to a single archive file.
You do this using the @code{compile-file} function.
The result is a single file that you can move around and @code{load}
just like the @code{.scm} source file.  You just specify the name
of the archive file to the @code{load} procedure.
Currently, the archive is a "zip" archive and has extension ".zip";
a future release will probably use "Java Archive" (jar) files.
The advantage of compiling to an archive is that it is simple
and transparent.  A minor disadvantage is that it causes the
Java "verifier" to be run when functions are loaded from it,
which takes a little extra time.

Alternatively, you can compile a Scheme source file to a
collection of @samp{.class} files.
You then use the standard Java class loading mechanism to load the code.
The Java "verifier" does not need to get run, which makes
loading a little faster.
The compiled class files do have to be installed somewhere
in the @code{CLASSPATH}.

You can also compile your Scheme program to native code using GCJ.

@menu
* Archive compilation::         Compiling to an archive file
* Files compilation::           Compiling to a set of .class files
* Compilation options::
* Compiling using Ant::
* Application compilation::     Compiling to a standalone application
* Applet compilation::          Compiling to an applet
* Compiling to executable::     Compiling to a native executable
@end menu

@node Archive compilation, Files compilation, Compiling, Compiling
@subsection Compiling to an archive file

@deffn Procedure compile-file source-file compiled-archive
Compile the @var{source-file}, producing a @code{.zip} archive
@var{compiled-file}.


For example, to byte-compile a file @samp{foo.scm} do:
@example
(compile-file "foo.scm" "foo")
@end example

This will create @samp{foo.zip}, which contains
byte-compiled JVM @code{.class} files.
You can move this file around, without worrying about class paths.
To load the compiled file, you can later @code{load} the
named file, as in either @code{(load "foo")} or @code{(load "foo.zip")}.
This should have the same effect as
loading @samp{foo.scm}, except you will get the faster byte-compiled versions.
@end deffn

@node Files compilation
@subsection Compiling to a set of .class files

Invoking @samp{kawa} (or @samp{java kawa.repl}) with
the @samp{-C} flag will compile
a @samp{.scm} source file into one or more @samp{.class} files:
@example
kawa --main -C myprog.scm
@end example

You run it as follows:
@example
kawa [-d @var{outdirectory}] [-P @var{prefix}] [-T @var{topname}] [--main | --applet | --servlet] -C @var{infile} ...
@end example

Note the @samp{-C} must come last, because @samp{Kawa} processes the
arguments and options in order,

Here:
@table @code
@item -C @var{infile} ...
The Scheme source files we want to compile.
@item -d @var{outdirectory}
The directory under which the resulting @samp{.class} files will be.
The default is the current directory.
@item -P @var{prefix}
A string to prepend to the generated class names.
The default is the empty string.
@item -T @var{topname}
The name of the "top" class - i.e. the one that contains the code
for the top-level expressions and definitions.
The default is generated from the @var{infile} and @var{prefix}.
@item --main
Generate a @code{main} method so that the resulting "top" class can
be used as a stand-alone application. @xref{Application compilation}.
@item --applet
The resulting class inherits from @code{java.applet.Applet},
and can be used as an applet.  @xref{Applet compilation}.
@item --servlet
The resulting class implements @code{javax.servlet.http.HttpServlet},
and can be used as an servlet in a servlet container like Tomcat.
@end table

When you actually want to load the classes, the @var{outdirectory}
must be in your @samp{CLASSPATH}.
You can use the standard @code{load} function to load the code,
by specifying the top-level class, either as a file name
(relative to @var{outdirectory}) or a class name.
E.g. if you did:
@example
kawa -d /usr/local/share/java -P my.lib. -T foo -C foosrc.scm
@end example
you can use either:
@example
(load "my.lib.foo")
@end example
or:
@example
(load "my/lib/foo.class")
@end example

If you are compiling a Scheme source file (say @samp{foosrc.scm})
that uses macros defined in some other file (say @samp{macs.scm}),
you need to make sure the definitions are visible to the compiler.
One way to do that is with the @samp{-f}:
@example
kawa -f macs.scm -C foosrc.scm
@end example

@node Compilation options
@subsection Compilation options

Various named option control how Kawa compiles certain forms.

@table @code
@item --module-static
If no @code{module-static} is specified, generate a static module
(as if @code{(module-static #t)} were specified). @xref{Module classes}.
This is (now) the default.
@item --module-nonstatic
@itemx --no-module-static
If no @code{module-static} is specified, generate a non-static module
(as if @code{(module-static #f)} were specified). @xref{Module classes}.
This used to be the default.
@item --module-static-run
If no @code{module-static} is specified, generate a static module
(as if @code{(module-static 'init-run)} were specified). @xref{Module classes}.
@cindex --warn-@var{whatever}
@cindex --no-warn-@var{whatever}
@pindex warn-unknown-member
@item --warn-unknown-member
Emit a warning if the code references a named member (field or method)
for which there is no match in the compile-time type of the receiver.
This defaults to on;
to turn it off use the @code{--no-warn-unknown-member} flag.
@pindex warn-invoke-unknown-method
@item --warn-invoke-unknown-method
Emit a warning if the @code{invoke} function calls a named method
for which there is no matching method in the compile-time type of the receiver.
This defaults to the value of @code{--warn-unknown-member},
to turn it off use the @code{--no-warn-invoke-unknown-method} flag.
@pindex warn-undefined-variable
@item --warn-undefined-variable
Emit a warning if the code references a variable which is neither in
lexical scope nor in the compile-time dynamic (global) environment.
This is useful for catching typos.
(A @code{define-variable} form can be used to silence warnings.
It declares to the compiler that a variable is to be resolved dynamically.)
@pindex warn-as-error
@item --warn-as-error
Treat a compilation warning as if it were an error and halt compilation.
@end table

An option can be followed by a value, as
in @code{--warn-invoke-unknown-method=no}.
For boolean options, the values @code{yes}, @code{true}, @code{on}, or @code{1}
enable the option, while @code{no}, @code{false}, @code{off},
or @code{0} disable it.
You can also negate an option by prefixing it with @code{no-}:
The option @code{--no-warn-unknown-member}
is the same as @code{--warn-unknown-member=no}.

You can set the same options within your Scheme source file.
(In that case they override the options on the command line.)

@deffn Syntax module-compile-options [key: value] ...
This sets the value of the @code{key} option to @code{value}
for the current module (source file).  It takes effect as
soon it is seen during the first macro-expansion pass,
and is active thereafter (unless overridden by @code{with-compile-options}).

The @var{key} is one of the above option names.
(The following colon make it a Kawa keyword.)
The @var{value} must be a literal value: either a boolean
(@code{#t} or @code{#f}), a number, or a string,
depending on the @var{key}.
(All the options so far are boolean options.)

@example
(module-compile-options warn-undefined-variable: #t)
;; This causes a warning message that y is unknown.
(define (func x) (list x y))
@end example
@end deffn

@deffn Syntax with-compile-options [key: value] ... body
Similar to @code{module-compile-options}, but the option
is only active within @var{body}.
@example
(define (func x)
  (with-compile-options warn-invoke-unknown-method: #f
    (invoke x 'size)))
@end example
@end deffn

@node Compiling using Ant
@subsection Compiling using Ant

Many Java projects use @uref{http://ant.apache.org, Ant}
for building Java projects.  Kawa includes a @code{<kawac>}
Ant ask that simplifies compiling Kawa sources files to classes.
See the @code{build.xml} in the Kawa source distribution for examples.
See the @uref{ant-kawac.html, @code{kawac} task documentation} for details.

@node Application compilation
@subsection Compiling to a standalone application

A Java application is a Java class with a special method
(whose name is @code{main}).  The application can be invoked directly
by naming it in the Java command.
If you want to generate an application from a Scheme program,
create a Scheme source file with the definitions you need, plus
the top-level actions that you want the application to execute.
You can compile in the regular way decribed in the previous section, but add
the @code{--main} option.  For example,
assuming your Scheme file is @code{MyProgram.scm}:
@example
kawa --main -C MyProgram.scm
@end example
This will create a @code{MyProgram.class} which you can either @code{load}
(as decribed in the previous section), or invoke as an application:
@example
java MyProgram [@var{args}]
@end example
Your Scheme program can access the command-line arguments @var{args}
by using the global variable @samp{command-line-arguments},
or the R6RS function @samp{command-line}.

If there is no explicit @code{module-export} in a module compiled
with @code{--main} then no names are exported.  (The default
otherwise is for all names to be exported.)

@node Applet compilation, Compiling to executable, Application compilation, Compiling
@subsection Compiling to an applet
An applet is a Java class that inherits from @code{java.applet.Applet}.
The applet can be downloaded and run in a Java-capable web-browser.
To generate an applet from a Scheme program, write the Scheme
program with appropriate definitions of the functions @samp{init},
@samp{start}, @samp{stop} and @samp{destroy}.  You must declare these
as zero-argument functions with a @code{<void>} return-type.

Here is an example, based on the scribble applet in Flanagan's
"Java Examples in a Nutshell" (O'Reilly, 1997):
@example
(define-private last-x 0)
(define-private last-y 0)

(define (init) :: void
  (let ((applet (this)))
    (applet:addMouseListener
     (object (java.awt.event.MouseAdapter)
	     ((mousePressed e)
	      (set! last-x (e:getX))
	      (set! last-y (e:getY)))))
    (applet:addMouseMotionListener
     (object (java.awt.event.MouseMotionAdapter)
	     ((mouseDragged e)
	      (let ((g (applet:getGraphics))
		    (x (e:getX))
		    (y (e:getY)))
		(g:drawLine last-x last-y x y)
		(set! last-x x)
		(set! last-y y)))))))

(define (start) :: void (format #t "called start.~%~!"))
(define (stop) :: void (format #t "called stop.~%~!"))
(define (destroy) :: void (format #t "called destroy.~%~!"))
@end example

You compile the program with the @samp{--applet} flag in addition to the
normal @samp{-C} flag:
@example
java kawa.repl --applet -C scribble.scm
@end example

You can then create a @samp{.jar} archive containing your applet:
@example
jar cf scribble.jar scribble*.class
@end example

Finally, you create an @samp{.html} page referencing your applet
and its support @code{jar}s:
@example
<html><head><title>Scribble testapp</title></head>
<body><h1>Scribble testapp</h1>
You can scribble here:
<br>
<applet code="scribble.class" archive="scribble.jar, kawa-@value{VERSION}.jar" width=200 height=200>
Sorry, Java is needed.</applet>
</body></html>
@end example

The problem with using Kawa to write applets is that the Kawa @code{.jar}
file is quite big, and may take a while to download over a network connection.
Some possible solutions:

@itemize
@item
Try to strip out of the Kawa @code{.jar} any classes your
applet doesn't need.
@item
Java 2 provides a mechanism to install a @uref{http://java.sun.com/docs/books/tutorial/ext/basics/download.html,
download extension}.
@item
Consider some alternative to applets, such as
@uref{http://java.sun.com/products/javawebstart/,Java Web Start}.
@end itemize

@node Compiling to executable, , Applet compilation, Compiling
@subsection Compiling to a native executable

You can compile your Scheme program to native code using GCJ,
as long as you have built Kawa using GCJ.

First, you need to compile the Scheme code to a set of @code{.class} files;
see @ref{Files compilation}.
@example
kawa --main -C myprog.scm
@end example

Then to create an executable @code{myprog} do:
@example
gckawa --main=myprog myprog*.class -o myprog
@end example

The @code{gckawa} is a simple shell script that calls @code{gcj}.
The reason for the wildcard in @code{myprog*.class} is that sometimes
Kawa will generate some helper classes in addition to @code{myprog.class}.
The @code{--main} option tell @code{gcj} which class contains
the @code{main} method it should use.  The @code{-o} option names
the resulting executable program.  The @code{-lkawa} option tells
the linker it should link with the kawa shared library, and
the @code{-L$PREFIX/bin} option tells the linker where it can
find that library.

@node Features, Syntax, Running, Top
@chapter Summary of Kawa Scheme Features

This manual mostly documents how Kawa Scheme differs from
standard (R5RS) Scheme, though the goal is to merge in
information about standard Scheme here as well.

Kawa is a full Scheme implementation.  It implements almost
all of R5RS (for exceptions @pxref{Restrictions}), plus some extensions.
By default, symbols are case sensitive.

It is completely written in Java.  Scheme functions and files
are automatically compiled into Java byte-codes.  Kawa does some
optimizations, and the compiled code runs at reasonable speed.

Kawa uses Unicode internally, and uses the Java facilities to convert
files using other character encodings.

Kawa provides the usual read-eval-print loop, as well as batch modes.

Kawa provides a framework for implementing other progressing languages,
and comes with incomplete support for CommonLisp, Emacs Lisp, and
EcmaScript, and the
draft @uref{http://www.gnu.org/software/qexo/,XML Query language}.

Kawa is written in an object-oriented style.

Kawa has builtin pretty-printer support, and fancy formatting.

Kawa supports class-definition facilities, and separately-compiled modules.

Kawa implements the full numeric tower, including infinite-precision
rational numbers and complex numbers.  It also supports "quantities"
with units, such as @code{3cm}.

You can optionally declare the types of variables.

You can conveniently access Java objects, methods, fields, and classes.

Kawa implements most of the features of the expression language of DSSSL,
the Scheme-derived ISO-standard Document Style Semantics and Specification
Language for SGML.  Of the core expression language, the only features
missing are character properties, @code{external-procedure},
the time-relationed procedures, and character name escapes in
string literals.  Also, Kawa is not generally tail-recursive.
From the full expression language, Kawa additionally is missing
@code{format-number}, @code{format-number-list}, and language objects.
Quantities, keyword values, and the expanded @code{lambda} form
(with optional and keyword parameters) are supported.

@menu
* Implemented SRFIs::
* Restrictions::
@end menu

@node Implemented SRFIs, Restrictions, , Features
@section Implemented SRFIs

Kawa implements the following semi-standard SRFIs
(@uref{http://srfi.schemers.org/,Scheme Request for Implementation}):
@itemize
@item
@uref{http://srfi.schemers.org/srfi-0/srfi-0.html, SRFI 0}: Feature-based conditional expansion construct,
using @code{cond-expand} - @pxref{Syntax and conditional compilation}.
@item
@uref{http://srfi.schemers.org/srfi-1/srfi-1.html, SRFI 1}: List Library, if @code{(require 'list-lib)}.
@item
@uref{http://srfi.schemers.org/srfi-2/srfi-2.html, SRFI 2}: AND-LET*: an AND with local bindings, a guarded LET* special form.
@item
@uref{http://srfi.schemers.org/srfi-4/srfi-4.html, SRFI 4}: Homogeneous numeric vector datatypes - @pxref{Uniform vectors}.
@item
@uref{http://srfi.schemers.org/srfi-6/srfi-6.html, SRFI 6}: Basic String Ports - @pxref{Ports}.
@item
@uref{http://srfi.schemers.org/srfi-8/srfi-8.html, SRFI 8}: @code{receive}: Binding to multiple values - @pxref{Multiple values}.
@item
@uref{http://srfi.schemers.org/srfi-9/srfi-9.html, SRFI 9}: Defining Record Types, using @code{define-record-type}
- @pxref{Record types}.
@item
@uref{http://srfi.schemers.org/srfi-11/srfi-11.html, SRFI 11}: Syntax for receiving multiple values,
using @code{let-values} and @code{let*-value} - @pxref{Multiple values}.
@item
@uref{http://srfi.schemers.org/srfi-13/srfi-13.html, SRFI 13}: String Library.
Needs some polishing.
@item
@uref{http://srfi.schemers.org/srfi-14/srfi-14.html, SRFI 14}: Character-set Library.
@item
@uref{http://srfi.schemers.org/srfi-16/srfi-16.html, SRFI 16}: Syntax for procedures of variable arity,
using @uref{http://srfi.schemers.org/srfi-16/srfi-16.html, @code{case-lambda}}.
@item
@uref{http://srfi.schemers.org/srfi-17/srfi-17.html, SRFI 17}: Generalized @code{set!} - @pxref{Locations}.
@item
@uref{http://srfi.schemers.org/srfi-23/srfi-23.html, SRFI 23}: Error reporting mechanism, using @code{error} - @pxref{Exceptions}.
@item
@uref{http://srfi.schemers.org/srfi-25/srfi-25.html, SRFI 25}: Multi-dimensional Array Primitives - @pxref{Arrays}.
@item
@uref{http://srfi.schemers.org/srfi-26/srfi-26.html, SRFI 26}: Notation for Specializing Parameters without Currying - @pxref{Procedures}. 
@item
@uref{http://srfi.schemers.org/srfi-28/srfi-28.html, SRFI 28}: Basic Format Strings - @pxref{Format}.
@item
@uref{http://srfi.schemers.org/srfi-30/srfi-30.html, SRFI 30}: Nested Multi-line Comments.
@item
@uref{http://srfi.schemers.org/srfi-37/srfi-37.html, SRFI 37}: @uref{http://srfi.schemers.org/srfi-37/srfi-37.html,@code{args-fold} - a program argument processor}, if @code{(require 'args-fold)}.
@item
@uref{http://srfi.schemers.org/srfi-39/srfi-39.html, SRFI 39}:
@xref{Parameter objects}.
@item
@uref{http://srfi.schemers.org/srfi-41/srfi-41.html, SRFI 41}: Streams.
@item
@uref{http://srfi.schemers.org/srfi-62/srfi-62.html, SRFI 62}: S-expression comments.
@item
@uref{http://srfi.schemers.org/srfi-64/srfi-64.html, SRFI 64}: A Scheme API for test suites.
@item
@uref{http://srfi.schemers.org/srfi-69/srfi-69.html, SRFI 69}: Basic hash tables - @pxref{Hash tables}.
@item
@uref{http://srfi.schemers.org/srfi-88/srfi-88.html, SRFI 88}: Keyword objects - @pxref{Keywords}.
@item
@uref{http://srfi.schemers.org/srfi-95/srfi-95.html, SRFI 95}: Sorting and Merging.
@item
@uref{http://srfi.schemers.org/srfi-97/srfi-97.html, SRFI 97}: Names for SRFI Libraries.
@end itemize

@node Restrictions, , Implemented SRFIs, Features
@section Features of R5RS not implemented

Kawa implements all the required and optional features of R5RS,
with the following exceptions.

The entire "numeric tower" is implemented.
However, some transcendental function only work on reals.
Integral function do not necessarily work on
inexact (floating-point) integers.
(The whole idea of "inexact integer" in R5RS seems rather pointless ...)

Also, @code{call-with-current-continuation} is only "upwards" (?).
I.e. once a continuation has been exited, it cannot be invoked.
These restricted continuations can be used to implement catch/throw
(such as the examples in R4RS), but not co-routines or backtracking.

Kawa now does general tail-call elimination, but only if
you use the flag @code{--full-tail-calls}.  (Currently, the
@code{eval} function itself is not fully tail-recursive, in violation
of R5RS.)   The @code{--full-tail-calls} flag is not on by default,
partly because it is noticably slower (though I have not measured how
much), and partly I think it is more useful for Kawa to be compilatible
with standard Java calling conventions and tools.
Code compiled with @code{--full-tail-calls} can call code
 compiled without it and vice versa.

Even without @code{--full-tail-calls}, if the
compiler can prove that the procedure being called is the current
function, then the tail call will be replaced by a jump.
This means the procedure must be defined using a letrec, not a
define (because the compiler does not know if someone might
re-define a global definition), and there must be no assignments
(using @code{set!}) to the procedure binding.

@node Syntax, Multiple values, Features, Top
@chapter Syntax

@menu
* Syntax notation::
* Lexical and datum syntax::
* Lexical syntax::
* Datum syntax::
* Hash-prefixed forms::
* Primitive expression syntax::
* Colon notation:: Property access using colon notation
* Bodies::
* Syntax and conditional compilation::
@end menu

@node Syntax notation, Lexical and datum syntax, , Syntax
@section Notation

The formal syntax for Kawa Scheme is written in an extended @acronym{BNF}.
Non--terminals are written @var{like-this}.  Case is insignificant
for non--terminal names.
Literal text (terminals) are written @stxlit{like this}.

All spaces in the grammar are for legibility.
@c  @meta{Empty} stands for the empty string.

The following extensions to @acronym{BNF} are used to make the
description more concise: @arbno{@meta{thing}} or @meta{thing}@code{...}
both mean zero or more occurrences of @meta{thing},
and @atleastone{@meta{thing}} means at least one @meta{thing}.

Some non-terminal names refer to the Unicode scalar values of the same
name: @meta{character-tabulation} (U+0009), @meta{linefeed} (U+000A),
@meta{carriage-return} (U+000D), @meta{line-tabulation} (U+000B),
@meta{form-feed} (U+000C), @meta{space} (U+0020), @meta{next-line}
(U+0085), @meta{line-separator} (U+2028), and @meta{paragraph-separator}
(U+2029).

@node Lexical and datum syntax, Lexical syntax, Syntax notation, Syntax
@section Lexical and datum syntax

The syntax of Scheme code is organized in three levels:

@enumerate
@item
the @emph{lexical syntax} that describes how a program text is split
into a sequence of lexemes,

@item
the @emph{datum syntax}, formulated in terms of the lexical syntax, that
structures the lexeme sequence as a sequence of @emph{syntactic data},
where a syntactic datum is a recursively structured entity,

@item
the @emph{program syntax} formulated in terms of the datum syntax,
imposing further structure and assigning meaning to syntactic data.
@end enumerate

Syntactic data (also called @emph{external representations}) double as a
notation for objects, and the @func{read} and
@func{write} procedures can be used for reading and writing syntactic data,
converting between their textual representation and the corresponding
objects.  Each syntactic datum represents a corresponding
@emph{datum value}.  A syntactic datum can be used in a program to obtain the
corresponding datum value using @code{quote}.
@c FIXME (@ref{base expressions quotation}).

Scheme source code consists of syntactic data and (non--significant)
comments.  Syntactic data in Scheme source code are called @emph{forms}.
(A form nested inside another form is called a @emph{subform}.)
Consequently, Scheme's syntax has the property that any sequence of
characters that is a form is also a syntactic datum representing some
object.  This can lead to confusion, since it may not be obvious out of
context whether a given sequence of characters is intended to be a
representation of objects or the text of a program.  It is also a source
of power, since it facilitates writing programs such as interpreters or
compilers that treat programs as objects (or vice versa).

A datum value may have several different external representations.  For
example, both @code{#e28.000} and @code{#x1c} are syntactic data
representing the exact integer object 28, and the syntactic data
@code{(8 13)}, @code{( 08 13 )}, @code{(8 . (13 . ()))} all represent a
list containing the exact integer objects 8 and 13.  Syntactic data that
represent equal objects (in the sense of @func{equal?})
are always equivalent as forms of a program.

Because of the close correspondence between syntactic data and datum
values, we sometimes uses the term @emph{datum} for either a
syntactic datum or a datum value when the exact meaning is apparent from
the context.

@c An implementation must not extend the lexical or datum syntax in any
@c way, with one exception: it need not treat the syntax
@c @code{#!<identifier>}, for any <identifier> (@ref{lex syntax
@c identifiers}) that is not @code{r6rs}, as a syntax violation, and it may
@c use specific @code{#!}--prefixed identifiers as flags indicating that
@c subsequent input contains extensions to the standard lexical or datum
@c syntax.  The syntax @code{#!r6rs} may be used to signify that the input
@c afterward is written with the lexical syntax and datum syntax described
@c by this report.  @code{#!r6rs} is otherwise treated as a comment;
@c @ref{lex syntax whitespace and comments}.

@node Lexical syntax, Datum syntax, Lexical and datum syntax, Syntax
@section Lexical syntax

The lexical syntax determines how a character sequence is split into a
sequence of lexemes, omitting non--significant portions such as comments
and whitespace.  The character sequence is assumed to be text according
to the @uref{http://unicode.org/,Unicode standard}.
Some of the lexemes, such as
identifiers, representations of number objects, strings etc., of the
lexical syntax are syntactic data in the datum syntax, and thus
represent objects.  Besides the formal account of the syntax, this
section also describes what datum values are represented by these
syntactic data.

The lexical syntax, in the description of comments, contains a forward
reference to @meta{datum}, which is described as part of the datum
syntax.  Being comments, however, these @meta{datum}s do not play a
significant role in the syntax.

Case is significant except in representations of booleans, number
objects, and in hexadecimal numbers specifying Unicode scalar values.
For example, @code{#x1A} and @code{#X1a} are equivalent.  The identifier
@code{Foo} is, however, distinct from the identifier @code{FOO}.

@subsection Formal account

@noindent
@var{Interlexeme-space} may occur on either side of any lexeme, but not
within a lexeme.

@meta{Identifier}s, @code{.}, @meta{number}s, @meta{character}s, and
@meta{boolean}s, must be terminated by a @meta{delimiter} or by the end
of the input.

@c The following two characters are reserved for future extensions to the
@c language: @code{@{ @}}

@display
@stxdef{lexeme} @stxref{identifier} | @var{boolean} | @var{number}
         | @var{character} | @var{string}
         | @stxlit{(} |  @stxlit{)} |  @stxlit{[} |  @stxlit{]} |  @stxlit{#(}
@c | #vu8( |
         | @stxlit{'} | @stxlit{`} | @stxlit{,} | @stxlit{,@@} | @stxlit{.}
         | @stxlit{#'} |  @stxlit{#`} |  @stxlit{#,} |  @stxlit{#,@@}
@stxdef{delimiter} @stxlit{(} |  @stxlit{)} |  @stxlit{[} | @stxlit{]} | @stxlit{"} | @stxlit{}; | @stxlit{#}
         | @stxref{whitespace}
@end display

((UNFINISHED))

@subsection Line endings

Line endings are significant in Scheme in single--line comments
and within string literals.
In Scheme source code, any of the line endings in @meta{line-ending}
marks the end of a line.  Moreover, the two--character line endings
@meta{carriage-return} @meta{linefeed} and @meta{carriage-return}
@meta{next-line} each count as a single line ending.

In a string literal, a @meta{line-ending} not preceded by a @code{\}
stands for a linefeed character, which is the standard line--ending
character of Scheme.

@subsection Whitespace and comments

@display
@stxdef{whitespace} @var{character-tabulation}
         | @var{linefeed} | @var{line-tabulation} | @var{form-feed}
         | @var{carriage-return} | @var{next-line}
         | @i{any character whose category is Zs, Zl, or Zp}
@stxdef{line ending} @var{linefeed} | @var{carriage return}
         | @var{carriage-return} @var{linefeed} | @var{next-line}
         | @var{carriage-return} @var{next-line} | @var{line-separator}
@stxdef{comment}  @stxlit{;} all subsequent characters up to a @var{line-ending}
                or @var{paragraph-separator}
         | @stxref{nested-comment}
         | @stxlit{#;} @stxref{interlexeme-space} @stxref{datum}
@stxdef{nested-comment}  @stxlit{#|} @stxref{comment-text} @stxref{comment-cont}* @stxlit{|#}
@stxdef{comment-text} character sequence not containing @stxlit{#|} or @stxlit{|#}
@stxdef{comment-cont} @stxref{nested-comment} @stxref{comment-text}
@stxdef{atmosphere} @stxref{whitespace} | @stxref{comment}
@stxdef{interlexeme-space} @var{atmosphere}*
@end display

@noindent
@emph{Whitespace} characters are spaces, linefeeds, carriage returns,
character tabulations, form feeds, line tabulations, and any other
character whose category is Zs, Zl, or Zp.  Whitespace is used for
improved readability and as necessary to separate lexemes from each
other.  Whitespace may occur between any two lexemes, but not within a
lexeme.  Whitespace may also occur inside a string, where it is
significant.

The lexical syntax includes several comment forms.  In all cases,
comments are invisible to Scheme, except that they act as delimiters,
so, for example, a comment cannot appear in the middle of an identifier
or representation of a number object.

A semicolon (@code{;}) indicates the start of a line comment.  The
comment continues to the end of the line on which the semicolon appears.

Another way to indicate a comment is to prefix a @stxref{datum}
with @code{#;}, possibly with
@meta{interlexeme-space} before the @meta{datum}.  The comment consists
of the comment prefix @code{#;} and the @meta{datum} together.  This
notation is useful for ``commenting out'' sections of code.

Block comments may be indicated with properly nested @code{#|} and
@code{|#} pairs.
@example
#|
   The FACT procedure computes the factorial of a
   non-negative integer.
|#
(define fact
  (lambda (n)
    ;; base case
    (if (= n 0)
        #;(= n 1)
        1       ; identity of *
        (* n (fact (- n 1))))))
@end example

@c The lexeme @code{#!r6rs}, which signifies that the program text that
@c follows is written with the lexical and datum syntax described in this
@c report, is also otherwise treated as a comment.

@subsection Identifiers

@display
@stxdef{identifier} @stxref{initial} @stxref{subsequent}*
         | @stxref{peculiar-identifier}
@stxdef{initial} @stxref{constituent} | @stxref{special-initial}
         | @stxref{inline-hex-escape}
@stxdef{letter} @stxlit{a} | @stxlit{b} | @stxlit{c} | ... | @stxlit{z}
         | @stxlit{A} | @stxlit{B} | @stxlit{C} | ... | @stxlit{Z}
@stxdef{constituent} @stxref{letter}
         | @i{any character whose Unicode scalar value is greater than
             127, and whose category is Lu, Ll, Lt, Lm, Lo, Mn,
             Nl, No, Pd, Pc, Po, Sc, Sm, Sk, So, or Co}
@stxdef{special-initial} @stxlit{!} | @stxlit{$} | @stxlit{%} | @stxlit{&} | @stxlit{*} | @stxlit{/} | @stxlit{<} | @stxlit{=}
         | @stxlit{>} | @stxlit{?} | @stxlit{^} | @stxlit{_} | @stxlit{~}
@stxdef{subsequent} @stxref{initial} | @stxref{digit}
         | @i{any character whose category is Nd, Mc, or Me}
         | @stxref{special-subsequent}
@stxdef{digit} @stxlit{0} | @stxlit{1} | @stxlit{2} | @stxlit{3} | @stxlit{4} | @stxlit{5} | @stxlit{6} | @stxlit{7} | @stxlit{8} | @stxlit{9}
@stxdef{hex-digit} @stxref{digit}
         | @stxlit{a} | @stxlit{A} | @stxlit{b} | @stxlit{B} | @stxlit{c} | @stxlit{C} | @stxlit{d} | @stxlit{D} | @stxlit{e} | @stxlit{E} | @stxlit{f} | @stxlit{F}
@stxdef{special-subsequent} @stxlit{+} | @stxlit{-} | @stxlit{.} | @stxlit{@@}
@stxdef{escape-sequence} @stxref{inline-hex-escape}
         | @stxlit{\\}@stxref{character-except-x}
         | @stxref{multi-escape-sequence}
@stxdef{inline-hex-escape} @stxlit{\\x}@stxref{hex-scalar-value}@stxlit{;}
@stxdef{hex-scalar-value} @stxref{hex-digit}+
@stxdef{multi-escape-sequence} @stxlit{|}@stxref{character-except-vbar}...@stxlit{|}
@stxdef{character-except-vbar} @i{any character except @code{|}}
@stxdef{character-except-x} @i{any character except @code{x}}
@stxdef{peculiar-identifier} @stxlit{+} | @stxlit{-} | @stxlit{...} | @stxlit{->} @var{subsequent}*
@end display

Most identifiers allowed by other programming languages are also
acceptable to Scheme.  In general, a sequence of letters, digits, and
``extended alphabetic characters'' is an identifier when it begins with
a character that cannot begin a representation of a number object.  In
addition, @code{+}, @code{-}, and @code{...} are identifiers, as is a
sequence of letters, digits, and extended alphabetic characters that
begins with the two--character sequence @code{->}.  Here are some
examples of identifiers:

@example
lambda         q                soup
list->vector   +                V17a
<=             a34kTMNs         ->-
the-word-recursion-has-many-meanings
@end example

Extended alphabetic characters may be used within identifiers as if they
were letters.  The following are extended alphabetic characters:

@example
! $ % & * + - . / < = > ? @@ ^ _ ~
@end example

Moreover, all characters whose Unicode scalar values are greater than
127 and whose Unicode category is Lu, Ll, Lt, Lm, Lo, Mn, Mc, Me, Nd,
Nl, No, Pd, Pc, Po, Sc, Sm, Sk, So, or Co can be used within
identifiers.  In addition, any character can be used within an
identifier when specified using an @meta{escape-sequence}.  For example,
the identifier @code{H\x65;llo} is the same as the identifier
@code{Hello}.

Kawa supports two additional non-R6RS ways of making
identifiers using special characters, both taken from Common Lisp:
Any character (except @code{x}) following a backslash is treated
as if it were a @var{letter};
as is any character between a pair of vertical bars.

@c , and the identifier @code{\x3BB;} is the same as the
@c identifier $\lambda$.

Any identifier may be used as a variable or as a syntactic keyword
@c (@ref{basic variables keywords regions} and @ref{syntax macros})
in a Scheme program.  Any identifier may also be used as a syntactic datum,
in which case it represents a @emph{symbol}.
@c (@ref{base symbols}).

Note that colon @code{:} is treated specially for the
``colon operator'' (FIXME NEEDS DOCUMENTATION) in Kawa Scheme,
though it is @var{special-initial} in standard Scheme (R6RS).

@node Datum syntax, Hash-prefixed forms, Lexical syntax, Syntax
@section Datum syntax

The datum syntax describes the syntax of syntactic data in terms of a
sequence of @meta{lexeme}s, as defined in the lexical syntax.

The following grammar describes the syntax of syntactic data in terms of
various kinds of lexemes defined in the grammar in section ``Lexical
Syntax'':

@display
@stxdef{datum} @stxref{defining-datum}
         | @stxref{nondefining-datum}
         | @stxref{defined-datum}

@stxdef{defining-datum} @stxlit{#}@stxref{indexnum}@stxlit{=}@stxref{nondefining-datum}
@stxdef{defined-datum} @stxlit{#}@var{indexnum}@stxlit{#}
@stxdef{nondefining-datum} @stxref{lexeme-datum}
         | @stxref{compound-datum}
@stxdef{indexnum} @stxref{digit}+

@stxdef{lexeme-datum} @meta{boolean} | @meta{number}
         | @meta{character} | @meta{string} | @stxref{symbol}
@stxdef{symbol} @stxref{identifier}
@stxdef{compound-datum} @stxref{list} | @stxref{vector} | @stxref{uniform-vector} | @stxref{xml-literal}
@stxdef{list} @stxlit{(}@stxref{datum}*@stxlit{)}
         | @stxlit{(}@stxref{datum}+ @stxlit{.} @stxref{datum}@stxlit{)}
         | @stxref{abbreviation}
@stxdef{abbreviation} @stxref{abbrev-prefix} @stxref{datum}
@stxdef{abbrev-prefix} @stxlit{'} | @stxlit{`} | @stxlit{,} | @stxlit{,@@}
         | @stxlit{#'} | @stxlit{#`}
@stxdef{vector} @stxlit{#(}@stxref{datum}*@stxlit{)}
@stxdef{uniform-vector} TODO
@end display
@c FIXME: add to abbrev-prefix: @stxlit{#,} | @stxlit{#,@@}

@subsection Abbreviations

The following are abbreviations:

@table @asis
@item @stxlit{'}@meta{datum}     
for @code{(quote @meta{datum})},

@item @stxlit{`}@meta{datum}     
for @code{(quasiquote @meta{datum})},

@item @stxlit{,}@meta{datum}     
for @code{(unquote @meta{datum})},

@item @stxlit{,@@}@meta{datum}     
for @code{(unquote-splicing @meta{datum})},

@item @stxlit{#'}@meta{datum}     
for @code{(syntax @meta{datum})}, and

@item @stxlit{#`}@meta{datum}     
for @code{(quasisyntax @meta{datum})}.

@c FIXME
@c @item @stxlit{#,}@meta{datum}     
@c for @code{(unsyntax @meta{datum})}, and
@c @item @stxlit{#,@@}@meta{datum}
@c for @code{(unsyntax-splicing @meta{datum})}.
@end table


@node Hash-prefixed forms
@section Hash-prefixed forms

A number of different special forms are indicated by an
initial hash (number) symbols (@code{#}).
Here is a table summarizing them.

Case is ignored for the character followed the @code{#}.
Thus @code{#x} and @code{#X} are the same.

@table @asis
@item @stxlit{#:}@var{keyword}
Guile-style keyword syntax (deprecated).
@item @stxlit{#\\}
Character literals.
@item @stxlit{#!}
@xref{Special named constants}.
@item @stxlit{#`}@var{datum}
Equivalent to @code{(quasisyntax @var{datum})}.
Convenience syntax for syntax-case macros.
@item @stxlit{#'}@var{datum}
Equivalent to @code{(syntax @var{datum})}.
Convenience syntax for syntax-case macros.
@item @stxlit{#(}
A vector.
@item @stxlit{#|}
Start of nested-comment.
@item @stxlit{#/}@var{regex}@stxlit{/}
@xref{Regular expressions}.
@item @stxlit{#<}
@xref{XML literals}.
@item @stxlit{#;}@var{datum}
A datum comment - the @var{datum} is ignored.
(An @var{interlexeme-space} may appear before the @var{datum}.)
@item @stxlit{#,(}@var{name} @var{datum} ...@stxlit{)}
Special named constructors.
@item @stxlit{#}@var{number}@stxlit{=}@var{datum}
A reference definition, allowing cyclic and shared structure.
Equivalent to the @var{datum}, but also defines an association between
the integer @var{number} and that @var{datum}, which can be
used by a subsequent @code{#@var{number}#} form.
@item @stxlit{#}@var{number}@stxlit{#}
A back-reference, allowing cyclic and shared structure.
@item @stxlit{#b}
A binary (base-2) number.
@item @stxlit{#d}
A decimal (base-10) number.
@item @stxlit{#e}
A prefix to treat the following number as exact.
@item @stxlit{#f}
The standard boolean false object.
@item @stxlit{#f}@var{n}@stxlit{(}@var{number} ...@stxlit{)}
A uniform vector of floating-point numbers.
The parameter @var{n} is a precision, which can be 32 or 64.
@xref{Uniform vectors}.
@item @stxlit{#i}
A prefix to treat the following number as inexact.
@item @stxlit{#o}
An octal (base-8) number.
@item @stxlit{#}@var{base}@stxlit{r}
A number in the specified @var{base} (radix).
@item @stxlit{#s}@var{n}@stxlit{(}@var{number} ...@stxlit{)}
A uniform vector of signed integers.
The parameter @var{n} is a precision, which can be 8, 16, 32, or 64.
@xref{Uniform vectors}.
@item @stxlit{#t}
The standard boolean true object.
@item @stxlit{#u}@var{n}@stxlit{(}@var{number} ...@stxlit{)}
A uniform vector of unsigned integers.
The parameter @var{n} is a precision, which can be 8, 16, 32, or 64.
@xref{Uniform vectors}.
@item @stxlit{#x}
A hexadecimal (base-16) number.
@end table

The follow named constructor forms are supported:

@table @asis
@item @stxlit{#,(path} @var{path}@stxlit{)}
@item @stxlit{#,(filepath} @var{path}@stxlit{)}
@item @stxlit{#,(URI} @var{path}@stxlit{)}
@item @stxlit{#,(symbol} @var{local-name} [@var{uri} [@var{prefix}]]@stxlit{)}
@itemx @stxlit{#,(symbol} @var{local-name} @var{namespace}@stxlit{)}
@item @stxlit{#,(namespace} @var{uri} [@var{prefix}]@stxlit{)}
@item @stxlit{#,(duration} @var{duration}@stxlit{)}
@end table

@node Primitive expression syntax
@section Primitive expression syntax

@display
@stxdef{expression} @stxref{literal-value} | @stxref{variable-reference}
  | @stxref{procedure-call} | TODO
@end display

@subsection Constant literals

@display
@stxdef{literal-value} @var{number} | @meta{boolean} | @meta{character} | @meta{string}
@end display
An expression consisting of a representation of a number object, a
boolean, a character, or a string evaluates ``to itself''.

@example
145932          @result{}  145932
#t              @result{}  #t
"abc"           @result{}  "abc"
@end example
@c #vu8(2 24 123)  @result{} #vu8(2 24 123)

@subsection Variable references

@display
@stxdef{variable-reference} @stxref{identifier}
@end display
An expression consisting of a variable is a variable reference if it is
not a macro use (see below).  The value of the variable reference is the
value stored in the location to which the variable is bound.  It is a
syntax violation to reference an unbound variable.

The following example examples assumes the base library has been
imported:

@example
(define x 28)
x   @result{}  28
@end example

@subsection Procedure calls

@display
@stxdef{procedure-call} @stxlit{(}@stxref{operator} @stxref{operand} @dots{})
@stxdef{operator} @stxref{expression}
@stxdef{operand} @stxref{expression}
@end display

A procedure call consists of expressions for the procedure to be called
and the arguments to be passed to it, with enclosing parentheses.  A
form in an expression context is a procedure call if @meta{operator} is
not an identifier bound as a syntactic keyword.

When a procedure call is evaluated, the operator and operand expressions
are evaluated (in an unspecified order) and the resulting procedure is
passed the resulting arguments.

@example
(+ 3 4)                @result{}  7
((if #f + *) 3 4)      @result{}  12
@end example

@subsection Macros

Libraries and top--level programs can define and use new kinds of
derived expressions and definitions called @emph{syntactic abstractions}
or @emph{macros}.  A syntactic abstraction is created by binding a
keyword to a @emph{macro transformer} or, simply, @emph{transformer}.

The transformer determines how a use of the macro (called a @emph{macro
use}) is transcribed into a more primitive form.

Most macro uses have the form:

@example
(@meta{keyword} @meta{datum} @dots{})
@end example
@noindent
where @meta{keyword} is an identifier that uniquely determines the kind
of form.  This identifier is called the @emph{syntactic keyword}, or
simply @emph{keyword}.  The number of @meta{datum}s and the syntax of
each depends on the syntactic abstraction.

Macro uses can also take the form of improper lists, singleton
identifiers, or @func{set!} forms, where the second subform of the
@func{set!} is the keyword:

@example
(@meta{keyword} @meta{datum} @dots{} . @meta{datum})
@meta{keyword}
(set! @meta{keyword} @meta{datum})
@end example

The @func{define-syntax}, @func{let-syntax} and @func{letrec-syntax}
forms create bindings for keywords, associate them with macro
transformers, and control the scope within which they are visible.

The @func{syntax-rules} and @func{identifier-syntax} forms create
transformers via a pattern language.  Moreover, the @func{syntax-case}
form allows creating transformers via arbitrary Scheme code.

Keywords occupy the same name space as variables.  That is, within the
same scope, an identifier can be bound as a variable or keyword, or
neither, but not both, and local bindings of either kind may shadow
other bindings of either kind.

Macros defined using @func{syntax-rules} and @func{identifier-syntax}
are ``hygienic'' and ``referentially transparent'' and thus preserve
Scheme's lexical scoping.

@itemize
@item 
If a macro transformer inserts a binding for an identifier (variable or
keyword) not appearing in the macro use, the identifier is in effect
renamed throughout its scope to avoid conflicts with other identifiers.

@item 
If a macro transformer inserts a free reference to an identifier, the
reference refers to the binding that was visible where the transformer
was specified, regardless of any local bindings that may surround the
use of the macro.
@end itemize

Macros defined using the @func{syntax-case} facility are also hygienic
unless @func{datum->syntax} is used.

@node Colon notation
@section Property access using colon notation

The @dfn{colon notation} accesses named parts (properties) of a value.
It is used to get and set fields, call methods, construct compound symbols,
and more.
Evaluating the form @code{@var{owner}:@var{property}}
evaluates the @code{@var{owner}} then it extracts the named @code{@var{property}} of the result.

@display
@stxdef{property-access-abbreviation} @stxref{property-owner-expression}@stxlit{:}@stxref{property-name}
@stxdef{property-owner-expression} @stxref{expression}
@stxdef{property-name} @stxref{identifier} | @stxlit{,}@stxref{expression}
@end display

The @var{property-name} is usually a literal name,
but it can be an unquoted @var{expression} (i.e. following a @code{,}),
in which case the name is evaluated at run-time.
No separators are allowed on either side of the colon.

The input syntax @code{@var{exp}:@var{part}} is translated by
the Scheme reader to the internal representation @code{($lookup$ @var{exp} (quasiquote @var{part}))}.

@subsection Part lookup rules

Evaluation proceeds as follows.
First @var{property-owner-expression} is
evaluated to yield a @var{owner} object.
Evaluating the @var{property-name} yields a @var{part} name,
which is a symbol: Either
the literal @var{identifier}, or the result of evaluating the
property-name @var{expression}.
If the @var{expression} evaluates to a string, it is converted to
a simple symbol, as if using @code{string->symbol}.

@itemize
@item
If the @var{owner} implements @code{gnu.mappingHasNamedParts},
then the result is the same as @code{(invoke @var{owner} 'get @var{part})}.

As a special case of this rule, if @var{owner} is a
@code{gnu.mapping.Namespace}, then the result is the
@ref{Namespaces,compound symbol in that namespace}.
@item
If @var{owner} is a @code{java.lang.Class} or a @code{gnu.bytecode.ObjectType},
the result is the static member named @var{part}
(i.e. a static field, method, or member class).
@item
If @var{owner} is a @code{java.lang.Package} object, we get the member
class or sub-package named @var{part}.
@item
Otherwise, we look for a named member (instance member or field).

Note you can't use colon notation to invoke instance methods
of a @code{Class}, because it will match a previous rule.
@end itemize

If the colon form is on the left-hand-side of an assignment (@code{set!}),
then the named part is modified as appropriate.

@c We will look into examples and details below.
@c @subsection The @code{HasNamedParts} case
@c @subsection Static parts of classes and packages
@c @subsection Instance parts

@node Bodies
@section Bodies

The @meta{body} of a @func{lambda}, @func{let}, @func{let*},
@func{let-values}, @func{let*-values}, @func{letrec}, or @func{letrec*}
expression, or that of a definition with a body consists of zero or more
definitions or expressions followed by a final expression.
(Standard Scheme requires that all definitions precede all expressions.)

@example
@stxdef{body} @stxref{statement} ... @stxref{expression}
@stxdef{statement} @var{definition} | @stxref{expression}
@end example

Each identifier defined by a definition is local to the @meta{body}.
That is, the identifier is bound, and the region of the binding is the
entire @meta{body}.
Example:

@example
(let ((x 5))
  (define foo (lambda (y) (bar x y)))
  (define bar (lambda (a b) (+ (* a b) a)))
  (foo (+ x 3)))
@result{} 45
@end example

When @func{begin}, @func{let-syntax}, or @func{letrec-syntax} forms
occur in a body prior to the first expression, they are spliced into the
body.  Some or all of the body, including portions wrapped in
@func{begin}, @func{let-syntax}, or @func{letrec-syntax} forms, may be
specified by a macro use.

An expanded @meta{body} containing variable definitions can be
converted into an equivalent @func{letrec*} expression.
(If there is a definition following expressions you may need to
convert the expressions to dummy definitions.)     For example,
the @func{let} expression in the above example is equivalent to

@example
(let ((x 5))
  (letrec* ((foo (lambda (y) (bar x y)))
            (bar (lambda (a b) (+ (* a b) a))))
    (foo (+ x 3))))
@end example


@node Syntax and conditional compilation
@section Syntax and conditional compilation

Kawa supports most of the @code{syntax-case} feature.

@deffn Syntax define-syntax ..
Pattern ...
@end deffn

@deffn Syntax define-syntax-case name @stxlit{(}literals@stxlit{)} @stxlit{(}pattern expr@stxlit{)} ...
A convenience macro to make it easy to define @code{syntax-case}-style macros.
Defines a macros with the given @var{name} and list of @var{literals}.
Each @var{pattern} has the form of a @code{syntax-rules}-style pattern,
and it is matched against the macro invocation syntax form.
When a match is found, the corresponding @var{expr} is evaluated.
It must evaluate to a syntax form,
which replaces the macro invocation.
@end deffn

@deffn Syntax define-macro @stxlit{(}name lambda-list@stxlit{)} form ...
@emph{This form is deprecated.}
Functionally equivalent to @code{defmacro}.
@end deffn

@deffn Syntax defmacro name lambda-list form ...
@emph{This form is deprecated.}
Instead of
@example
(defmacro (@var{name} ...)
  (let ... `(... ,@var{exp} ...)))
@end example
you should probably do:
@example
(define-syntax-case @var{name} ()
  ((_ ...) (let #`(... @var{exp} ...))))
@end example
and instead of
@example
(defmacro (@var{name} ... @var{var} ...) `(... @var{var} ...))
@end example
you should probably do:
@example
(define-syntax-case @var{name} ()
  ((_ ... @var{var} ...) #`(... @var{var} ...))
@end example

Defines an old-style macro a la Common Lisp,
and installs @code{(lambda @var{lambda-list} @var{form} ...)}
as the expansion function for @var{name}.
When the translator sees an application of @var{name},
the expansion function is called with the rest of the application
as the actual arguments.  The resulting object must be a Scheme
source form that is futher processed (it may be repeatedly macro-expanded).
@end deffn

@deffn Procedure gentemp
Returns a new (interned) symbol each time it is called.
The symbol names are implementation-dependent.
(This is not directly macro-related, but is often used in conjunction
with @code{defmacro} to get a fresh unique identifier.)
@end deffn

@deffn Syntax cond-expand cond-expand-clause* [@stxlit{(else} command-or-definition*@stxlit{)}]
@display
@stxdef{cond-expand-clause} @stxlit{(}@var{feature-requirement} @var{command-or-definition}*@stxlit{)}
@findex @i{fff-rec}
@stxdef{feature-requirement} @var{feature-identifier}
  | @stxlit{(and} @var{feature-requirement}*@stxlit{)}
  | @stxlit{(or} @var{feature-requirement}*@stxlit{)}
  | @stxlit{(not} @var{feature-requirement}@stxlit{)}
@stxdef{feature-identifier} a symbol which is the name or alias of a SRFI
@end display

The @code{cond-expand} form tests for the existence of features at
macro-expansion time. It either expands into the body of one of its
clauses or signals an error during syntactic
processing. @code{cond-expand} expands into the body of the first clause
whose feature requirement is currently satisfied; the @code{else}
clause, if present, is selected if none of the previous clauses is
selected.

A feature requirement has an obvious interpretation as a logical
formula, where the @var{feature-identifier} variables have meaning true if @c 
the feature corresponding to the feature identifier, as specified in the
SRFI registry, is in effect at the location of the @code{cond-expand} form, and
false otherwise. A feature requirement is satisfied if its formula is
true under this interpretation.

Examples:
@example
(cond-expand
    ((and srfi-1 srfi-10)
     (write 1))
    ((or srfi-1 srfi-10)
     (write 2))
    (else))
@end example

@example
(cond-expand
  (command-line
   (define (program-name) (car (argv)))))
@end example

The second example assumes that @code{command-line} is an alias for some
feature which gives access to command line arguments. Note that an error
will be signaled at macro-expansion time if this feature is not present.

You can use @code{java-6} to check for Java 6.

You can use @code{class-exists:@var{ClassName}} to check
if @code{@var{ClassName}} exists.
@end deffn

@anchor{include}
@deffn Syntax include path
Read the contents of the file at @var{path} as a sequence of forms,
and treat the result as if the resulting forms were the forms
of a @code{begin}.
@end deffn

@anchor{include-relative}
@deffn Syntax include-relative path
Same as @code{include}, except that the @var{path} is relative to the
path of the source-file containing the @code{include-file}.
@end deffn

@deffn Procedure expand form
The result of evaluating @var{form} is treated as a Scheme expression,
syntax-expanded to internal form, and then converted back to (roughly)
the equivalent expanded Scheme form.

This can be useful for debugging macros.

To access this function, you must first @code{(require 'syntax-utils)}.
@example
(require 'syntax-utils)
(expand '(cond ((> x y) 0) (else 1))) @result{} (if (> x y) 0 1)
@end example
@end deffn

@node Multiple values, Symbols and namespaces, Syntax, Top
@chapter Multiple values

The multiple-value feature was added in R5RS.

@deffn Procedure values object ...
Delivers all of its arguments to its continuation.
@end deffn

@deffn Procedure call-with-values thunk receiver
Call its @var{thunk} argument with a continuation that,
when passed some values, calls the @var{receiver} procedure
with those values as arguments.
@end deffn

@deffn Syntax let-values @stxlit{((}@stxref{formals} @stxref{expression}@stxlit{)} ...@stxlit{)} @stxref{body}
Each @var{formals} should be a formal arguments list as for a @code{lambda}.

The @var{expression}s are evaluated in the current environment, the
variables of the @var{formals} are bound to fresh locations, the return
values of the @var{expression}s are stored in the variables, the
@var{body} is evaluated in the extended environment, and the values of
the last expression of @var{body} are returned. The @var{body} is a
"tail body", cf section 3.5 of the R5RS.

The matching of each @var{formals} to values is as for the matching of
@var{formals} to arguments in a @code{lambda} expression, and it is an
error for an @var{expression} to return a number of values that does not
match its corresponding @var{formals}.
@example
(let-values (((a b . c) (values 1 2 3 4)))
  (list a b c))            @result{} (1 2 (3 4)) 

(let ((a 'a) (b 'b) (x 'x) (y 'y))
  (let-values (((a b) (values x y))
               ((x y) (values a b)))
    (list a b x y)))       @result{} (x y a b)
@end example
@end deffn

@deffn Syntax let*-values @stxlit{((}@stxref{formals} @stxref{expression}@stxlit{)} ...@stxlit{)} @stxref{body}

Each @var{formals} should be a formal arguments list as for a
@code{lambda} expression.

@code{let*-values} is similar to @code{let-values}, but the bindings are
performed sequentially from left to right, and the region of a binding
indicated by (@var{formals} @var{expression}) is that part of the
@code{let*-values} expression to the right of the binding. Thus the
second binding is done in an environment in which the first binding is
visible, and so on.
@example
(let ((a 'a) (b 'b) (x 'x) (y 'y))
  (let*-values (((a b) (values x y))
                ((x y) (values a b)))
    (list a b x y)))       @result{} (x y x y)
@end example
@end deffn

@deffn Syntax receive @stxref{formals} @stxref{expression} @stxref{body}
This convenience
form (from @uref{http://srfi.schemers.org/srfi-8/srfi-8.html, SRFI-8})
is equivalent to:
@example
(let-values ((@var{formals} @var{expression})) @var{body})
@end example
For example:
@example
(receive a (values 1 2 3 4)
  (reverse a)) @result{} (4 3 2 1)

(receive (a b . c) (values 1 2 3 4)
  (list a b c))            @result{} (1 2 (3 4)) 

(let ((a 'a) (b 'b) (x 'x) (y 'y))
  (receive (a b) (values x y)
    (receive (x y) (values a b)
      (list a b x y))))    @result{} (x y x y)
@end example
@end deffn

@deffn Procedure values-append arg1 ...
The values resulting from evaluating each argument are appended
together.
@end deffn

@node Symbols and namespaces, Procedures, Multiple values, Top
@chapter Symbols and namespaces

An identifier is a name that appears in a program.

A symbol is an object representing a string that cannot be
modified. This string is called the symbol's name. Unlike strings, two
symbols whose names are spelled the same way are indistinguishable.
A symbol is immutable (unmodifiable) and normally viewed as atomic.
Symbols are useful for many applications; for instance, they may be
used the way enumerated values are used in other languages.

In addition to the simple symbols or standard Scheme, Kawa
also has compound (two-part) symbols.

@menu
* Simple symbols::
* Namespaces::
* Keywords::
* Special named constants::
@end menu

@node Simple symbols, Namespaces, , Symbols and namespaces
@section Simple symbols

Simple symbols have no properties other than their name, an immutable string.
They have the useful property that two simple symbols
are identical (in the sense of @func{eq?}, @func{eqv?} and
@func{equal?}) if and only if their names are spelled the same way.  A
symbol literal is formed using @func{quote}.

@deffn Procedure {symbol?} @var{obj}
Return @true{} if @var{obj} is a symbol, @false{} otherwise.

@example
(symbol? 'foo)          @result{} #t
(symbol? (car '(a b)))  @result{} #t
(symbol? "bar")         @result{} #f
(symbol? 'nil)          @result{} #t
(symbol? '())           @result{} #f
(symbol? #f)            @result{} #f
@end example
@end deffn

@deffn Procedure {symbol->string} @var{symbol}
Return the name of @var{symbol} as an immutable string.

@example
(symbol->string 'flying-fish)                   @result{}  "flying-fish"
(symbol->string 'Martin)                        @result{}  "Martin"
(symbol->string (string->symbol "Malvina"))     @result{}  "Malvina"
@end example
@end deffn

@deffn Procedure {string->symbol} @var{string}
Return the symbol whose name is @var{string}.

@example
(eq? 'mISSISSIppi 'mississippi)
@result{} #f

(string->symbol "mISSISSIppi")
@result{} the symbol with name "mISSISSIppi"

(eq? 'bitBlt (string->symbol "bitBlt"))
@result{} #t

(eq? 'JollyWog (string->symbol (symbol->string 'JollyWog)))
@result{} #t

(string=? "K. Harper, M.D."
          (symbol->string (string->symbol "K. Harper, M.D.")))
@result{} #t
@end example
@end deffn

@node Namespaces, Keywords, Simple symbols, Symbols and namespaces
@section Namespaces and compound symbols

Different applications may want to use the same symbol
to mean different things.  To avoid such @dfn{name clashes}
we can use @dfn{compound symbols}, which have two string parts:
a @dfn{local name} and a @dfn{namespace URI}.
The namespace-uri can be any string, but it is
recommended that it have the form of an absolute
@uref{http://en.wikipedia.org/wiki/Uniform_Resource_Identifier,URI}.
It would be too verbose to write the full URI all the
time, so one usually uses a @dfn{namespace prefix}
(namespace alias) as a short local alias to refer to a
namespace URI.

Compound symbols are usually written using the infix colon operator:
@example
@var{prefix}@stxlit{:}@var{local-name}
@end example
where @var{prefix} is is namespace alias bound
to some (lexically-known) namespace URI.

Compound symbols are used for namespace-aware XML processing.

@subsection Namespace objects

A @dfn{namespace} is a mapping from strings to symbols.
The string is the local-name of resulting symbol.
A namespace is similar to a Common Lisp @dfn{package}.

A namespace has a namespace-uri, which a string;
it recommended that it have the form of an absolute URI.
A namespace may optionally have a prefix, which is a string used
when printing out symbols belonging to the namespace.
(If you want for ``equivalent symbols'' (i.e. those that have the same
local-name and same uri) to be the identical symbol object, then
you should use namespaces whose prefix is the empty string.)

@deffn Constructor namespace name [prefix]
Return a namespace with the given @var{name} and @var{prefix}.
If no such namespace exists, create it.
The @var{namespace-name} is commonly a URI, especially when working with XML,
in which case it is called a @var{namespace-URI}.  However, any non-empty
string is allowed.
The prefix can be a string or a simple symbol.
(If a symbol is used, then the symbol's local-name is used.)
The default for @var{prefix} is the empty string.
Multiple calls with the same arguments will yield the same namespace object.
@end deffn

The reader macro @code{#,namespace} is equivalent to the
@code{namespace} function, but it is invoked at read-time:
@example
#,(namespace "http://www.w3.org/1999/XSL/Transform" xsl)
(eq? #,(namespace "foo") (namespace "foo")) @result{} #t
@end example

The form @code{(,#namespace "" "")} returns the default @dfn{empty namespace},
which is used for simple symbols.

@deffn Procedure namespace-uri namespace
Return the namespace-uri of the argument @var{namespace}, as a string.
@end deffn

@deffn Procedure namespace-prefix namespace
Return the namespace prefix of the argument @var{namespace}, as a string.
@end deffn

@subsection Compound symbols

A compound symbol is one that belongs to a namespace other than the
default empty namespace, and (normally) has a non-empty namespace uri.
(It is possible for a symbol to belong to a non-default namespace
and have an empty namespace uri, but that is not recommended.)

@deffn Constructor symbol local-name namespace-spec
@deffnx Constructor symbol local-name [uri [prefix]]
Construct a symbol with the given @var{local-name} and namespace.
If @var{namespace-spec} is a namespace object, then find (or if needed
construct) a symbol with the given @var{local-name} belonging to the
namespace.  Multiple calls to @code{symbol} with the same namespace
and @var{local-name} will yield the same symbol object.

If uri is a string (optionally followed by a prefix),
then:
@example
(symbol lname uri [prefix])
@end example
is equivalent to:
@example
(symbol lname (namespace uri [prefix]))
@end example

Using @code{#t} for the @var{namespace-spec} is equivalent to
using the empty namespace @code{#,(namespace "")}.

Using @code{#!null} or @code{#f} for the @var{namespace-spec}
creates an @var{uninterned} symbol, which does not belong to
any namespace.
@end deffn

@deffn Procedure symbol-local-name symbol
Return the local name of the argument symbol, as an immutable string.
(The string is interned, except in the case of an uninterned symbol.)
@end deffn

@deffn Procedure symbol-prefix symbol
Return the prefix of the argument symbol, as an immutable
(and interned) string.
@end deffn

@deffn Procedure symbol-namespace-uri symbol
Return the namespace uri of the argument symbol, as an immutable
(and interned) string.
@end deffn

@deffn Procedure symbol-namespace symbol
Return the namespace object (if any) of the argument symbol.
Returns @code{#!null} if the symbol is uninterned.
@end deffn

@deffn Procedure {symbol=?} @vari{symbol} @varii{symbol} @variii{symbol} @dots{}
Return @true{} if the symbols are equivalent as symbols,
i.e., if their local-names and namespace-uris are the same.
They may have different values of @code{symbol-prefix} and @code{symbol-namespace}.
If a symbol is uninterned (or is @code{#!null}) then @code{symbol=?}
returns the same result as @code{eq?}.
@end deffn

Two symbols are @code{equal?} or @code{eqv?} if they're @code{symbol=?}.

@subsection Namespace aliases

A namespace is usually referenced using a shorter @dfn{namespace alias},
which is is a lexical definition that binds a namespace prefix
to a namespace object (and thus a namespace uri).
This allows using compound symbols as identifiers in Scheme programs.

@deffn Syntax define-namespace name namespace-name
Defines @var{name} as a @dfn{namespace prefix} - a lexically scoped
"nickname" for the namespace
whose full name is @var{namespace-name}, which should be a non-empty
string literal.
It is customary for the string have syntactic form of
an absolute @uref{http://en.wikipedia.org/wiki/Uniform_Resource_Identifier,URI},
but any non-empty string is acceptable and is used without
further interpretation.

Any symbols in the scope of this definitions that contain a colon, and
where the part before the colon matches the @var{name} will be
treated as being in the package/namespace whose global unique name
is the @var{namespace-name}.

Has mostly the same effect as:
@example
(define-constant @var{name} #,(namespace @var{namespace-name})
@end example

However, using @code{define-namespace} (rather than @code{define-constant})
is recommended if you want to use compound symbols as names of
variables, especially local variables, or if you want to quote
compound symbols.

Note that the prefix is only visible lexically: it is not
part of the namespace, or thus indirectly the symbols, and
so is not available when printing the symbol.
You might consider using @code{define-xml-namespace} as an alternative.

A namespace is similar to a Common Lisp package,
and the @var{namespace-name} is like the name of the package.
However, a namespace alias belongs to the lexical scope,
while a Common Lisp package nickname is global
and belongs to the package itself.

If the namespace-name starts with the string @code{"class:"}, then the
@var{name} can be used for invoking Java methods
(@pxref{Method operations}) and accessing fields (@pxref{Field operations}).

You can use a namespace as an abbreviation or renaming of a
class name, but as a matter of style @code{define-alias} is preferred.
@end deffn

@deffn Syntax define-private-namespace name namespace-name
Same as @code{define-namespace}, but the prefix @var{name}
is local to the current module.
@end deffn

For example you might have a set of a geometry definitions
defined under the namespace-uri @code{"http://foo.org/lib/geometry"}:

@example
(define-namespace geom "http://foo.org/lib/geometry")
(define (geom:translate x y)
  (java.awt.geom.AffineTransform:getTranslateInstance x y))
(define geom:zero (geom:translate 0 0))
geom:zero
  @result{} AffineTransform[[1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]
@end example

You could have some other definitions for complex math:
@example
(define-namespace complex "http://foo.org/lib/math/complex")
(define complex:zero +0+0i)
@end example

You can use a namespace-value directly in a compound name:
@example
(namespace "http://foo.org/lib/geometry"):zero
  @result{} AffineTransform[[1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]
@end example

The variation @code{define-xml-namespace} is used for @ref{Creating XML nodes}.

@deffn Syntax define-xml-namespace prefix "namespace-uri"
Defines a namespace with prefix @var{prefix} and URI @var{namespace-uri}.
This is similar to @code{define-namespace} but with two important differences:
@itemize
@item
Every symbol in the namespace automatically maps to
an element-constructor-type, as with  the @code{html} namespace.
@item
The @var{prefix} is a component of the namespace object, and
hence indirectly of any symbols belongining to the namespace.
@end itemize

Thus the definition is roughly equivalent to:
@example
(define-constant @var{name} #,(namespace @var{namespace-name name})
@end example
along with an infinite set of definitions, for every possible @var{tag}:
@example
(define (name:@var{tag} . rest) (apply make-element 'name:@var{tag} rest))
@end example

@end deffn

@example
$ kawa --output-format xml
#|kawa:1|# (define-xml-namespace na "Namespace1")
#|kawa:2|# (define-xml-namespace nb "Namespace1")
#|kawa:3|# (define xa (na:em "Info"))
#|kawa:4|# xa
<na:em xmlns:na="Namespace1">Info</na:em>
#|kawa:5|# (define xb (nb:em "Info"))
#|kawa:6|# xa
<nb:em xmlns:nb="Namespace1">Info</nb:em>
@end example

Note that the prefix is part of the qualified name
(it is actually part of the namespace object),
and it is used when printing the tag.
Two qualified names (symbols) that have the same
local-name and the same namespace-name are considered
equal, even if they have different prefix.  You can think of
the prefix as annotation used when printing, but not
otherwise part of the ``meaning'' of a compound symbol.
They are the same object if they also have the same prefix.
This is an important different from traditional Lisp/Scheme symbols,
but it is how XML QNames work.
@example
#|kawa:7|# (instance? xb na:em)
true
#|kawa:8|# (eq? 'na:em 'nb:em)
false
#|kawa:9|# (equal? 'na:em 'nb:em)
true
#|kawa:10|# (eqv? 'na:em 'nb:em)
true
@end example
(Note that @code{#t} is printed as @code{true} when using XML formatting.)

The predefined @code{html} prefix could be defined thus:
@example
(define-xml-namespace html "http://www.w3.org/1999/xhtml")
@end example

@node Keywords, Special named constants, Namespaces, Symbols and namespaces
@section Keywords

Keywords are similar to symbols.  The main difference is that keywords are
self-evaluating and therefore do not need to be quoted in expressions.
They are used mainly for specifying keyword arguments.

@display
@stxdef{keyword} @stxref{identifier}@stxlit{:}
@end display

A keyword is a single token; therefore no whitespace is allowed between
the @var{identifier} and the colon (which is not considered part
of the name of the keyword).

@deffn Procedure keyword? obj
Return @code{#t} if @var{obj} is a keyword, and otherwise returns @code{#f}.
@end deffn

@deffn Procedure keyword->string keyword
Returns the name of @var{keyword} as a string.
The name does not include the final @code{#\:}.
@end deffn

@deffn Procedure string->keyword string
Returns the keyword whose name is @var{string}.
(The @var{string} does not include a final @code{#\:}.)
@end deffn

@node Special named constants, , Keywords, Symbols and namespaces
@section Special named constants

@defvr Constant #!optional
Special self-evaluating literal used in lambda parameter lists
before optional parameters.
@end defvr

@defvr Constant #!rest
Special self-evaluating literal used in lambda parameter lists
before the rest parameter.
@end defvr

@defvr Constant #!key
Special self-evaluating literal used in lambda parameter lists
before keyword parameters.
@end defvr

@defvr Constant #!eof
The end-of-file object.

Note that if the Scheme reader sees this literal at top-level,
it is returned literally.  This is indistinguishable from
coming to the end of the input file.  If you do not want to end reading,
but want the actual value of @code{#!eof}, you should quote it.
@end defvr

@defvr Constant #!void
The void value.  Same as @code{(values)}.
If this is the value of an expression in a read-eval-print loop,
nothing is printed.
@end defvr

@defvr Constant #!null
The Java @code{null} value.  This is not really a Scheme value,
but is useful when interfacing to low-level Java code.
@end defvr

@node Procedures, Numbers, Symbols and namespaces, Top
@chapter Procedures

@deffn Procedure apply proc [arg1 ...] args
@var{Args} must be a sequence (list, vector, or string) or a
primitive Java array.
(This is an extension over standard Scheme, which requires that
@var{args} be a list.)
Calls the @var{proc} (which must be a procedure), using as arguments
the @var{arg1}... values plus all the elements of @var{args}.
@end deffn

@deffn Syntax constant-fold proc arg1 ...
Same as @code{(@var{proc} @var{arg1} ...)}, unless @var{proc} and
all the following arguments are compile-time constants.
(That is:  They are either constant, or symbols that have a global
binding and no lexical binding.)  In that case, @var{proc}
is applied to the arguments at compile-time, and the result replaces
the @code{constant-fold} form.  If the application raises an exception,
a compile-time error is reported.
For example:
@example
(constant-fold vector 'a 'b 'c)
@end example
is equivalent to @code{(quote #(a b c))}, assuming @code{vector}
has not been re-bound.
@end deffn

@menu
* Procedure properties::
* Generic procedures::
* Extended formals::
@end menu

@node Procedure properties, Generic procedures, , Procedures
@section Procedure properties

You can associate arbitrary @dfn{properties} with any procedure.
Each property is a (@var{key}, @var{value})-pair.  Usually the
@var{key} is a symbol, but it can be any object.

The system uses certain internal properties:
@code{'name} refers to the name used when a procedure is printed;
@code{'emacs-interactive} is used to implement Emacs @code{interactive}
specification;
@code{'setter} is used to associate a @code{setter} prcedure.

@deffn Procedure procedure-property proc key [default]
Get the property value corresponding to the given @var{key}.
If @var{proc} has no property with the given @var{key},
return @var{default} (which defaults to @code{#f}) instead.
@end deffn

@deffn Procedure set-procedure-property! proc key value
Associate the given @var{value} with the @var{key} property of @var{proc}.
@end deffn

To change the print name of the standard @code{+} procedure (probably
not a good idea!), you could do:
@example
(set-procedure-property! + 'name 'PLUS)
@end example
Note this @emph{only} changes the name property used for printing:
@example
+ @result{} #<procedure PLUS>
(+ 2 3) @result{} 5
(PLUS 3 4) @result{} ERROR
@end example

As a matter of style, it is cleaner to use the @code{define-procedure}
form, as it is a more declarative interface.

@deffn Syntax define-procedure name [propname: propvalue] ... method ...
Defines @var{name} as a compound procedure consisting of the
specified @var{method}s, with the associated properties.
Applying @var{name} select the "best" @var{method}, and applies that.
See the following section on generic procedures.

For example, the standard @code{vector-ref} procedure specifies
one method, as well as the @code{setter} property:
@example
(define-procedure vector-ref
  setter: vector-set!
  (lambda ((vector :: <vector>) (k :: <int>))
    (invoke vector 'get k)))
@end example
@end deffn

@node Generic procedures, Extended formals, Procedure properties, Procedures
@section Generic (dynamically overloaded) procedures

A @dfn{generic procedure} is a collection of @dfn{method procedures}.
(A "method procedure" is not the same as a Java method, but
the terms are related.)
You can call a generic procedure, which selects the "closest
match" among the component method procedures:  I.e. the most specific
method procedure that is applicable given the actual arguments.

@quotation
@strong{Warning:} The current implementation of selecting the "best" method
is not reliable if there is more than one method.
It can select depending on argument count, and it can select between
primitive Java methods.  However, selecting between different Scheme
procedures based on parameter types should be considered experimental.
The main problem is we can't determine the most specific
method, so Kawa just tries the methods in order.
@end quotation

@deffn Procedure make-procedure [keyword: value]... method...
Create a generic procedure given the specific methods.
You can also specify property values for the result.

The @var{keyword}s specify how the arguments are used.
A @code{method:} keyword is optional and specifies that the following
argument is a method.
A @code{name:} keyword specifies the name of the resulting procedure,
when used for printing.
Unrecognized keywords are used to set the procedure properties of the result.
@example
(define plus10 (make-procedure foo: 33 name: 'Plus10
                            method: (lambda (x y) (+ x y 10))
                            method: (lambda () 10)))
@end example
@end deffn

@node Extended formals, , Generic procedures, Procedures
@section Extended Formal Arguments List

The formal arguments list of a lambda expression has two
extendsions over standard Scheme:
Kawa borrows the extended formal argument list of DSSSL,
and Kawa allows you to declare the type of the parameter.

@display
@stxdef{lambda-expression} @stxlit{(lambda} @stxref{formals} @stxref{opt-return-type} @stxref{body}@stxlit{)}
@stxdef{return-type} @stxref{type}
@stxdef{opt-return-type} [[@stxlit{::}] @stxref{type}]
@end display
where
@display
@stxdef{formals} @stxlit{(}@stxref{formal-arguments}@stxlit{)} | @stxref{rest-arg}
@end display
You can of course also use the extended format in a @code{define}:
@example
@b{(define (}@var{name} @var{formal-arguments}@b{)} [@var{rtype}] @var{body}@b{)}
@end example
@display
@stxdef{formal-arguments}
    @stxref{req-opt-args} (@stxref{rest-key-args} | @stxlit{.} @stxref{rest-arg})
@end display
@display
@stxdef{req-opt-args} @stxref{req-arg} ... [@stxlit{#!optional} @stxref{opt-arg} ...]
@stxdef{rest-key-args} [@stxlit{#!rest} @stxref{rest-arg}] [@stxlit{#!key} @stxref{key-arg} ...]
@stxdef{req-arg}  @var{variable} [@stxlit{::} @var{type}] | @stxlit{(}@var{variable} [[@stxlit{::}] @var{type}] @stxlit{)}
@stxdef{opt-arg} @stxref{arg-with-default}
@stxdef{key-arg} @stxref{arg-with-default}
@stxdef{arg-with-default} @var{variable} [@stxlit{::} @var{type}]
    | @stxlit{(} @var{variable} [@stxlit{::} @var{type} [@var{initializer}] | @var{initializer} [[@stxlit{::}] @var{type}]] @stxlit{)}
@stxdef{rest-arg} @var{variable}
@end display

When the procedure is applied to a list of actual arguments, the formal and
actual arguments are processed from left to right as follows:

@itemize
@item
The @var{req-arg}s are bound to actual arguments starting with the
first actual argument.  It shall be an error if there are fewer actual
arguments then there are @var{req-arg}s.
@item
Next the @var{opt-arg}s are bound to remaining actual arguemnts.
If there are fewer remaining actual arguments than there are
@var{opt-arg}s, then the remaining @var{variable}s are bound
to the corresponding @var{initializer}, if one was specified, and
otherwise to @code{#f}.  The @var{initializer} is evaluated in an
environment in which all the previous formal parameters have been bound.
@item
If there is a @var{rest-arg}, it is bound to a list of all the
remaining actual arguments.  These remaining actual arguments are also
eligible to be bound to keyword arguments.   If there is no
@var{rest-arg} and there are no @var{key-arg}s, then it shall
be an error if there are any remaining actual arguments.
@item
If @code{#!key} was specified, then there shall be an even number of
remaining actual arguments.  These are interpreted as a series of pairs,
where the first member of each pair is a keyword specifying the argument name,
and the second is the corresponding value.  It shall be an error if the first
member of a pair is not a keyword.  It shall be an error if the argument name
is not the same as a variable in a @var{key-arg}s, unless there
is a @var{rest-arg}.  If the same argument name occurs more than once
in the list of actual arguments, then the first value is used.
If there is no actual argument for a particular @var{key-arg},
then the variable is bound
to the corresponding @var{initializer}, if one was specified, and
otherwise to @code{#f}.  The @var{initializer} is evaluated in an
environment in which all the previous formal parameters have been bound.
@end itemize

If a @var{type} is specified, the corresponding actual argument (or
the @var{initializer} default value) is coerced to the specified @var{type}.
In the function body, the parameter has the specified type.

If @var{rtype} (the first form of the function body) is an unbound
identifier of the form @code{<TYPE>} (that is the first character
is @samp{<} and the last is @samp{>}), then that specifies the
function's return type.  It is syntactic sugar for
@code{(as <TYPE> (begin BODY))}.

@deffn Syntax cut slot-or-expr slot-or-expr* [@code{<...>}]
where each @var{slot-or-expr} is either an @var{expression} or
the literal symbol @code{<>}.

It is frequently necessary to specialize some of the parameters of a
multi-parameter procedure. For example, from the binary operation @code{cons}
one might want to obtain the unary operation
@code{(lambda (x) (cons 1 x))}.
This specialization of parameters is also known
as @dfn{partial application}, @dfn{operator section}, or @dfn{projection}.
The macro @code{cut} specializes some of the parameters of its first
argument. The parameters that are to show up as formal variables of the
result are indicated by the symbol @code{<>}, pronouced as "slot".
In addition, the symbol @code{<...>}, pronounced as "rest-slot", matches all
residual arguments of a variable argument procedure.

A @code{cut}-expression is transformed into
a @var{lambda expression} with as many formal variables as there are
slots in the list @var{slot-or-expr}*.
The body of the resulting @var{lambda expression} calls
the first @var{slot-or-expr} with arguments from the @var{slot-or-expr}* list
in the order they appear. In case there is a rest-slot symbol, the resulting
procedure is also of variable arity, and the body calls the first
@var{slot-or-expr} with remaining arguments provided to the actual call of the
specialized procedure.

Here are some examples:

@code{(cut cons (+ a 1) <>)} is the same as @w{@code{(lambda (x2) (cons (+ a 1) x2))}}

@code{(cut list 1 <> 3 <> 5)} is the same as @w{@code{(lambda (x2 x4) (list 1 x2 3 x4 5))}}

@code{(cut list)} is the same as @w{@code{(lambda () (list))}}

@code{(cut list 1 <> 3 <...>)} is the same as @w{@code{(lambda (x2 . xs) (apply list 1 x2 3 xs))}}

The first argument can also be a slot, as one should expect in Scheme:
@code{(cut <> a b)} is the same as @w{@code{(lambda (f) (f a b))}}
@end deffn

@deffn Syntax cute slot-or-expr slot-or-expr* [@code{<...>}]
The macro @code{cute} (a mnemonic for "cut with evaluated non-slots") is
similar to @code{cut}, but it evaluates the non-slot expressions at the
time the procedure is specialized, not at the time the specialized
procedure is called.

For example
@code{(cute cons (+ a 1) <>)} is the same as
@w{@code{(let ((a1 (+ a 1))) (lambda (x2) (cons a1 x2)))}}

As you see from comparing this example with the first example above, the
@code{cute}-variant will evaluate @code{(+ a 1)} once,
while the @code{cut}-variant will
evaluate it during every invocation of the resulting procedure.

@end deffn

@node Numbers, Characters and text, Procedures, Top
@chapter Quantities and Numbers

Kawa supports the full Scheme set of number operations with some extensions.

Kawa converts between Scheme number types
and Java number types as appropriate.

@menu
* Arithmetic operations::
* Quantities::
* Logical Number Operations::
* Performance of numeric operations::
@end menu

@node Arithmetic operations
@section Arithmetic operations

@deffn Procedure + @var{z} @dots{}
@deffnx Procedure * @var{z} @dots{}
These procedures return the sum or product of their arguments.

@example
(+ 3 4)                          @result{}  7
(+ 3)                            @result{}  3
(+)                              @result{}  0
(+ +inf.0 +inf.0)                @result{}  +inf.0
(+ +inf.0 -inf.0)                @result{}  +nan.0

(* 4)                            @result{}  4
(*)                              @result{}  1
(* 5 +inf.0)                     @result{}  +inf.0
(* -5 +inf.0)                    @result{}  -inf.0
(* +inf.0 +inf.0)                @result{}  +inf.0
(* +inf.0 -inf.0)                @result{}  -inf.0
(* 0 +inf.0)                     @result{}  +nan.0
(* 0 +nan.0)                     @result{}  +nan.0
(* 1.0 0)                        @result{}  0.0
@end example

For any real number object @var{x} that is neither infinite nor NaN:

@example
(+ +inf.0 @var{x})                   @result{}  +inf.0
(+ -inf.0 @var{x})                   @result{}  -inf.0
@end example

For any real number object @var{x}:

@example
(+ +nan.0 @var{x})                   @result{}  +nan.0
@end example

For any real number object @var{x} that is not an exact 0:

@example
(* +nan.0 @var{x})                   @result{}  +nan.0
@end example

@c If any of these procedures are applied to mixed non--rational real and
@c non--real complex arguments, they either raise an exception with
@c condition type @code{&implementation-restriction} or return an
@c unspecified number object.

The behavior of @code{-0.0} is illustrated by the following examples:

@example
(+  0.0 -0.0)  @result{}  0.0
(+ -0.0  0.0)  @result{}  0.0
(+  0.0  0.0)  @result{}  0.0
(+ -0.0 -0.0)  @result{} -0.0
@end example
@end deffn

@deffn Procedure - @var{z}
@deffnx Procedure - @vari{z} @varii{z} @variii{z} @dots{}
With two or more arguments, this procedures returns the difference of
its arguments, associating to the left.  With one argument, however, it
returns the negation (additive inverse) of its argument.

@example
(- 3 4)                               @result{}  -1
(- 3 4 5)                             @result{}  -6
(- 3)                                 @result{}  -3
(- +inf.0 +inf.0)                     @result{}  +nan.0
@end example

@c If this procedure is applied to mixed non--rational real and non--real
@c complex arguments, it either raises an exception with condition type
@c @code{&implementation-restriction} or returns an unspecified number
@c object.

The behavior of @code{-0.0} is illustrated by the following examples:

@example
(-  0.0)       @result{} -0.0
(- -0.0)       @result{}  0.0
(-  0.0 -0.0)  @result{}  0.0
(- -0.0  0.0)  @result{} -0.0
(-  0.0  0.0)  @result{}  0.0
(- -0.0 -0.0)  @result{}  0.0
@end example
@end deffn

@deffn Procedure / @var{z}
@deffnx Procedure / @vari{z} @varii{z} @variii{z} @dots{}
If all of the arguments are exact, then the divisors must all be
nonzero.  With two or more arguments, this procedure returns the
quotient of its arguments, associating to the left.  With one argument,
however, it returns the multiplicative inverse of its argument.

@example
(/ 3 4 5)                         @result{}  3/20
(/ 3)                             @result{}  1/3
(/ 0.0)                           @result{}  +inf.0
(/ 1.0 0)                         @result{}  +inf.0
(/ -1 0.0)                        @result{}  -inf.0
(/ +inf.0)                        @result{}  0.0
(/ 0 0)                           @result{}  exception &assertion
(/ 3 0)                           @result{}  exception &assertion
(/ 0 3.5)                         @result{}  0.0
(/ 0 0.0)                         @result{}  +nan.0
(/ 0.0 0)                         @result{}  +nan.0
(/ 0.0 0.0)                       @result{}  +nan.0
@end example

If this procedure is applied to mixed non--rational real and non--real
complex arguments, it either raises an exception with condition type
@code{&implementation-restriction} or returns an unspecified number
object.
@end deffn

@deffn Procedure div @vari{x} @varii{x}
@deffnx Procedure mod @vari{x} @varii{x}
@deffnx Procedure div-and-mod @vari{x} @varii{x}

These procedures implement number--theoretic integer division.
They accept two real numbers @vari{x} and @varii{x} as operands,
where @varii{x} must be nonzero.
(Kawa allows @varii{x} to be zero for @code{mod}.)
@code{div} returns an integer, and @code{mod} returns a real.
Their results are specified by:

@example
(div @vari{x} @varii{x}) @result{} @var{nd}
(mod @vari{x} @varii{x}) @result{} @var{xm}
@end example

such that:

@example
@vari{x} = @var{nd} * @varii{x} + @var{xm}
0  <= @var{xm} < |@varii{x}|
@end example

@c In the cases where the mathematical
@c requirements cannot be satisfied by
@c any number object, either an exception is raised with condition type
@c @code{&implementation-restriction}, or unspecified number objects (one
@c for for @func{div}, @func{mod}, @func{div0} and @func{mod0}, two for
@c @func{div-and-mod} and @func{div0-and-mod0}) are returned.

@example
(div-and-mod @vari{x} @varii{x})
  @result{} (values (div @vari{x} @varii{x}) (mod @vari{x} @varii{x}))
@end example

@example
(div 123 10)    @result{}  12
(mod 123 10)    @result{}  3
(div 123 -10)   @result{}  -12
(mod 123 -10)   @result{}  3
(div -123 10)   @result{}  -13
(mod -123 10)   @result{}  7
(div -123 -10)  @result{}  13
(mod -123 -10)  @result{}  7
(mod 123 0)     @result{}  123 ;; Kawa extension
@end example
@end deffn


@deffn Procedure div0 @vari{x} @varii{x}
@deffnx Procedure mod0 @vari{x} @varii{x}
@deffnx Procedure div0-and-mod0 @vari{x} @varii{x}
@code{div0} and @code{mod0} are like @code{div} and @code{mod}, except
the result of @code{mod0} lies within a half--open interval centered on
zero.  The results are specified by:
@example
(div0 @vari{x} @varii{x}) @result{} @var{nd}
(mod0 @vari{x} @varii{x}) @result{} @var{xm}
@end example
such that:
@example
@vari{x} = @var{nd} * @varii{x} + @var{xm}
-|@varii{x}| <= @var{xm} < |@varii{x}/2|
@end example

@example
(div0-and-mod0 @vari{x} @varii{x})
  @result{} (values (div0 @vari{x} @varii{x}) (mod0 @vari{x} @varii{x}))
@end example

@example
(div0 123 10)   @result{}  12
(mod0 123 10)   @result{}  3
(div0 123 -10)  @result{}  -12
(mod0 123 -10)  @result{}  3
(div0 -123 10)  @result{}  -12
(mod0 -123 10)  @result{}  -3
(div0 -123 -10) @result{}  12
(mod0 -123 -10) @result{}  -3
@end example
@end deffn

@deffn Procedure quotient x y
Kawa generalizes @code{quotient} to arbitrary real numbers,
using the definition:
@code{(truncate (/ x y))}.
@end deffn

@deffn Procedure remainder x y
Generalized to arbitrary real numbers, using the definition:
@code{(- x (* y (truncate (/ x y))))}.
If @code{y} is @code{0}, the result is @code{x} - i.e. we take
@code{(* 0 (quotient x 0))} to be @code{0}.
The result is inexact if either argument is inexact,
even if @code{x} is exact and @code{y} is 0.
@example
(remainder 13 4)     @result{} 1
(remainder -13 4)    @result{} -1
(remainder 13 -4)    @result{} 1
(remainder -13 -4)   @result{} -1
(remainder -13 -4.0) @result{} -1.0
@end example
@end deffn

@deffn Procedure modulo x y
Generalized to arbitrary real numbers, using the definition:
@code{(- x (* y (floor (/ x y))))}.
If @code{y} is @code{0}, the result is @code{x}.
The result is inexact if either argument is inexact,
even if @code{x} is exact and @code{y} is 0.

@example
(modulo 13 4)   @result{} 1
(modulo -13 4)  @result{} 3
(modulo 13 -4)  @result{} -4
(modulo -13 -4) @result{} -1
@end example
@end deffn

@deffn Procedure abs @var{x}
Returns the absolute value of its argument.

@example
(abs -7)                         @result{}  7
(abs -inf.0)                     @result{}  +inf.0
@end example
@end deffn

@deffn Procedure gcd @vari{n} @dots{}
@deffnx Procedure lcm @vari{n} @dots{}
These procedures return the greatest common divisor or least common
multiple of their arguments.  The result is always non--negative.
(R6RS allows inexact integer arguments; Kawa does not.)

@example
(gcd 32 -36)                     @result{}  4
(gcd)                            @result{}  0
(lcm 32 -36)                     @result{}  288
(lcm 32.0 -36)                   @result{}  288.0
(lcm)                            @result{}  1
@end example
@end deffn

@deffn Procedure numerator @var{q}
@deffnx Procedure denominator @var{q}
These procedures return the numerator or denominator of their argument;
the result is computed as if the argument was represented as a fraction
in lowest terms.  The denominator is always positive.  The denominator
of @code{0} is defined to be @code{1}.
(R6RS allows inexact integer arguments; Kawa does not.)

@example
(numerator   (/ 6 4))            @result{}  3
(denominator (/ 6 4))            @result{}  2
@c (denominator (inexact (/ 6 4)))        =>  2.0
@end example
@end deffn

@deffn Procedure floor @var{x}
@deffnx Procedure ceiling @var{x}
@deffnx Procedure truncate @var{x}
@deffnx Procedure round @var{x}
These procedures return inexact integer objects for inexact arguments
that are not infinities or NaNs, and exact integer objects for exact
rational arguments.

@table @code
@item floor
Returns the largest integer object not larger than @var{x}.

@item ceiling
Returns the smallest integer object not smaller than @var{x}.
@item truncate
Returns the integer object closest to @var{x} whose absolute value is
not larger than the absolute value of @var{x}.

@item round
Returns the closest integer object to @var{x}, rounding to even when
@var{x} represents a number halfway between two integers.
@end table

If the argument to one of these procedures is inexact, then the result
is also inexact.  If an exact value is needed, the result should be
passed to the @func{exact} procedure.

Although infinities and NaNs are not integer objects, these procedures
return an infinity when given an infinity as an argument, and a NaN when
given a NaN.

@example
(floor -4.3)                     @result{}  -5.0
(ceiling -4.3)                   @result{}  -4.0
(truncate -4.3)                  @result{}  -4.0
(round -4.3)                     @result{}  -4.0

(floor 3.5)                      @result{}  3.0
(ceiling 3.5)                    @result{}  4.0
(truncate 3.5)                   @result{}  3.0
(round 3.5)                      @result{}  4.0

(round 7/2)                      @result{}  4
(round 7)                        @result{}  7

(floor +inf.0)                   @result{}  +inf.0
(ceiling -inf.0)                 @result{}  -inf.0
(round +nan.0)                   @result{}  +nan.0
@end example
@end deffn

@deffn Procedure rationalize @vari{x} @varii{x}
The @func{rationalize} procedure returns a number object representing
the @emph{simplest} rational number differing from @vari{x} by no more
than @varii{x}.

A rational number @emph{r_1} is @emph{simpler} than another rational
number @emph{r_2} if @code{r_1 = p_1/q_1} and @code{r_2 = p_2/q_2} (in
lowest terms) and @code{|p_1| <= |p_2|} and @code{|q_1| <= |q_2|}.  Thus
@code{3/5} is simpler than @code{4/7}.

Although not all rationals are comparable in this ordering (consider
@code{2/7} and @code{3/5}) any interval contains a rational number that
is simpler than every other rational number in that interval (the
simpler @code{2/5} lies between @code{2/7} and @code{3/5}).

Note that @code{0 = 0/1} is the simplest rational of all.
@example
(rationalize (exact .3) 1/10)          => 1/3
(rationalize .3 1/10)                  => #i1/3  ; approximately

(rationalize +inf.0 3)                 =>  +inf.0
(rationalize +inf.0 +inf.0)            =>  +nan.0
@c (rationalize 3 +inf.0)                 =>  0.0
@end example

The first two examples hold only in implementations whose inexact real
number objects have sufficient precision.
@end deffn

@deffn Procedure exp @var{z}
@deffnx Procedure log @var{z}
@deffnx Procedure log @vari{z} @varii{z}
@deffnx Procedure sin @var{z}
@deffnx Procedure cos @var{z}
@deffnx Procedure tan @var{z}
@deffnx Procedure asin @var{z}
@deffnx Procedure acos @var{z}
@deffnx Procedure atan @var{z}
@deffnx Procedure atan @vari{x} @varii{x}
These procedures compute the usual transcendental functions.

The @func{exp} procedure computes the base--@var{e} exponential of
@var{z}.
The @func{log} procedure with a single argument computes the natural
logarithm of @var{z} (@strong{not} the base--10 logarithm); @code{(log
@vari{z} @varii{z})} computes the base--@varii{z} logarithm of @vari{z}.

The @func{asin}, @func{acos}, and @func{atan} procedures compute
arcsine, arccosine, and arctangent, respectively.  The two--argument
variant of @func{atan} computes:

@example
(angle (make-rectangular @varii{x} @vari{x}))
@end example

These procedures may return inexact results even when given exact
arguments.
@example
(exp +inf.0)    @result{} +inf.0
(exp -inf.0)    @result{} 0.0
(log +inf.0)    @result{} +inf.0
(log 0.0)       @result{} -inf.0
(log 0)         @result{} exception &assertion
(log -inf.0)    @result{} +inf.0+3.141592653589793i    ; approximately
(atan -inf.0)   @result{} -1.5707963267948965          ; approximately
(atan +inf.0)   @result{} 1.5707963267948965           ; approximately
(log -1.0+0.0i) @result{} 0.0+3.141592653589793i       ; approximately
(log -1.0-0.0i) @result{} 0.0-3.141592653589793i       ; approximately
                                                ; if -0.0 is distinguished
@end example
@end deffn
@deffn Procedure sqrt @var{z}
Return the principal square root of @var{z}.  For rational @var{z}, the
result has either positive real part, or zero real part and
non--negative imaginary part.  The value of @code{(sqrt @var{z})} could be
expressed as:

@example
e^((log z)/2)
@end example

The @func{sqrt} procedure may return an inexact result even when given
an exact argument.

@example
(sqrt -5)                   @result{}  0.0+2.23606797749979i ; approximately
(sqrt +inf.0)               @result{}  +inf.0
(sqrt -inf.0)               @result{}  +inf.0i
@end example
@end deffn

@node Quantities
@section Quantities and Units

As a super-class of numbers, Kawa also provides quantities.
A @dfn{quantity} is a product of a @dfn{unit} and a pure number.
The number part can be an arbitrary complex number.
The unit is a product of integer powers of base units,
such as meter or second.

Kawa quantities are a generalization of the quantities in DSSSL,
which only has length-derived quantities.

The precise syntax of quantity literals may change,
but some examples are @code{10pt} (10 points), @code{5s} (5 seconds),
and @code{4cm^2} (4 square centimeters).

@deffn Procedure quantity? object
True iff @var{object} is a quantity.  Note that all numbers are
quantities, but not the other way round.
Currently, there are no quantities that re not numbers.
To distinguish a plain unit-less number from a quantity,
you can use @code{complex?}.
@end deffn

@deffn Procedure quantity->number q
Returns the pure number part of the quantity @var{q}, relative to
primitive (base) units.
If @var{q} is a number, returns @var{q}.
If @var{q} is a unit, yields the magitude of @var{q} relative to base units.
@end deffn

@deffn Procedure quantity->unit q
Returns the unit of the quantity @var{q}.
If @var{q} is a number, returns the empty unit.
@end deffn

@deffn Procedure make-quantity x unit
Returns the product of @var{x} (a pure number) and @var{unit}.
You can specify a string instead of @var{unit}, such as @code{"cm"}
or @code{"s"} (seconds).
@end deffn

@deffn Syntax define-base-unit unit-name dimension
Define @var{unit-name} as a base (primitive) unit,
which is used to measure along the specified @var{dimension}.
@example
(define-base-unit dollar "Money")
@end example
@end deffn

@deffn Syntax define-unit unit-name expression
Define @var{unit-name} as a unit (that can be used in literals)
equal to the quantity @var{expression}.
@example
(define-unit cent 0.01dollar)
@end example
The @var{unit-name} is declared in the @code{unit} namespace,
so the above is equivalent to:
@example
(define-constant unit:cent (* 0.01 unit:dollar))
@end example
@end deffn

@node Logical Number Operations
@section Logical Number Operations

These functions operate on the 2's complement binary representation
of an exact integer.

@deffn Procedure bitwise-not i
Returns the bit-wise logical inverse of the argument.
More formally, returns the exact integer whose two's
complement representation is the one's complement of the two's
complement representation of @var{i}.
@end deffn

@deffn Procedure  bitwise-and i ...
@deffnx Procedure bitwise-ior i ...
@deffnx Procedure bitwise-xor i ...
These procedures return the exact integer that is the bit-wise
``and'', ``inclusive or'', or ``exclusive or'' of the two's
complement representations of their arguments.
If they are passed only one argument, they return that argument.
If they are passed no arguments, they return the integer
that acts as identity for the operation: -1, 0, or 0, respectively. 
@end deffn

@deffn Procedure bitwise-if i1 i2 i3

Returns the exact integer that is the bit-wise ``if'' of the twos
complement representations of its arguments, i.e. for each bit, if it
is 1 in i1, the corresponding bit in i2 becomes the value of the
corresponding bit in the result, and if it is 0, the corresponding bit
in i3 becomes the corresponding bit in the value of the result. This
is equivaent to the following computation:
@example
(bitwise-ior (bitwise-and i1 i2)
             (bitwise-and (bitwise-not i1) i3))
@end example
@end deffn

@deffn Procedure bitwise-bit-count i
If ei is non-negative, returns the number of 1 bits in the twos complement
representation of i. Otherwise it returns the result of the following
computation:
@example
(bitwise-not (bitwise-bit-count (bitwise-not i)))
@end example
@end deffn

@deffn Procedure bitwise-length i
Returns the number of bits needed to represent i if it is positive,
and the number of bits needed to represent @code{(bitwise-not @var{i})}
if it is negative, which is the exact integer that is the result of the
following computation:
@example
(do ((result 0 (+ result 1))
     (bits (if (negative? i)
               (bitwise-not i)
               ei)
           (bitwise-arithmetic-shift bits -1)))
    ((zero? bits)
     result))
@end example
This is the number of bits needed to represent @var{i} in an unsigned field.
@end deffn

@deffn Procedure bitwise-first-bit-set i
Returns the index of the least significant 1 bit in the twos complement
representation of i. If ei is 0, then - 1 is returned.
@example
(bitwise-first-bit-set 0) @result{} -1
(bitwise-first-bit-set 1) @result{} 0
(bitwise-first-bit-set -4) @result{} 2
@end example
@end deffn

@deffn Procedure bitwise-bit-set? i1 i2
Returns @code{#t} if the i2'th bit (where @var{i2} must be non-negative)
is 1 in the two's complement representation of @var{i1}, and @code{#f}
otherwise. This is the result of the following computation:
@example
(not (zero?
       (bitwise-and
         (bitwise-arithmetic-shift-left 1 i2)
         i1)))
@end example
@end deffn

@deffn Procedure bitwise-copy-bit i bitno replacement-bit
Return the result of replacing the @var{bitno}'th bit of @var{i}
by @var{replacement-bit}, where @var{bitno} must be non-negative,
and @var{replacement-bit} must be either 0 or 1.
This is the result of the following computation:
@example
(let* ((mask (bitwise-arithmetic-shift-left 1 bitno)))
  (bitwise-if mask
            (bitwise-arithmetic-shift-left replacement-bit bitno)
            i))
@end example
@end deffn

@deffn Procedure bitwise-bit-field n start end
Return the integer formed from the (unsigned) bit-field
starting at @var{start} and ending just before @var{end}.
Same as:
@example
(let ((mask
       (bitwise-not
        (bitwise-arithmetic-shift-left -1 @var{end}))))
  (bitwise-arithmetic-shift-right
    (bitwise-and @var{n} mask)
    @var{start}))
@end example
@end deffn

@deffn Procedure bitwise-copy-bit-field to start end from
Returns the result of replacing in @var{to} the bits at positions from @var{start} (inclusive) to @var{end} (exclusive) by the bits in @var{from} from position 0 (inclusive) to position @var{end} - @var{start} (exclusive).
Both @var{start} and @var{start} must be non-negative,
and @var{start} must be less than or equal to @var{start}.

This is the result of the following computation:
@example
(let* ((mask1
         (bitwise-arithmetic-shift-left -1 start))
       (mask2
         (bitwise-not
           (bitwise-arithmetic-shift-left -1 end)))
       (mask (bitwise-and mask1 mask2)))
  (bitwise-if mask
              (bitwise-arithmetic-shift-left from
                                             start)
              to))
@end example
@end deffn

@deffn Procedure bitwise-arithmetic-shift i j
Shifts @var{i} by @var{j}.
It is a ``left'' shift if @code{@var{j}>0}, and
a ``right'' shift if @code{@var{j}<0}.
The result is equal to @code{(floor (* @var{i} (expt 2 @var{j})))}.

Examples:
@example
(bitwise-arithmetic-shift -6 -1) @result{}-3
(bitwise-arithmetic-shift -5 -1) @result{} -3
(bitwise-arithmetic-shift -4 -1) @result{} -2
(bitwise-arithmetic-shift -3 -1) @result{} -2
(bitwise-arithmetic-shift -2 -1) @result{} -1
(bitwise-arithmetic-shift -1 -1) @result{} -1
@end example
@end deffn

@deffn Procedure bitwise-arithmetic-shift-left i amount
@deffnx Procedure bitwise-arithmetic-shift-right i amount
The @var{amount} must be non-negative
The @code{bitwise-arithmetic-shift-left} procedure returns the same
result as @code{bitwise-arithmetic-shift},
and @code{(bitwise-arithmetic-shift-right @var{i} @var{amount})} returns the
same result as @code{(bitwise-arithmetic-shift @var{i} (- @var{amount}))};
@end deffn

@deffn Procedure bitwise-rotate-bit-field n start end count
Returns the result of cyclically permuting in @var{n} the bits at positions
from @var{start} (inclusive) to @var{end} (exclusive) by
@var{count} bits towards the more significant bits,
@var{start} and @var{end} must be non-negative,
and @var{start} must be less than or equal to @var{end}.
This is the result of the following computation:
@example
(let* ((n     ei1)
       (width (- end start)))
  (if (positive? width)
      (let* ((count (mod count width))
             (field0
               (bitwise-bit-field n start end))
             (field1 (bitwise-arithmetic-shift-left
                       field0 count))
             (field2 (bitwise-arithmetic-shift-right
                       field0
                       (- width count)))
             (field (bitwise-ior field1 field2)))
        (bitwise-copy-bit-field n start end field))
      n))
@end example
@end deffn

@deffn Procedure bitwise-reverse-bit-field i start end
Returns the result obtained from @var{i} by reversing the order of the bits at positions from @var{start} (inclusive) to @var{end} (exclusive),
where @var{start} and @var{end} must be non-negative,
and @var{start} must be less than or equal to @var{end}.
@example
(bitwise-reverse-bit-field #b1010010 1 4) @result{}  88 ; #b1011000
@end example
@end deffn

@deffn Procedure logop op x y
Perform one of the 16 bitwise operations of @var{x} and @var{y},
depending on @var{op}.
@end deffn

@deffn Procedure logtest i j
Returns true if the arguments have any bits in common.
Same as @code{(not (zero? (bitwise-and @var{i} @var{j})))},
but is more efficient.
@end deffn

@subsection Deprecated Logical Number Operations

These older functions are still available, but we
recommand using the R6RS-compatible functions.

@deffn Procedure lognot i
Equivalent to @code{(bitwise-not @var{i})}.
@end deffn

@deffn Procedure logand i ...
Equivalent to @code{(bitwise-and @var{i} ...)}.
@end deffn

@deffn Procedure logior i ...
Equivalent to @code{(bitwise-ior @var{i} ...)}.
@end deffn

@deffn Procedure logxor i ...
Equivalent to @code{(bitwise-xor @var{i} ...)}.
@end deffn

@deffn Procedure logcount i
Count the number of 1-bits in @var{i}, if it is non-negative.
If @var{i} is negative, count number of 0-bits.
Same as @code{(bitwise-bit-count @var{i})} if @var{i} is non-negative.
@end deffn

@deffn Procedure integer-length i
Equivalent to @code{(bitwise-length @var{i})}.
@end deffn

@deffn Procedure logbit? i pos
Equivalent to @code{bitwise-bit-set? @var{i} @var{pos})}.
@end deffn

@deffn Procedure arithmetic-shift i j
Equivalent to @code{bitwise-arithmetic-shift @var{i} @var{j})}.
@end deffn

@deffn Procedure ash i j
Alias for @code{arithmetic-shift}.
@end deffn

@deffn Procedure bit-extract n start end
Equivalent to @code{(bitwise-bit-field @var{n} @var{start} @var{end})}.
@end deffn

@node Performance of numeric operations
@section Performance of numeric operations

Kawa can generally do a pretty good job of generating
efficient code for numeric operations, at least when
it knows or can figure out the types of the operands.

The basic operations @code{+}, @code{-}, and @code{*}
are compiled to single-instruction bytecode if both
operands are @code{int} or @code{long}.
Likewise, if both operands are floating-point (or
one is floating-point and the other is rational),
then single-instruction @code{double} or @code{float}
instructions are emitted.

A binary operation involing an infinite-precision @code{integer}
and a fixed-size @code{int} or @code{long} is normally
evaluated by expanding the latter to @code{integer}
and using @code{integer} arithmetic.  An exception is the
@code{integer} argument is an integer literal whose
value fits in a @code{int} or @code{long} - in that case
the operation is done using  @code{int} or @code{long}
arithmetic.

In general, integer literals have amorphous type.
When used to infer the type of a variable, they have @code{integer} type:
@example
(let ((v1 0))
  ... v1 has type integer ... )
@end example
However, a literal whose value fits in the @code{int} or @code{long} range
is implicitly viewed @code{int} or @code{long} in certain contexts,
primarily method overload resolution and binary arithmethic
(as mentioned above).

The comparison functions @code{<}, @code{<=}, @code{=},
@code{>}, and @code{=>} are also optimized to single instriction
operations if the operands have appropriate type.
However, the functions @code{zero?}, @code{positive?}, and @code{negative?}
have not yet been optimized.
Instead of @code{(positive? x)} write @code{(> x 0)}.

There are a number of integer division and modulo operations.
If the operands are @code{int} or @code{long}, it is faster
to use @code{quotient} and @code{remainder} rather
than @code{div} and @code{mod} (or @code{modulo}).
If you know the first operand is non-negative and the second is positive,
then use @code{quotient} and @code{remainder}.
(If an operand is an arbitrary-precision @code{integer},
then it dosn't really matter.)

The logical operations @code{bitwise-and}, @code{bitwise-ior},
@code{bitwise-xor}, @code{bitwise-not}, @code{bitwise-arithmetic-shift-left},
@code{bitwise-arithmetic-shift-right} are compiled
to single bitcode instructions if the operands are @code{int} or @code{long}.
Avoid @code{bitwise-arithmetic-shift} if the sign of the shift is known.
If the operands are arbitrary-precision @code{integer},
a library call is needed, but run-time type dispatch is avoided.

@node Characters and text, Data structures, Numbers, Top
@chapter Characters and text

@menu
* Characters::
* Character sets::
* Strings::
* Unicode::              Unicode character classes and conversions
* Regular expressions::
@end menu

@node Characters
@section Characters

@emph{Characters} are objects that represent Unicode scalar values.

@quotation
@emph{Note:}
Unicode defines a standard mapping between sequences of
@dfn{Unicode scalar values}  (integers in the range @code{0} to @code{#x10FFFF},
excluding the range @code{#xD800} to @code{#xDFFF}) in the latest
version of the standard and human--readable ``characters''.
More precisely, Unicode distinguishes
between glyphs, which are printed for humans to read, and characters,
which are abstract entities that map to glyphs (sometimes in a way
that’s sensitive to surrounding characters). Furthermore, different
sequences of scalar values sometimes correspond to the same
character. The relationships among scalar, characters, and glyphs are
subtle and complex.

Despite this complexity, most things that a literate human would call
a ``character'' can be represented by a single Unicode scalar value
(although several sequences of Unicode scalar values may represent
that same character). For example, Roman letters, Cyrillic letters,
Hebrew consonants, and most Chinese characters fall into this
category.

Unicode scalar values exclude the range @code{#xD800} to @code{#xDFFF},
which are part of the range of Unicode @dfn{code points}.
However, the Unicode code points in this range, the so-called
@dfn{surrogates}, are an artifact of the UTF-16 encoding, and can only
appear in specific Unicode encodings, and even then only in pairs that
encode scalar values.  Consequently, all characters represent code
points, but the surrogate code points do not have representations as
characters.
@end quotation

@deffn Procedure {char?} @var{obj}
Return @true{} if @var{obj} is a character, @false{} otherwise.
@end deffn

@deffn Procedure {char->integer} @var{char}
@deffnx Procedure {integer->char} @var{sv}
@var{sv} must be a Unicode scalar value, i.e., a non--negative exact
integer object in @code{[0, #xD7FF] union [#xE000, #x10FFFF]}.

Given a character, @func{char->integer} returns its Unicode scalar value
as an exact integer object.  For a Unicode scalar value @var{sv},
@func{integer->char} returns its associated character.

@example
(integer->char 32)                     @result{} #\space
(char->integer (integer->char 5000))   @result{} 5000
(integer->char #\xD800)                @result{} throws ClassCastException
@end example
@end deffn


@deffn Procedure {char=?} @vari{char} @varii{char} @variii{char} @dots{}
@deffnx Procedure {char<?} @vari{char} @varii{char} @variii{char} @dots{}
@deffnx Procedure {char>?} @vari{char} @varii{char} @variii{char} @dots{}
@deffnx Procedure {char<=?} @vari{char} @varii{char} @variii{char} @dots{}
@deffnx Procedure {char>=?} @vari{char} @varii{char} @variii{char} @dots{}
These procedures impose a total ordering on the set of characters
according to their Unicode scalar values.

@example
(char<? #\z #\ß)      @result{} #t
(char<? #\z #\Z)      @result{} #f
@end example
@end deffn

@node Character sets
@section Character sets

Sets of characters are useful for text-processing code,
including parsing, lexing, and pattern-matching.
@uref{http://srfi.schemers.org/srfi-14/srfi-14.html, SRFI 14} specifies
a @code{char-set} type for such uses.  Some examples:

@example
(import (srfi :14 char-sets))
(define vowel (char-set #\a #\e #\i #\o #\u))
(define vowely (char-set-adjoin vowel #\y))
(char-set-contains? vowel #\y) @result{}  #f
(char-set-contains? vowely #\y) @result{}  #t
@end example

See the @uref{http://srfi.schemers.org/srfi-14/srfi-14.html, SRFI 14 specification} for details.

@deffn Type char-set
The type of character sets.
In Kawa @code{char-set} is a type that can be used in type specifiers:
@example
(define vowely ::char-set (char-set-adjoin vowel #\y))
@end example
@end deffn

Kawa uses @uref{http://www.ibm.com/developerworks/linux/library/l-cpinv.html,inversion lists} for an efficient implementation, using Java @code{int} arrays
to represents character ranges (inversions).
The @code{char-set-contains?} function uses binary search,
so it takes time proportional to the logarithm of the number of inversions.
Other operations may take time proportional to the number of inversions.

@node Strings
@section Strings

Strings are sequences of characters.  The @emph{length} of a string is
the number of characters that it contains.  This number is fixed when
the string is created.  The @emph{valid indices} of a string are the
integers less than the length of the string.  The first character of a
string has index 0, the second has index 1, and so on.

@quotation
@emph{Kawa note:}
Kawa's implementation of strings that contain
surrogate characters does not quite follow the R6RS specification.
Specifically indexing into such a string retrieves a surrogate
rather than a Unicode scalar value.
It is not clear what the best solution is - there is a tradeoff
between performance, compatibility with R6RS, and
interoperability with Java APIs.
@end quotation

@deffn Procedure {string?} @var{obj}
Return @true{} if @var{obj} is a string, @false{} otherwise.
@end deffn


@deffn Procedure make-string @var{k}
@deffnx Procedure make-string @var{k} @var{char}
Return a newly allocated string of length @var{k}.  If @var{char} is
given, then all elements of the string are initialized to @var{char},
otherwise the contents of the @var{string} are unspecified.
@end deffn


@deffn Procedure string @var{char} @dots{}
Return a newly allocated string composed of the arguments.
@end deffn


@deffn Procedure string-length @var{string}
Return the number of characters in the given @var{string} as an exact
integer object.
@end deffn


@deffn Procedure string-ref @var{string} @var{k}
@var{k} must be a valid index of @var{string}.  The @func{string-ref}
procedure returns character @var{k} of @var{string} using zero--origin
indexing.

@c @quotation
@c @emph{Note:} Implementors should make @func{string-ref} run in constant
time.
@c @end quotation
@end deffn


@deffn Procedure {string=?} @vari{string} @varii{string} @variii{string} @dots{}
Return @true{} if the strings are the same length and contain the same
characters in the same positions.  Otherwise, the @func{string=?}
procedure returns @false{}.

@example
(string=? "Straße" "Strasse")    @result{} #f
@end example
@end deffn


@deffn Procedure {string<?} @vari{string} @varii{string} @variii{string} @dots{}
@deffnx Procedure {string>?} @vari{string} @varii{string} @variii{string} @dots{}
@deffnx Procedure {string<=?} @vari{string} @varii{string} @variii{string} @dots{}
@deffnx Procedure {string>=?} @vari{string} @varii{string} @variii{string} @dots{}
These procedures are the lexicographic extensions to strings of the
corresponding orderings on characters.  For example, @func{string<?} is
the lexicographic ordering on strings induced by the ordering
@func{char<?} on characters.  If two strings differ in length but are
the same up to the length of the shorter string, the shorter string is
considered to be lexicographically less than the longer string.

@example
(string<? "z" "ß")      @result{} #t
(string<? "z" "zz")     @result{} #t
(string<? "z" "Z")      @result{} #f
@end example
@end deffn


@deffn Procedure substring @var{string} @var{start} @var{end}
@var{string} must be a string, and @var{start} and @var{end} must be
exact integer objects satisfying:

@example
0 <= @var{start} <= @var{end} <= (string-length @var{string})
@end example

The @func{substring} procedure returns a newly allocated string formed
from the characters of @var{string} beginning with index @var{start}
(inclusive) and ending with index @var{end} (exclusive).
@end deffn


@deffn Procedure string-append @var{string} @dots{}
Return a newly allocated string whose characters form the concatenation
of the given strings.
@end deffn

@deffn Procedure string->list @var{string}
@deffnx Procedure list->string @var{list}
@var{list} must be a list of characters.

The @func{string->list} procedure returns a newly allocated list of the
characters that make up the given string.

The @func{list->string} procedure returns a newly allocated string
formed from the characters in @var{list}.

The @func{string->list} and @func{list->string} procedures are inverses
so far as @func{equal?} is concerned.
@end deffn

@ignore
@deffn Procedure string-for-each @var{proc} @vari{string} @varii{string} @dots{}
The @var{string}s must all have the same length.  @var{proc} should
accept as many arguments as there are @var{string}s.

The @func{string-for-each} procedure applies @var{proc} element--wise to
the characters of the @var{string}s for its side effects, in order from
the first characters to the last.  @var{proc} is always called in the
same dynamic environment as @func{string-for-each} itself.  The return
values of @func{string-for-each} are unspecified.

Analogous to @func{for-each}.
@end deffn
@end ignore


@deffn Procedure string-copy @var{string}
Returns a newly allocated copy of the given @var{string}.
@end deffn

@node Unicode, Regular expressions, Strings, Characters and text
@section Unicode character classes and conversions

@ignore
The procedures exported by the @rsixlibrary{unicode} library provide
access to some aspects of the Unicode semantics for characters and
strings: category information, case--independent comparisons, case
mappings, and normalization.
@end ignore

Some of the procedures that operate on characters or strings ignore the
difference between upper case and lower case.  These procedures have
@code{-ci} (for ``case insensitive'') embedded in their names.

@subsection Characters

@deffn Procedure char-upcase @var{char}
@deffnx Procedure char-downcase @var{char}
@deffnx Procedure char-titlecase @var{char}
@deffnx Procedure char-foldcase @var{char}
These procedures take a character argument and return a character
result.

If the argument is an upper--case or title--case character, and if there
is a single character that is its lower--case form, then
@func{char-downcase} returns that character.

If the argument is a lower--case or title--case character, and there is
a single character that is its upper--case form, then @func{char-upcase}
returns that character.

If the argument is a lower--case or upper--case character, and there is
a single character that is its title--case form, then
@func{char-titlecase} returns that character.

If the argument is not a title--case character and there is no single
character that is its title--case form, then @func{char-titlecase}
returns the upper--case form of the argument.

Finally, if the character has a case--folded character, then
@func{char-foldcase} returns that character.  Otherwise the character
returned is the same as the argument.

For Turkic characters @code{#\x130} and @code{#\x131},
@func{char-foldcase} behaves as the identity function; otherwise
@func{char-foldcase} is the same as @func{char-downcase} composed with
@func{char-upcase}.

@example
(char-upcase #\i)               @result{}  #\I
(char-downcase #\i)             @result{}  #\i
(char-titlecase #\i)            @result{}  #\I
(char-foldcase #\i)             @result{}  #\i

(char-upcase #\ß)               @result{}  #\ß
(char-downcase #\ß)             @result{}  #\ß
(char-titlecase #\ß)            @result{}  #\ß
(char-foldcase #\ß)             @result{}  #\ß

(char-upcase #\Σ)               @result{}  #\Σ
(char-downcase #\Σ)             @result{}  #\σ
(char-titlecase #\Σ)            @result{}  #\Σ
(char-foldcase #\Σ)             @result{}  #\σ

(char-upcase #\ς)               @result{}  #\Σ
(char-downcase #\ς)             @result{}  #\ς
(char-titlecase #\ς)            @result{}  #\Σ
(char-foldcase #\ς)             @result{}  #\σ
@end example

@quotation
@emph{Note:} @func{char-titlecase} does not always return a title--case
character.
@end quotation

@quotation
@emph{Note:} These procedures are consistent with Unicode's
locale--independent mappings from scalar values to scalar values for
upcase, downcase, titlecase, and case--folding operations.  These
mappings can be extracted from @file{UnicodeData.txt} and
@file{CaseFolding.txt} from the Unicode Consortium, ignoring Turkic
mappings in the latter.

Note that these character--based procedures are an incomplete
approximation to case conversion, even ignoring the user's locale.  In
general, case mappings require the context of a string, both in
arguments and in result.  The @func{string-upcase},
@func{string-downcase}, @func{string-titlecase}, and
@func{string-foldcase} procedures perform more general case conversion.
@end quotation
@end deffn

@deffn Procedure char-ci=? @vari{char} @varii{char} @variii{char} @dots{}
@deffnx Procedure char-ci<? @vari{char} @varii{char} @variii{char} @dots{}
@deffnx Procedure char-ci>? @vari{char} @varii{char} @variii{char} @dots{}
@deffnx Procedure char-ci<=? @vari{char} @varii{char} @variii{char} @dots{}
@deffnx Procedure char-ci>=? @vari{char} @varii{char} @variii{char} @dots{}
These procedures are similar to @func{char=?}, etc., but operate on the
case--folded versions of the characters.

@example
(char-ci<? #\z #\Z)             @result{} #f
(char-ci=? #\z #\Z)             @result{} #f
(char-ci=? #\ς #\σ)             @result{} #t
@end example
@end deffn


@deffn Procedure char-alphabetic? @var{char}
@deffnx Procedure char-numeric? @var{char}
@deffnx Procedure char-whitespace? @var{char}
@deffnx Procedure char-upper-case? @var{char}
@deffnx Procedure char-lower-case? @var{char}
@deffnx Procedure char-title-case? @var{char}
These procedures return @true{} if their arguments are alphabetic,
numeric, whitespace, upper--case, lower--case, or title--case
characters, respectively; otherwise they return @false{}.

A character is alphabetic if it has the Unicode ``Alphabetic'' property.
A character is numeric if it has the Unicode ``Numeric'' property.  A
character is whitespace if has the Unicode ``White_Space'' property.  A
character is upper case if it has the Unicode ``Uppercase'' property,
lower case if it has the ``Lowercase'' property, and title case if it is
in the Lt general category.

@example
(char-alphabetic? #\a)          @result{}  #t
(char-numeric? #\1)             @result{}  #t
(char-whitespace? #\space)      @result{}  #t
(char-whitespace? #\x00A0)      @result{}  #t
(char-upper-case? #\Σ)          @result{}  #t
(char-lower-case? #\σ)          @result{}  #t
(char-lower-case? #\x00AA)      @result{}  #t
(char-title-case? #\I)          @result{}  #f
(char-title-case? #\x01C5)      @result{}  #t
@end example
@end deffn

@deffn Procedure char-general-category @var{char}
Return a symbol representing the Unicode general category of
@var{char}, one of @code{Lu}, @code{Ll}, @code{Lt}, @code{Lm},
@code{Lo}, @code{Mn}, @code{Mc}, @code{Me}, @code{Nd}, @code{Nl},
@code{No}, @code{Ps}, @code{Pe}, @code{Pi}, @code{Pf}, @code{Pd},
@code{Pc}, @code{Po}, @code{Sc}, @code{Sm}, @code{Sk}, @code{So},
@code{Zs}, @code{Zp}, @code{Zl}, @code{Cc}, @code{Cf}, @code{Cs},
@code{Co}, or @code{Cn}.

@example
(char-general-category #\a)         @result{} Ll
(char-general-category #\space)     @result{} Zs
(char-general-category #\x10FFFF)   @result{} Cn  
@end example
@end deffn


@subsection Strings

@deffn Procedure string-upcase @var{string}
@deffnx Procedure string-downcase @var{string}
@deffnx Procedure string-titlecase @var{string}
@deffnx Procedure string-foldcase @var{string}
These procedures take a string argument and return a string result.
They are defined in terms of Unicode's locale--independent case mappings
from Unicode scalar--value sequences to scalar--value sequences.  In
particular, the length of the result string can be different from the
length of the input string.  When the specified result is equal in the
sense of @func{string=?} to the argument, these procedures may return
the argument instead of a newly allocated string.

The @func{string-upcase} procedure converts a string to upper case;
@func{string-downcase} converts a string to lower case.  The
@func{string-foldcase} procedure converts the string to its case--folded
counterpart, using the full case--folding mapping, but without the
special mappings for Turkic languages.  The @func{string-titlecase}
procedure converts the first cased character of each word, and downcases
all other cased characters.

@example
(string-upcase "Hi")              @result{} "HI"
(string-downcase "Hi")            @result{} "hi"
(string-foldcase "Hi")            @result{} "hi"

(string-upcase "Straße")          @result{} "STRASSE"
(string-downcase "Straße")        @result{} "straße"
(string-foldcase "Straße")        @result{} "strasse"
(string-downcase "STRASSE")       @result{} "strasse"

(string-downcase "Σ")             @result{} "σ"
; Chi Alpha Omicron Sigma:
(string-upcase "ΧΑΟΣ")            @result{} "ΧΑΟΣ"
(string-downcase "ΧΑΟΣ")          @result{} "χαος"
(string-downcase "ΧΑΟΣΣ")         @result{} "χαοσς"
(string-downcase "ΧΑΟΣ Σ")        @result{} "χαος σ"
(string-foldcase "ΧΑΟΣΣ")         @result{} "χαοσσ"
(string-upcase "χαος")            @result{} "ΧΑΟΣ"
(string-upcase "χαοσ")            @result{} "ΧΑΟΣ"

(string-titlecase "kNock KNoCK")  @result{} "Knock Knock"
(string-titlecase "who's there?") @result{} "Who's There?"
(string-titlecase "r6rs")         @result{} "R6rs"
(string-titlecase "R6RS")         @result{} "R6rs"
@end example

@quotation
@emph{Note:} The case mappings needed for implementing these procedures
can be extracted from @file{UnicodeData.txt}, @file{SpecialCasing.txt},
@file{WordBreakProperty.txt} (the ``MidLetter'' property partly defines
case--ignorable characters), and @file{CaseFolding.txt} from the Unicode
Consortium.

Since these procedures are locale--independent, they may not be
appropriate for some locales.
@end quotation

@quotation
@emph{Note:} Word breaking, as needed for the correct casing of the
upper case greek sigma and for @func{string-titlecase}, is specified in
Unicode Standard Annex #29.
@end quotation

@quotation
@emph{Kawa Note:}  The implementation of @func{string-titlecase}
does not correctly handle the case where an initial character
needs to be converted to multiple characters, such as
``LATIN SMALL LIGATURE FL'' which should be converted to
the two letters @code{"Fl"}.
@end quotation
@end deffn

@deffn Procedure string-ci=? @vari{string} @varii{string} @variii{string} @dots{}
@deffnx Procedure string-ci<? @vari{string} @varii{string} @variii{string} @dots{}
@deffnx Procedure string-ci>? @vari{string} @varii{string} @variii{string} @dots{}
@deffnx Procedure string-ci<=? @vari{string} @varii{string} @variii{string} @dots{}
@deffnx Procedure string-ci>=? @vari{string} @varii{string} @variii{string} @dots{}
These procedures are similar to @func{string=?}, etc., but operate on
the case--folded versions of the strings.

@example
(string-ci<? "z" "Z")                   @result{} #f
(string-ci=? "z" "Z")                   @result{} #t
(string-ci=? "Straße" "Strasse")        @result{} #t
(string-ci=? "Straße" "STRASSE")        @result{} #t
(string-ci=? "ΧΑΟΣ" "χαοσ")             @result{} #t
@end example
@end deffn

@deffn Procedure string-normalize-nfd @var{string}
@deffnx Procedure string-normalize-nfkd @var{string}
@deffnx Procedure string-normalize-nfc @var{string}
@deffnx Procedure string-normalize-nfkc @var{string}
These procedures take a string argument and return a string result,
which is the input string normalized to Unicode normalization form D,
KD, C, or KC, respectively.  When the specified result is equal in the
sense of @func{string=?} to the argument, these procedures may return
the argument instead of a newly allocated string.

@example
(string-normalize-nfd "\xE9;")          @result{} "\x65;\x301;"
(string-normalize-nfc "\xE9;")          @result{} "\xE9;"
(string-normalize-nfd "\x65;\x301;")    @result{} "\x65;\x301;"
(string-normalize-nfc "\x65;\x301;")    @result{} "\xE9;"
@end example
@end deffn

@subsection Deprecated in-place case modification

The following functions are deprecated; they really don't
and cannot do the right thing, because in some languages
upper and lower case can use different number of characters.

@deffn Procedure string-upcase! str
@emph{Deprecated:} Destructively modify @var{str}, replacing the letters
by their upper-case equivalents.
@end deffn

@deffn Procedure string-downcase! str
@emph{Deprecated:} Destructively modify @var{str}, replacing the letters
by their upper-lower equivalents.
@end deffn

@deffn Procedure string-capitalize! str
@emph{Deprecated:} Destructively modify @var{str}, such that the letters that start a new word
are replaced by their title-case equivalents, while non-initial letters
are replaced by their lower-case equivalents.
@end deffn

@node Regular expressions, , Unicode, Characters and text
@section Regular expressions

Kawa provides @dfn{regular expressions}, which is a convenient
mechanism for matching a string against a @dfn{pattern}
and maybe replacing matching parts.

A regexp is a string that describes a pattern. A regexp matcher tries
to match this pattern against (a portion of) another string, which we
will call the text string. The text string is treated as raw text and
not as a pattern.

Most of the characters in a regexp pattern are meant to match
occurrences of themselves in the text string. Thus, the pattern ``@code{abc}''
matches a string that contains the characters ``@code{a}'', ``@code{b}'',
``@code{c}'' in succession.

In the regexp pattern, some characters act as @dfn{metacharacters},
and some character sequences act as @dfn{metasequences}. That is, they
specify something other than their literal selves. For example, in the
pattern ``@code{a.c}'', the characters ``@code{a}'' and ``@code{c}'' do stand
for themselves but the metacharacter ``@code{.}'' can match any character
(other than newline). Therefore, the pattern ``@code{a.c}'' matches an
``@code{a}'', followed by any character, followed by a ``@code{c}''.

If we needed to match the character ``@code{.}'' itself, we @dfn{escape}
it, ie, precede it with a backslash ``@code{\}''. The character sequence
``@code{\.}'' is thus a metasequence, since it doesn’t match itself but
rather just ``@code{.}''.  So, to match ``@code{a}'' followed by a literal
``@code{.}'' followed by ``@code{c}'' we use the regexp pattern
``@code{a\.c}''.  To write this as a Scheme string literal,
you need to quote the backslash, so you need to write @code{"a\\.c"}.
Kawa also allows the literal syntax @code{#/a\.c/},
which avoids the need to double the backslashes.

You can choose between two similar styles of regular expressions.
The two differ slightly in terms of which characters act as metacharacters,
and what those metacharacters mean:
@itemize
@item
Functions starting with @code{regex-} are implemented using
the @code{java.util.regex} package.
This is likely to be more efficient, has better Unicode support and
some other minor extra features, and literal syntax @code{#/a\.c/}
mentioned above.
@item
Functions starting with @code{pregexp-} are implemented in pure Scheme
using Dorai Sitaram's ``Portable Regular Expressions for Scheme'' library.
These will be portable to more Scheme implementations, including BRL,
and is available on older Java versions.
@end itemize


@subsection Java regular expressions

The syntax for regular expressions is
@uref{http://java.sun.com/javase/6/docs/api/java/util/regex/Pattern.html, documented here}.

@deffn Type regex
A compiled regular expression,
implemented as @code{java.util.regex.Pattern}.
@end deffn

@deffn Constructor regex arg
Given a regular expression pattern (as a string),
compiles it to a @code{regex} object.

@example
(regex "a\\.c")
@end example
This compiles into a pattern that matches an
``@code{a}'', followed by any character, followed by a ``@code{c}''.
@end deffn

The Scheme reader recognizes ``@code{#/}'' as the start of a
regular expression @dfn{pattern literal}, which ends with the next
un-escaped ``@code{/}''.
This has the big advantage that you don't need to double the backslashes:
@example
#/a\.c/
@end example
This is equivalent to @code{(regex "a\\.c")}, except it is
compiled at read-time.
If you need a literal ``@code{/}'' in a pattern, just escape it
with a backslash: ``@code{#/a\/c/}'' matches a ``@code{a}'',
followed by a ``@code{/}'', followed by a ``@code{c}''.

You can add single-letter @emph{modifiers} following the pattern literal.
The following modifiers are allowed:
@table @code
@item i
The modifier ``@code{i}'' cause the matching to ignore case.
For example the following pattern matches ``@code{a}'' or ``@code{A}''.
@example
#/a/i
@end example
@item m
Enables ``metaline'' mode.
Normally metacharacters ``@code{^}'' and ``@code{$}'
match at the start end end of the entire input string.
In metaline mode ``@code{^}'' and ``@code{$}'' also
match just before or after a line terminator.

Multiline mode can also be enabled by the metasequence ``@code{(?m)}''. 
@item s
Enable ``singleline'' (aka ``dot-all'') mode.
In this mode the matacharacter ``@code{.} matches any character,
including a line breaks.
This mode be enabled by the metasequence ``@code{(?s)}''.
@end table

The following functions accept a regex either as
a pattern string or a compiled @code{regex} pattern.
I.e. the following are all equivalent:
@example
(regex-match "b\\.c" "ab.cd")
(regex-match #/b\.c/ "ab.cd")
(regex-match (regex "b\\.c") "ab.cd")
(regex-match (java.util.regex.Pattern:compile "b\\.c") "ab.cd")
@end example
These all evaluate to the list @code{("b.c")}.

The following functions must be imported by doing one of:
@example
(require 'regex) ;; or
(import (kawa regex))
@end example

@deffn Procedure regex-match-positions regex string [start [end]]

The procedure @code{regex‑match‑position} takes pattern and a
text @var{string}, and returns a match if the regex matches (some part of)
the text string.

Returns @code{#f} if the regexp did not match the string;
and a list of index pairs if it did match.
@example
(regex-match-positions "brain" "bird") @result{} #f
(regex-match-positions "needle" "hay needle stack")
  @result{} ((4 . 10))
@end example

In the second example, the integers 4 and 10 identify the substring
that was matched. 4 is the starting (inclusive) index and 10 the
ending (exclusive) index of the matching substring.

@example
(substring "hay needle stack" 4 10) @result{} "needle"
@end example

In this case the return list contains only one index
pair, and that pair represents the entire substring matched by the
regexp. When we discuss subpatterns later, we will see how a single
match operation can yield a list of submatches.

@code{regex‑match‑positions} takes optional third and fourth arguments
that specify the indices of the text string within which the matching
should take place.

@example
(regex-match-positions "needle"
  "his hay needle stack -- my hay needle stack -- her hay needle stack"
  24 43)
  @result{} ((31 . 37))
@end example

Note that the returned indices are still reckoned relative to the full text string.
@end deffn

@deffn Procedure regex-match regex string [start [end]]
The procedure @code{regex‑match} is called like @code{regex‑match‑positions}
but instead of returning index pairs it returns the matching substrings:
@example
(regex-match "brain" "bird") @result{} #f
(regex-match "needle" "hay needle stack")
  @result{} ("needle")
@end example

@code{regex‑match} also takes optional third and fourth arguments,
with the same meaning as does @code{regex‑match‑positions}.
@end deffn

@deffn Procedure regex-split regex string
Takes two arguments, a @var{regex} pattern and a text @var{string},
and returns a list of substrings of the text string,
where the pattern identifies the delimiter separating the substrings.
@example
(regex-split ":" "/bin:/usr/bin:/usr/bin/X11:/usr/local/bin")
  @result{} ("/bin" "/usr/bin" "/usr/bin/X11" "/usr/local/bin")

(regex-split " " "pea soup")
  @result{} ("pea" "soup")
@end example

If the first argument can match an empty string, then the list of all
the single-character substrings is returned, plus we get
a empty strings at each end.

@example
(regex-split "" "smithereens")
@result{} => ("" "s" "m" "i" "t" "h" "e" "r" "e" "e" "n" "s" "")
@end example

(Note: This behavior is different from @code{pregexp-split}.)

To identify one-or-more spaces as the delimiter, take care to use the regexp
``@code{ +}'', not ``@code{ *}''.
@example
(regex-split " +" "split pea     soup")
  @result{} ("split" "pea" "soup")
(regex-split " *" "split pea     soup")
  @result{} ("" "s" "p" "l" "i" "t" "" "p" "e" "a" "" "s" "o" "u" "p" "")
@end example
@end deffn

@deffn Procedure regex‑replace regex string replacement
Replaces the matched portion of the text @var{string} by another a
@var{replacdement} string.
@example
(regex-replace "te" "liberte" "ty")
  @result{} "liberty"
@end example

Submatches can be used in the replacement string argument.
The replacement string can use ``@code{$@var{n}}''
as a @dfn{backreference} to refer back to the @var{n}th
submatch, ie, the substring that matched the @var{n}th
subpattern.   ``@code{$0}'' refers to the entire match.
@example
(regex-replace #/_(.+?)_/
               "the _nina_, the _pinta_, and the _santa maria_"
		"*$1*"))
  @result{} "the *nina*, the _pinta_, and the _santa maria_"
@end example
@end deffn

@deffn Procedure regex‑replace* regex string replacement
Replaces all matches in the text @var{string} by the @var{replacement} string:
@example
(regex-replace* "te" "liberte egalite fraternite" "ty")
  @result{} "liberty egality fratyrnity"
(regex-replace* #/_(.+?)_/
                "the _nina_, the _pinta_, and the _santa maria_"
                "*$1*")
  @result{} "the *nina*, the *pinta*, and the *santa maria*"
@end example
@end deffn

@deffn Procedure regex-quote pattern
Takes an arbitrary string and returns a pattern string that precisely
matches it. In particular, characters in the input string that could
serve as regex metacharacters are escaped as needed.

@example
(regex-quote "cons")
  @result{} "\Qcons\E"
@end example
@code{regex‑quote} is useful when building a composite regex
from a mix of regex strings and verbatim strings.
@end deffn

@subsection Portable Scheme regular expressions

This provides the procedures @code{pregexp}, @code{pregexp‑match‑positions},
@code{pregexp‑match}, @code{pregexp‑split}, @code{pregexp‑replace},
@code{pregexp‑replace*}, and @code{pregexp‑quote}.

Before using them, you must require them:
@example
(require 'pregexp)
@end example

These procedures have the same interface as the corresponding
@code{regex-} versions, but take slightly different pattern syntax.
The replace commands use ``@code{\}'' instead of ``@code{$}''
to indicate substitutions.
Also, @code{pregexp‑split} behaves differently from
@code{regex‑split} if the pattern can match an empty string.

See @uref{http://evalwhen.com/pregexp/index.html,here for details}.

@node Data structures, Exceptions, Characters and text, Top
@chapter Data structures

@menu
* Lists::
* Arrays::  Multi-dimensional Arrays
* Uniform vectors::
* Hash tables::
@end menu

@node Lists, Arrays, , Data structures
@section Lists

The @uref{http://srfi.schemers.org/srfi-1/srfi-1.html, SRFI-1 List Library}
is available, though not enabled by default.  To use its functions you
must @code{(require 'list-lib)} or @code{(require 'srfi-1)}.
@example
(require 'list-lib)
(iota 5 0 -0.5) @result{} (0.0 -0.5 -1.0 -1.5 -2.0)
@end example

@deffn Procedure reverse! list
The result is a list consisting of the elements of @var{list} in reverse order.
No new pairs are allocated, instead the pairs of @var{list} are re-used,
with @code{cdr} cells of @var{list} reversed in place.  Note that if @var{list}
was pair, it becomes the last pair of the reversed result.
@end deffn

@node Arrays, Uniform vectors, Lists, Data structures
@section Multi-dimensional Arrays

Arrays are heterogeneous data structures whose elements are indexed by
integer sequences of fixed length.  The length of a valid index sequence
is the rank or the number of dimensions of an array. The shape of an
array consists of bounds for each index.

The lower bound @var{b} and the upper bound @var{e} of a dimension are
exact integers with @code{(<= @var{b} @var{e})}. A valid index along the
dimension is an exact integer @var{k} that satisfies both
@code{(<= @var{b} @var{k})} and @code{(< @var{k} @var{e})}.
The length of the array along the dimension is the difference
@code{(- @var{e} @var{b})}.
The size of an array is the product of the lengths of its dimensions.

A shape is specified as an even number of exact integers. These are
alternately the lower and upper bounds for the dimensions of an array.

@deffn Procedure array? obj
Returns @code{#t} if @var{obj} is an array, otherwise returns @code{#f}.
@end deffn

@deffn Procedure shape bound ...
Returns a shape. The sequence @var{bound} ... must consist of an even number
of exact integers that are pairwise not decreasing. Each pair gives the
lower and upper bound of a dimension.
If the shape is used to specify the dimensions of an array
and @var{bound} ... is the sequence @var{b0} @var{e0} ... @var{bk} @var{ek}
... of @var{n} pairs of bounds, then a valid index to the array is any
sequence @var{j0} ... @var{jk} ... of @var{n} exact integers where
each @var{jk} satisfies @code{(<= @var{bk} @var{jk})}
and @code{(< @var{jk} @var{ek})}.

The shape of a @var{d}-dimensional array is a @var{d} * 2 array
where the element at @var{k 0} contains the lower bound for an index along
dimension @var{k} and the element at @var{k 1} contains the
corresponding upper bound, where @var{k} satisfies @code{(<=  0 @var{k})}
and @code{(< @var{k} @var{d})}.
@end deffn

@deffn Procedure make-array shape
@deffnx Procedure make-array shape obj
Returns a newly allocated array whose shape is given by@var{ shape}.
If @var{obj} is provided, then each element is initialized to it.
Otherwise the initial contents of each element is unspecified.
The array does not retain a reference to @var{shape}.
@end deffn

@deffn Procedure array shape obj ...
Returns a new array whose shape is given by @var{shape} and the initial
contents of the elements are @var{obj} ... in row major order. The array does
not retain a reference to @var{shape}.
@end deffn

@deffn Procedure array-rank array
Returns the number of dimensions of @var{array}.
@example
(array-rank
  (make-array (shape 1 2 3 4)))
@end example
Returns 2.
@end deffn

@deffn Procedure array-start array k
Returns the lower bound for the index along dimension @var{k}.
@end deffn

@deffn Procedure array-end array k
Returns the upper bound for the index along dimension @var{k}.
@end deffn

@deffn Procedure array-ref array k ...
@deffnx Procedure array-ref array index
Returns the contents of the element of @var{array} at index @var{k} ....
The sequence @var{k} ... must be a valid index to @var{array}.
In the second form, @var{index} must be either a vector or a
0-based 1-dimensional array containing @var{k} ....
@example
(array-ref (array (shape 0 2 0 3)
              'uno 'dos 'tres
              'cuatro 'cinco 'seis)
   1 0)
@end example
Returns @code{cuatro}.
@example
(let ((a (array (shape 4 7 1 2) 3 1 4)))
   (list (array-ref a 4 1)
         (array-ref a (vector 5 1))
         (array-ref a (array (shape 0 2)
                         6 1))))
@end example
Returns @code{(3 1 4)}.
@end deffn

@deffn Procedure array-set! array k ... obj
@deffnx Procedure array-set! array index obj
Stores @var{obj} in the element of @var{array} at index @var{k} ....
Returns the void value.
The sequence @var{k} ... must be a valid index to @var{array}.
In the second form, @var{index} must be either a vector or a
0-based 1-dimensional array containing @var{k} ....

@example
(let ((a (make-array
            (shape 4 5 4 5 4 5))))
   (array-set! a 4 4 4 "huuhkaja")
   (array-ref a 4 4 4))
@end example
Returns @code{"huuhkaja"}.
@end deffn

@deffn Procedure share-array array shape proc
Returns a new array of @var{shape} shape that shares elements of @var{array}
through @var{proc}. The procedure @var{proc} must implement an affine
function that returns indices of @var{array} when given indices of the
array returned by @code{share-array}.
The array does not retain a reference to @var{shape}.
@example
(define i_4
   (let* ((i (make-array
                (shape 0 4 0 4)
                0))
          (d (share-array i
                (shape 0 4)
                (lambda (k)
                   (values k k)))))
      (do ((k 0 (+ k 1)))
          ((= k 4))
         (array-set! d k 1))
      i))
@end example

Note: the affinity requirement for @var{proc} means that each value must
be a sum of multiples of the arguments passed to @var{proc}, plus a constant.

Implementation note: arrays have to maintain an internal index mapping
from indices @var{k1} ... @var{kd} to a single index into a backing vector;
the composition of this mapping and @var{proc} can be recognised
as @code{(@var{+ n0} (* @var{n1} @var{k1}) ... (* @var{nd} @var{kd}))}
by setting each index in turn to 1 and others to 0,
and all to 0 for the constant term; the composition can then be compiled
away, together with any complexity that the user introduced in their
procedure.
@end deffn

Multi-dimensional arrays are specified
by @uref{http://srfi.schemers.org/srfi-25/srfi-25.html,SRFI-25}.
In Kawa, a one-dimensional array whose lower bound is 0 is also a sequence.
Furthermore, if such an array is simple (not created @code{share-array})
it will be implemented using a @code{<vector>}.
Uniform vectors and strings are also arrays in Kawa.
For example:
@example
(share-array
 (f64vector 1.0 2.0 3.0 4.0 5.0 6.0)
 (shape 0 2 0 3)
 (lambda (i j) (+ (* 2 i) j)))
@end example
evaluates to a two-dimensionsal array of @code{<double>}:
@example
#2a((1.0 2.0 3.0) (3.0 4.0 5.0))
@end example

@node Uniform vectors, Hash tables, Arrays, Data structures
@section Uniform vectors

Uniform vectors are vectors whose elements are of the same numeric type.
The are defined by @uref{http://srfi.schemers.org/srfi-4/srfi-4.html,SRFI-4}.
However, the type names (such as @code{s8vector}) are a Kawa extension.

@deffn Type s8vector
The type of uniform vectors where each element can contain
a signed 8-bit integer.  Represented using an array of @code{byte}.
@end deffn

@deffn Type u8vector
The type of uniform vectors where each element can contain
an unsigned 8-bit integer.  Represented using an array of @code{<byte>},
but each element is treated as if unsigned.
@end deffn

@deffn Type s16vector
The type of uniform vectors where each element can contain
a signed 16-bit integer.  Represented using an array of @code{short}.
@end deffn

@deffn Type u16vector
The type of uniform vectors where each element can contain
an unsigned 16-bit integer.  Represented using an array of @code{short},
but each element is treated as if unsigned.
@end deffn

@deffn Type s32vector
The type of uniform vectors where each element can contain
a signed 32-bit integer.  Represented using an array of @code{int}.
@end deffn

@deffn Type u32vector
The type of uniform vectors where each element can contain
an unsigned 32-bit integer.  Represented using an array of @code{int},
but each element is treated as if unsigned.
@end deffn

@deffn Type s64vector
The type of uniform vectors where each element can contain
a signed 64-bit integer.  Represented using an array of @code{long}.
@end deffn

@deffn Type u64vector
The type of uniform vectors where each element can contain
an unsigned 64-bit integer.  Represented using an array of @code{long},
but each element is treated as if unsigned.
@end deffn

@deffn Type f32vector
The type of uniform vectors where each element can contain
a 32-bit floating-point real.  Represented using an array of @code{float}.
@end deffn

@deffn Type f64vector
The type of uniform vectors where each element can contain
a 64-bit floating-point real.  Represented using an array of @code{double}.
@end deffn

@deffn Procedure s8vector? value
@deffnx Procedure u8vector? value
@deffnx Procedure s16vector? value
@deffnx Procedure u16vector? value
@deffnx Procedure s32vector? value
@deffnx Procedure u32vector? value
@deffnx Procedure s64vector? value
@deffnx Procedure u64vector? value
@deffnx Procedure f32vector? value
@deffnx Procedure f64vector? value
Return true iff @var{value} is a uniform vector of the specified type.
@end deffn

@deffn Procedure make-s8vector n [value]
@deffnx Procedure make-u8vector n [value]
@deffnx Procedure make-s16vector n [value]
@deffnx Procedure make-u16vector n [value]
@deffnx Procedure make-s32vector n [value]
@deffnx Procedure make-u32vector n [value]
@deffnx Procedure make-s64vector n [value]
@deffnx Procedure make-u64vector n [value]
@deffnx Procedure make-f32vector n [value]
@deffnx Procedure make-f64vector n [value]
Create a new uniform vector of the specified type,
having room for @var{n} elements.
Initialize each element to @var{value} if it is specified; zero otherwise.
@end deffn

@deffn Constructor s8vector value ...
@deffnx Constructor u8vector value ...
@deffnx Constructor s16vector value ..
@deffnx Constructor u16vector value ...
@deffnx Constructor s32vector value ...
@deffnx Constructor u32vector value ...
@deffnx Constructor s64vector value ...
@deffnx Constructor u64vector value ...
@deffnx Constructor f32vector value ...
@deffnx Constructor f64vector value ...
Create a new uniform vector of the specified type,
whose length is the number of @var{value}s specified,
and initialize it using those @var{value}s.
@end deffn

@deffn Procedure s8vector-length v
@deffnx Procedure u8vector-length v
@deffnx Procedure s16vector-length v
@deffnx Procedure u16vector-length v
@deffnx Procedure s32vector-length v
@deffnx Procedure u32vector-length v
@deffnx Procedure s64vector-length v
@deffnx Procedure u64vector-length v
@deffnx Procedure f32vector-length v
@deffnx Procedure f64vector-length v
Return the length (in number of elements) of the uniform vector @var{v}.
@end deffn

@deffn Procedure s8vector-ref v i
@deffnx Procedure u8vector-ref v i
@deffnx Procedure s16vector-ref v i
@deffnx Procedure u16vector-ref v i
@deffnx Procedure s32vector-ref v i
@deffnx Procedure u32vector-ref v i
@deffnx Procedure s64vector-ref v i
@deffnx Procedure u64vector-ref v i
@deffnx Procedure f32vector-ref v i
@deffnx Procedure f64vector-ref v i
Return the element at index @var{i} of the uniform vector @var{v}.
@end deffn

@deffn Procedure s8vector-set! v i x
@deffnx Procedure u8vector-set! v i x
@deffnx Procedure s16vector-set! v i x
@deffnx Procedure u16vector-set! v i x
@deffnx Procedure s32vector-set! v i x
@deffnx Procedure u32vector-set! v i x
@deffnx Procedure s64vector-set! v i x
@deffnx Procedure u64vector-set! v i x
@deffnx Procedure f32vector-set! v i x
@deffnx Procedure f64vector-set! v i x
Set the element at index @var{i} of uniform vector @var{v}
to the value @var{x}, which must be a number coercible
to the appropriate type.
@end deffn

@deffn Procedure s8vector->list v
@deffnx Procedure u8vector->list v
@deffnx Procedure s16vector->list v
@deffnx Procedure u16vector->list v
@deffnx Procedure s32vector->list v
@deffnx Procedure u32vector->list v
@deffnx Procedure s64vector->list v
@deffnx Procedure u64vector->list v
@deffnx Procedure f32vector->list v
@deffnx Procedure f64vector->list v
Convert the uniform vetor @var{v} to a list containing the elments of @var{v}.
@end deffn

@deffn Procedure list->s8vector l
@deffnx Procedure list->u8vector l
@deffnx Procedure list->s16vector l
@deffnx Procedure list->u16vector l
@deffnx Procedure list->s32vector l
@deffnx Procedure list->u32vector l
@deffnx Procedure list->s64vector l
@deffnx Procedure list->u64vector l
@deffnx Procedure list->f32vector l
@deffnx Procedure list->f64vector l
Create a uniform vector of the appropriate type, initializing it
with the elements of the list @var{l}.  The elements of @var{l}
must be numbers coercible the new vector's element type.
@end deffn

@subsection Relationship with Java arrays

Each uniform array type is implemented as an @dfn{underlying Java array},
and a length field.
The underlying type is
@code{byte[]} for @code{u8vector} or @code{s8vector};
@code{short[]} for @code{u16vector} or @code{u16vector};
@code{int[]} for @code{u32vector} or @code{s32vector};
@code{long[]} for @code{u64vector} or @code{s64vector};
@code{float[]} for @code{f32vector}; and
@code{double[]} for @code{f32vector}.
The length field allows a uniform array to only use the
initial part of the underlying array.  (This can be used
to support Common Lisp's fill pointer feature.)
This also allows resizing a uniform vector.  There is no
Scheme function for this, but you can use the @code{setSize} method:
@example
(invoke some-vector 'setSize 200)
@end example

If you have a Java array, you can create a uniform vector
sharing with the Java array:
@example
(define arr :: byte[] ((primitive-array-new byte) 10))
(define vec :: u8vector (make u8vector arr))
@end example
At this point @code{vec} uses @code{arr} for its underlying storage,
so changes to one affect the other.
It @code{vec} is re-sized so it needs a larger underlying array,
then it will no longer use @code{arr}.

@node Hash tables, , Uniform vectors, Data structures
@section Hash tables

A @dfn{hashtable} is a data structure that
associates keys with values.
The hashtable has no intrinsic order for the (key, value) associations
it contains, and
supports in-place modification as the primary means of setting the contents
of a hash table.
Any object can be used as a key, provided a @dfn{hash function} and a suitable
@dfn{equivalence function} is available.
A hash function is a procedure that
maps keys to exact integer objects.

The hashtable provides key lookup and destructive update in amortised
constant time, provided that a good hash function is used. 
A hash function @var{h} is acceptable for an equivalence predicate @var{e} iff
@code{(@var{e} @var{obj1} @var{obj2})} implies
@code{(= (@var{h} @var{obj1}) (@var{h} @var{obj2}))}.
A hash function @var{h} is good for a equivalence predicate @var{e} if
it distributes the resulting hash values for non-equal objects
(by @var{e}) as uniformly as possible over the range of hash
values, especially in the case when some (non-equal) objects resemble
each other by e.g. having common subsequences. This definition is
vague but should be enough to assert that e.g. a constant function is
not a good hash function.

Kawa provides two complete sets of functions for hashtables:
@itemize
@item
The functions specified by R6RS have names starting with @code{hashtable-}
@item
The functions specified by the older
@uref{http://srfi.schemers.org/srfi-69/srfi-69.html, SRFI-69} specifiation
have names starting with @code{hash-table-}
@end itemize

Both interfaces use the same underlying datatype, so it is possible 
to mix and match from both sets.
That datatype implements @code{java.util.Map}.
@c The Kawa implementation has been optimized for performance and better
@c Java integration.  Specifically, the default hash function uses
@c the standard Java @code{hashCode} method.
Freshly-written code should probably use the R6RS functions.

@subsection R6RS hash tables

To use these hash table functions in your Kawa program you must first:

@example
(import (rnrs hashtables))
@end example

This section uses the @var{hashtable} parameter name for arguments that
must be hashtables, and the @var{key} parameter name for arguments that
must be hashtable keys.

@deffn Procedure make-eq-hashtable
@deffnx Procedure make-eq-hashtable @var{k}
Return a newly allocated mutable hashtable that accepts arbitrary
objects as keys, and compares those keys with @func{eq?}.  If an
argument is given, the initial capacity of the hashtable is set to
approximately @var{k} elements.
@end deffn


@deffn Procedure make-eqv-hashtable
@deffnx Procedure make-eqv-hashtable @var{k}
Return a newly allocated mutable hashtable that accepts arbitrary
objects as keys, and compares those keys with @func{eqv?}.  If an
argument is given, the initial capacity of the hashtable is set to
approximately @var{k} elements.
@end deffn

@deffn Procedure make-hashtable @var{hash-function} @var{equiv}
@deffnx Procedure make-hashtable @var{hash-function} @var{equiv} @var{k}
@var{hash-function} and @var{equiv} must be procedures.
@var{hash-function} should accept a key as an argument and should return
a non--negative exact integer object.  @var{equiv} should accept two
keys as arguments and return a single value.  Neither procedure should
mutate the hashtable returned by @func{make-hashtable}.

The @func{make-hashtable} procedure returns a newly allocated mutable
hashtable using @var{hash-function} as the hash function and @var{equiv}
as the equivalence function used to compare keys.  If a third argument
is given, the initial capacity of the hashtable is set to approximately
@var{k} elements.

Both @var{hash-function} and @var{equiv} should behave like pure
functions on the domain of keys.  For example, the @func{string-hash}
and @func{string=?} procedures are permissible only if all keys are
strings and the contents of those strings are never changed so long as
any of them continues to serve as a key in the hashtable.  Furthermore,
any pair of keys for which @var{equiv} returns true should be hashed to
the same exact integer objects by @var{hash-function}.

@quotation
@emph{Note:} Hashtables are allowed to cache the results of calling the
hash function and equivalence function, so programs cannot rely on the
hash function being called for every lookup or update.  Furthermore any
hashtable operation may call the hash function more than once.
@end quotation
@end deffn

@subsubsection Procedures

@deffn Procedure {hashtable?} @var{obj}
Return @true{} if @var{obj} is a hashtable, @false{} otherwise.
@end deffn

@deffn Procedure hashtable-size @var{hashtable}
Return the number of keys contained in @var{hashtable} as an exact
integer object.
@end deffn

@deffn Procedure hashtable-ref @var{hashtable} @var{key} @var{default}
Return the value in @var{hashtable} associated with @var{key}.  If
@var{hashtable} does not contain an association for @var{key},
@var{default} is returned.
@end deffn

@deffn Procedure {hashtable-set!} @var{hashtable} @var{key} @var{obj}
Change @var{hashtable} to associate @var{key} with @var{obj}, adding a
new association or replacing any existing association for @var{key}, and
returns unspecified values.
@end deffn

@deffn Procedure {hashtable-delete!} @var{hashtable} @var{key}
Remove any association for @var{key} within @var{hashtable} and returns
unspecified values.
@end deffn

@deffn Procedure {hashtable-contains?} @var{hashtable} @var{key}
Return @true{} if @var{hashtable} contains an association for @var{key},
@false{} otherwise.
@end deffn

@deffn Procedure {hashtable-update!} @var{hashtable} @var{key} @var{proc} @var{default}
@var{proc} should accept one argument, should return a single value, and
should not mutate @var{hashtable}.

The @func{hashtable-update!} procedure applies @var{proc} to the value
in @var{hashtable} associated with @var{key}, or to @var{default} if
@var{hashtable} does not contain an association for @var{key}.  The
@var{hashtable} is then changed to associate @var{key} with the value
returned by @var{proc}.

The behavior of @func{hashtable-update!} is equivalent to the following
code, but is may be (and is in Kawa) implemented more efficiently in cases
where the implementation can avoid multiple lookups of the same key:

@example
(hashtable-set!
  hashtable key
  (proc (hashtable-ref
         hashtable key default)))
@end example
@end deffn


@deffn Procedure hashtable-copy @var{hashtable}
@deffnx Procedure hashtable-copy @var{hashtable} @var{mutable}
Return a copy of @var{hashtable}.  If the @var{mutable} argument is
provided and is true, the returned hashtable is mutable; otherwise it is
immutable.
@end deffn

@deffn Procedure {hashtable-clear!} @var{hashtable}
@deffnx Procedure {hashtable-clear!} @var{hashtable} @var{k}
Remove all associations from @var{hashtable} and returns unspecified
values.

If a second argument is given, the current capacity of the hashtable is
reset to approximately @var{k} elements.
@end deffn

@deffn Procedure hashtable-keys @var{hashtable}
Return a vector of all keys in @var{hashtable}.  The order of the vector
is unspecified.
@end deffn

@deffn Procedure hashtable-entries @var{hashtable}
Return two values, a vector of the keys in @var{hashtable}, and a vector
of the corresponding values.

Example:

@example
(let ((h (make-eqv-hashtable)))
  (hashtable-set! h 1 'one)
  (hashtable-set! h 2 'two)
  (hashtable-set! h 3 'three)
  (hashtable-entries h))
@result{} #(1 2 3) #(one two three) ; two return values
@end example

@noindent
the order of the entries in the result vectors is not known.
@end deffn

@subsubsection Inspection

@deffn Procedure hashtable-equivalence-function @var{hashtable}
Return the equivalence function used by @var{hashtable} to compare keys.
For hashtables created with @func{make-eq-hashtable} and
@func{make-eqv-hashtable}, returns @func{eq?} and @func{eqv?}
respectively.
@end deffn

@deffn Procedure hashtable-hash-function @var{hashtable}
Return the hash function used by @var{hashtable}.  For hashtables
created by @func{make-eq-hashtable} or @func{make-eqv-hashtable},
@false{} is returned.
@end deffn

@deffn Procedure {hashtable-mutable?} @var{hashtable}
Return @true{} if @var{hashtable} is mutable, otherwise @false{}.
@end deffn

@subsubsection Hash functions

The @func{equal-hash}, @func{string-hash}, and @func{string-ci-hash}
procedures of this section are acceptable as the hash functions of a
hashtable only if the keys on which they are called are not mutated
while they remain in use as keys in the hashtable.

@deffn Procedure equal-hash @var{obj}
Return an integer hash value for @var{obj}, based on its structure and
current contents.  This hash function is suitable for use with
@func{equal?} as an equivalence function.
@quotation
@emph{Note:} Like @func{equal?}, the @func{equal-hash} procedure must
always terminate, even if its arguments contain cycles.
@end quotation
@end deffn

@deffn Procedure string-hash @var{string}
Return an integer hash value for @var{string}, based on its current
contents.  This hash function is suitable for use with @func{string=?}
as an equivalence function.
@end deffn

@deffn Procedure string-ci-hash @var{string}
Return an integer hash value for @var{string} based on its current
contents, ignoring case.  This hash function is suitable for use with
@func{string-ci=?} as an equivalence function.
@end deffn

@deffn Procedure symbol-hash @var{symbol}
Return an integer hash value for @var{symbol}.
@end deffn


@subsection SRFI-69 hash tables

To use these hash table functions in your Kawa program you must first:
@example
(require 'srfi-69)
@end example
or
@example
(require 'hash-table)
@end example
or
@example
(import (srfi :69 basic-hash-tables))
@end example

@subsubsection Type constructors and predicate
@deffn Procedure make-hash-table [ equal? [ hash [ size-hint]]] → hash-table

Create a new hash table with no associations.
The @var{equal?} parameter is a predicate
that should accept two keys and return a boolean telling whether they
denote the same key value; it defaults to the @code{equal?} function.

The @var{hash} parameter is a hash function, and defaults to an 
appropriate hash function
for the given @var{equal?} predicate (see the Hashing section).
However, an
acceptable default is not guaranteed to be given for any equivalence
predicate coarser than @code{equal?}, except for @code{string-ci=?}.
(The function @code{hash} is acceptable for @code{equal?}, so if you
use coarser equivalence than @code{equal?} other than @code{string-ci=?},
you must always provide the function hash yourself.)
(An equivalence predicate @var{c1} is coarser than a equivalence
predicate @var{c2} iff there exist values @var{x} and @var{y} such
that @code{(and (@var{c1} @var{x} @var{y}) (not (@var{c2} @var{x} @var{y})))}.)

The @var{size-hint} parameter can be used to suggested an approriate
initial size.  This option is not part of the SRFI-69 specification
(though it is handled by the reference implementation), so specifying
that option might be unportable.
@end deffn

@deffn Procedure hash-table? obj → boolean
A predicate to test whether a given object @var{obj} is a hash table.
@end deffn

@deffn Procedure alist->hash-table alist [ equal? [ hash [ size-hint]]] → hash-table

Takes an association list @var{alist} and creates a hash table
@var{hash-table} which maps the @code{car} of every element in
@var{alist} to the @code{cdr} of corresponding elements in
@var{alist}. The @var{equal?}, @var{hash}, and @var{size-hint}
parameters are interpreted as in @code{make-hash-table}. If some key
occurs multiple times in @var{alist}, the value in the first
association will take precedence over later ones. (Note: the choice of
using @code{cdr} (instead of @code{cadr}) for values tries to strike
balance between the two approaches: using @var{cadr} would render this
procedure unusable for @code{cdr} alists, but not vice versa.)
@end deffn

@subsubsection Reflective queries
@deffn Procedure hash-table-equivalence-function hash-table
Returns the equivalence predicate used for keys of @var{hash-table}.
@end deffn

@deffn Procedure hash-table-hash-function hash-table
Returns the hash function used for keys of @var{hash-table}.
@end deffn

@subsubsection Dealing with single elements
@deffn Procedure hash-table-ref hash-table key [ thunk ] → value
This procedure returns the value associated to @var{key} in
@var{hash-table}. If no value is associated to @var{key} and
@var{thunk} is given, it is called with no arguments and its value is
returned; if @var{thunk} is not given, an error is signalled. Given a
good hash function, this operation should have an (amortised) complexity
of O(1) with respect to the number of associations in @var{hash-table}.
@end deffn

@deffn Procedure hash-table-ref/default hash-table key default → value
Evaluates to the same value as @code{(hash-table-ref @var{hash-table}
@var{key} (lambda () @var{default}))}. Given a good hash function, this
operation should have an (amortised) complexity of O(1) with respect
to the number of associations in hash-table.
@end deffn

@deffn Procedure hash-table-set! hash-table key value → void
This procedure sets the value associated to @var{key} in
@var{hash-table}. The previous association (if any) is removed. Given
a good hash function, this operation should have an (amortised)
complexity of O(1) with respect to the number of associations in
hash-table.
@end deffn

@deffn Procedure hash-table-delete! hash-table key → void
This procedure removes any association to @var{key} in
@var{hash-table}. It is not an error if no association for the
@var{key} exists; in this case, nothing is done. Given a good hash
function, this operation should have an (amortised) complexity of O(1)
with respect to the number of associations in hash-table.
@end deffn

@deffn Procedure hash-table-exists? hash-table key → boolean
This predicate tells whether there is any association to @var{key} in
@var{hash-table}. Given a good hash function, this operation should
have an (amortised) complexity of O(1) with respect to the number of
associations in hash-table.
@end deffn

@deffn Procedure hash-table-update! hash-table key function [ thunk ] → void
Semantically equivalent to, but may be implemented more efficiently than,
the following code:
@example
(hash-table-set! @var{hash-table key}
                 (function (hash-table-ref @var{hash-table} @var{key} @var{thunk})))
@end example
@end deffn

@deffn Procedure hash-table-update!/default hash-table key function default → void
Behaves as if it evaluates to
@code{(hash-table-update! @var{hash-table} @var{key} @var{function} (lambda () @var{default}))}.
@end deffn

@subsubsection Dealing with the whole contents

@deffn Procedure hash-table-size hash-table → integer
Returns the number of associations in @var{hash-table}. This operation takes
constant time.
@end deffn

@deffn Procedure hash-table-keys hash-table → list
Returns a list of keys in @var{hash-table}.
The order of the keys is unspecified.
@end deffn

@deffn Procedure hash-table-values hash-table → list
Returns a list of values in @var{hash-table}. The order of the values is
unspecified, and is not guaranteed to match the order of keys in the
result of @code{hash-table-keys}.
@end deffn

@deffn Procedure hash-table-walk hash-table proc → void
@var{proc} should be a function taking two arguments, a key and a
value. This procedure calls @var{proc} for each association in
@var{hash-table}, giving the key of the association as key and the
value of the association as value. The results of @var{proc} are
discarded. The order in which @var{proc} is called for the different
associations is unspecified.
@end deffn

@deffn Procedure hash-table-fold hash-table f init-value → final-value
This procedure calls @var{f} for every association in @var{hash-table}
with three arguments: the key of the association key, the value of the
association value, and an accumulated value, @var{val}. The @var{val}
is @var{init-value} for the first invocation of @var{f}, and for
subsequent invocations of @var{f}, the return value of the previous
invocation of @var{f}. The value @var{final-value} returned by
@code{hash-table-fold} is the return value of the last invocation of
@var{f}. The order in which @var{f} is called for different
associations is unspecified.
@end deffn

@deffn Procedure hash-table->alist hash-table → alist
Returns an association list such that the @code{car} of each element
in @var{alist} is a key in @var{hash-table} and the corresponding
@code{cdr} of each element in @var{alist} is the value associated to
the key in @var{hash-table}. The order of the elements is unspecified.

The following should always produce a hash table with the same mappings
as a hash table @var{h}:
@example
(alist->hash-table (hash-table->alist @var{h})
                        (hash-table-equivalence-function @var{h})
                        (hash-table-hash-function @var{h}))
@end example
@end deffn

@deffn Procedure hash-table-copy hash-table → hash-table
Returns a new hash table with the same equivalence predicate, hash
function and mappings as in @var{hash-table}.
@end deffn

@deffn Procedure hash-table-merge! hash-table1 hash-table2 → hash-table
Adds all mappings in @var{hash-table2} into @var{hash-table1} and
returns the resulting hash table. This function may modify
@var{hash-table1} destructively.
@end deffn

@subsubsection Hash functions

The Kawa implementation always calls these hash functions with a single
parameter, and expects the result to be within the entire
(32-bit signed) @code{int} range, for compatibility with
standard @code{hashCode} methods.

@deffn Procedure hash object [ bound ] → integer
Produces a hash value for object in the range from 0 (inclusive) tp to
@var{bound} (exclusive).

If @var{bound} is not given, the Kawa implementation returns a value within
the range @w{@code{(- (expt 2 32))}} (inclusive)
to @w{@code{(- (expt 2 32) 1)}} (inclusive).
It does this by calling the standard @code{hashCode} method,
and returning the result as is.
(If the @var{object} is the Java @code{null} value, 0 is returned.)
This hash function is acceptable for @code{equal?}.
@end deffn

@deffn Procedure string-hash string [ bound ] → integer
The same as @code{hash}, except that the argument string must be a string.
(The Kawa implementation returns the same as the @code{hash} function.)
@end deffn

@deffn Procedure string-ci-hash string [ bound ] → integer
The same as @code{string-hash}, except that the case of characters in
string does not affect the hash value produced.
(The Kawa implementation returns the same the @code{hash} function
applied to the lower-cased @var{string}.)
@end deffn

@deffn Procedure hash-by-identity object [ bound ] → integer
The same as @code{hash}, except that this function is only guaranteed
to be acceptable for @code{eq?}.
Kawa uses the @code{identityHashCode} method of @code{java.lang.System}.
@end deffn 

@node Exceptions, Eval and Environments, Data structures, Top
@chapter Exception handling

@deffn Procedure catch key thunk handler
Invoke @var{thunk} in the dynamic context of @var{handler} for
exceptions matching @var{key}.  If thunk throws to the symbol @var{key},
then @var{handler} is invoked this way:

@example
(handler key args ...)
@end example

@var{key} may be a symbol.  The @var{thunk} takes no
arguments.  If @var{thunk} returns normally, that is the return value of
@code{catch}.

Handler is invoked outside the scope of its own @code{catch}.  If
@var{handler} again throws to the same key, a new handler from further
up the call chain is invoked.

If the key is @code{#t}, then a throw to @emph{any} symbol will match
this call to @code{catch}.
@end deffn

@deffn Procedure throw key &rest args ...
Invoke the catch form matching @var{key}, passing @var{args} to the
@var{handler}.  

If the key is a symbol it will match catches of the same
symbol or of #t.

If there is no handler at all, an error is signaled.
@end deffn

@deffn procedure error message args ...
Raise an error with key @code{misc-error} and a message constructed by
displaying @var{msg} and writing @var{args}.
This normally prints a stack trace, and brings you back to
the top level, or exits kawa if you are not running interactively.
This procedure is part of SRFI-23, and other Scheme implementations.
@end deffn

@deffn Procedure primitive-throw exception
Throws the @var{exception}, which must be an instance of a sub-class
of @code{<java.lang.Throwable>}.
@end deffn

@deffn Syntax try-finally body handler
Evaluate @var{body}, and return its result.
However, before it returns, evaluate @var{handler}.
Even if @var{body} returns abnormally (by throwing an exception),
@var{handler} is evaluated.

(This is implemented just like Java's @code{try}-@code{finally}.)
@end deffn

@deffn Syntax try-catch body handler ...
Evaluate @var{body}, in the context of the given @var{handler} specifications.
Each @var{handler} has the form:
@example
@var{var} @var{type} @var{exp} ...
@end example
If an exception is thrown in @var{body}, the first @var{handler}
is selected such that the thrown exception is an instance of
the @var{handler}'s @var{type}. If no @var{handler} is selected,
the exception is propagated through the dynamic execution context
until a matching @var{handler} is found.  (If no matching @var{handler}
is found, then an error message is printed, and the computation terminated.)

Once a @var{handler} is selected,
the @var{var} is bound to the thrown exception, and the @var{exp} in
the @var{handler} are executed.  The result of the @code{try-catch}
is the result of @var{body} if no exception is thrown, or the
value of the last @var{exp} in the selected @var{handler} if an
exception is thrown.

(This is implemented just like Java's @code{try}-@code{catch}.)
@end deffn

@deffn Procedure dynamic-wind in-guard thunk out-guard
All three arguments must be 0-argument procedures.
First calls @var{in-guard}, then @var{thunk}, then @var{out-guard}.
The result of the expression is that of @var{thunk}.
If @var{thunk} is exited abnormally (by throwing an exception or
invoking a continuation), @var{out-guard} is called.

If the continuation of the dynamic-wind is re-entered (which
is not yet possible in Kawa), the @var{in-guard} is called again.

This function was added in R5RS.
@end deffn

@node Eval and Environments, Debugging, Exceptions, Top
@chapter Eval and Environments

@deffn Procedure eval expression [environment]
@code{eval} evaluates @var{expression} in the environment indicated
by @var{environment}.

The default for @var{environment} is the result
of @code{(interaction-environment)}.
@end deffn

@deffn Procedure null-environment version
This procedure returns an environment that contains no variable bindings,
but contains (syntactic) bindings for all the syntactic keywords.

The effect of assigning to a variable in this environment (such
as @code{let}) is undefined.
@end deffn

@deffn Procedure scheme-report-environment version
The @var{version} must be an exact non-negative inetger corresponding to
a version of one of the Revised@var{version} Reports on Scheme.
The procedure returns an environment that contains exactly the set of
bindings specified in the corresponding report.

This implementation supports @var{version} that is 4 or 5.

The effect of assigning to a variable in this environment (such
as @code{car}) is undefined.
@end deffn

@deffn Procedure interaction-environment
This procedure return an environment that contains implementation-defined
bindings, as well as top-level user bindings.
@end deffn

@deffn Procedure environment-bound? environment symbol
Return true @code{#t} if there is a binding for @var{symbol}
in @var{environment};  otherwise returns @code{#f}.
@end deffn

@deffn Syntax fluid-let ((variable init) ...) body ...
Evaluate the @var{init} expressions.
Then modify the dynamic bindings for the @var{variables} to the
values of the @var{init} expressions, and evaluate the @var{body} expressions.
Return the result of the last expression in @var{body}.
Before returning, restore the original bindings.
The temporary bindings are only visible in the current thread, and its
descendent threads.
@end deffn

@deffn Procedure base-uri [node]
If @var{node} is specified, returns the base-URI property
of the @var{node}.  If the @var{node} does not have the base-URI
property, returns @code{#f}.
(The XQuery version returns the empty sequence in that case.)

In the zero-argument case, returns the "base URI" of the current context.
By default the base URI is the current working directory (as a URL).
While a source file is @code{load}ed, the base URI is temporarily
set to the URL of the document.
@end deffn

@deffn Procedure load path
The @var{path} can be an (absolute) URL or a filename.
Since @code{load} is a run-time function it doesn't work well
with Kawa's orientation towards compilation.
It is highly recommended that you use instead use @code{@ref{include, include}}.
@end deffn

@deffn Procedure load-relative path
Same as @code{load}, except that @var{path} is a
URI that is relative to the context's current base URI.
Since @code{load-relative} is a run-time function it doesn't work well
with Kawa's orientation towards compilation.
It is highly recommended that you use instead use @ref{include-relative, include-relative}.
@end deffn

@menu
* Locations::
* Parameter objects::
@end menu

@node Locations, Parameter objects, , Eval and Environments
@section Locations

A @dfn{location} is a place where a value can be stored.
An @dfn{lvalue} is an expression that refers to a location.
(The name "lvalue" refers to the fact that the left operand
of @code{set!} is an lvalue.)
The only kind of lvalue in standard Scheme is a @dfn{variable}.
Kawa also allows @dfn{computed lvalues}.  These are procedure
calls used in "lvalue context", such as the left operand of @code{set!}.

You can only use procedures that have an associated @dfn{setter}.
In that case, @code{(set! (f arg ...) value)}
is equivalent to @code{((setter f) arg ... value)}
Currently, only a few procedures have associated @code{setter}s,
and only builtin procedures written in Java can have @code{setter}s.

For example:
@example
(set! (car x) 10)
@end example
is equivalent to:
@example
((setter car) x 10)
@end example
which is equivalent to:
@example
(set-car! x 10)
@end example

@deffn Procedure setter procedure
Gets the "setter procedure" associated with a "getter procedure".
Equivalent to @code{(procedure-property @var{procedure} 'setter)}.
By convention, a setter procedure takes the same parameters as
the "getter" procedure, plus an extra parameter that is the
new value to be stored in the location specified by the parameters.
The expectation is that following
@code{((setter @var{proc}) @var{args} ... @var{value})} then
the value of @code{(@var{proc} @var{args} ...)} will be @var{value}.

The @code{setter} of @code{setter} can be used to set the
@code{setter} property.
For example the Scheme prologue effectively does the following:
@example
(set! (setter vector-set) vector-set!)
@end example
@end deffn

Kawa also gives you access to locations as first-class values:

@deffn Syntax location lvalue
Returns a location object for the given @var{lvalue}.
You can get its value (by applying it, as if it were a procedure),
and you can set its value (by using @code{set!} on the application).
The @var{lvalue} can be a local or global variable, or a procedure
call using a procedure that has a @code{setter}.
@example
(define x 100)
(define lx (location x))
(set! (lx) (cons 1 2)) ;; set x to (1 . 2)
(lx)  ;; returns (1 . 2)
(define lc (location (car x)))
(set! (lc) (+ 10 (lc)))
;; x is now (11 . 2)
@end example
@end deffn

@deffn Syntax define-alias variable lvalue
Define @var{variable} as an alias for @var{lvalue}.
In other words, makes it so that @code{(location @var{variable})}
is equivalent to @code{(location @var{lvalue})}.
This works both top-level and inside a function.
@end deffn

Some people might find it helpful to think of a location
as a settable @dfn{thunk}.  Others may find it useful to
think of the @code{location} syntax as similar to the C @samp{&} operator;
for the @samp{*} indirection operator, Kawa uses procedure application.

You can use @code{define-alias} to define a shorter type synonym,
similar to Java's  @code{import TypeName} (single-type-import) declaration:
@example
(define-alias StrBuf java.lang.StringBuffer)
@end example

@node Parameter objects, , Locations, Eval and Environments
@section Parameter objects

A parameter object is a procedure that is bound to a location,
and may optionally have a conversion procedure.
The procedure accepts zero or one argument.
When the procedure is called with zero arguments,
the content of the location is returned.
On a call with one argument the content of the location
is updated with the result of applying the parameter object's conversion
procedure to the argument.

Parameter objects are created with the @code{make-parameter} procedure
which takes one or two arguments. The second argument is a one
argument conversion procedure. If only one argument is passed to
make-parameter the identity function is used as a conversion
procedure.
A new location is created and asociated with the 
parameter object. The initial content of the location is the
result of applying the conversion procedure to the first argument of
make-parameter.

Note that the conversion procedure can be used for guaranteeing the
type of the parameter object's binding and/or to perform some
conversion of the value.

The @code{parameterize} special form, when given a parameter object
and a value, binds the parameter
object to a new location for the dynamic extent of its body.
The initial content of the location is the result of
applying the parameter object's conversion procedure to the value. The
@code{parameterize} special form behaves analogously to @code{let}
when binding more than one parameter object (that is the order of
evaluation is unspecified and the new bindings are only visible in the
body of the parameterize special form).

When a new thread is created using @code{future} or @code{runnable}
then the child thread shares locations with its parents.
This sharing is broken by a @code{parameterize} that changes
the location, and restored when the @code{parameterize} exits.

Note that @code{parameterize} and @code{fluid-let} have similar
binding and sharing behavior.
The difference is that @code{fluid-let} modifies locations
accessed by name, while @code{make-parameter} and @code{parameterize}
create anonymous locations accessed by calling a parameter procedure.

The R5RS procedures @code{current-input-port} and @code{current-output-port}
are parameter objects.

@deffn Procedure make-parameter init [converter]

Returns a new parameter object which is bound in the global dynamic
environment to a location containing the value returned by the call
@code{(@var{converter} @var{init})}. If the conversion procedure
converter is not specified the identity function is used instead.

The parameter object is a procedure which accepts zero or one
argument. When it is called with no argument, the content of the
location bound to this parameter object in the current dynamic
environment is returned. When it is called with one argument, the
content of the location is set to the result of the call
@code{(@var{converter} @var{arg})}, where @var{arg} is the argument
passed to the parameter object, and an unspecified value is returned.

@example
(define radix
  (make-parameter 10))

(define write-shared
  (make-parameter
    #f
    (lambda (x)
      (if (boolean? x)
          x
          (error "only booleans are accepted by write-shared")))))

(radix)           @result{}  10
(radix 2)
(radix)           @result{}  2
(write-shared 0)  gives an error

(define prompt
  (make-parameter
    123
    (lambda (x)
      (if (string? x)
          x
          (with-output-to-string (lambda () (write x)))))))

(prompt)       @result{}  "123"
(prompt ">")
(prompt)       @result{}  ">"
@end example
@end deffn

@deffn Syntax parameterize ((expr1 expr2) ...) @stxref{body}
The expressions @var{expr1} and @var{expr2} are evaluated in an
unspecified order. The value of the @var{expr1} expressions must be
parameter objects. For each @var{expr1} expression and in an
unspecified order, the local dynamic environment is extended with a
binding of the parameter object @var{expr1} to a new location whose
content is the result of the call @code{(@var{converter} @var{val})},
where @var{val} is the value of @var{expr2} and @var{converter} is the
conversion procedure of the parameter object. The resulting dynamic
environment is then used for the evaluation of @var{body} (which
refers to the R5RS grammar nonterminal of that name). The result(s) of
the parameterize form are the result(s) of the @var{body}.

@example
(radix)                                              @result{}  2
(parameterize ((radix 16)) (radix))                  @result{}  16
(radix)                                              @result{}  2

(define (f n) (number->string n (radix)))

(f 10)                                               @result{}  "1010"
(parameterize ((radix 8)) (f 10))                    @result{}  "12"
(parameterize ((radix 8) (prompt (f 10))) (prompt))  @result{}  "1010"
@end example
@end deffn

@node Debugging, Threads, Eval and Environments, Top
@chapter Debugging

@deffn Syntax trace procedure
Cause @var{procedure} to be "traced", that is debugging output will
be written to the standard error port every time @var{procedure}
is called, with the parameters and return value.

Note that Kawa will normally assume that a procedure defined with
the procedure-defining variant of @code{define} is constant,
and so it might be inlined:
@example
(define (ff x) (list x x))
(trace ff) ;; probably won't work
(ff 3)     ;; not traced
@end example
It works if you specify the @code{--no-inline} flag to Kawa.
Alternatively, you can use the variable-defining variant of @code{define}:
@example
#|kawa:1|# (define ff (lambda (x) name: 'ff (list x x)))
#|kawa:2|# (trace ff) ;; works
#|kawa:3|# (ff 3)
call to ff (3)
return from ff => (3 3)
(3 3)
@end example
Note the use of the @code{name:} procedure property to give the
anonymous @code{lambda} a name.
@end deffn

@deffn Syntax untrace procedure
Turn off tracing (debugging output) of @var{procedure}.
@end deffn

@deffn Procedure disassemble procedure
Returns a string representation of the disassembled bytecode
for @var{procedure}, when known.
@end deffn

@node Threads, Processes, Debugging, Top
@chapter Threads

There is a very preliminary interface to create parallel threads.
The interface is similar to the standard @code{delay}/@code{force},
where a thread is basically the same as a promise, except that
evaluation may be in parallel.

@deffn Syntax future expression
Creates a new thread that evaluates @var{expression}.
@end deffn

@deffn Procedure force thread
The standard @code{force} function has generalized to also work
on threads.  If waits for the thread's @var{expression} to finish
executing, and returns the result.
@end deffn

@deffn Procedure runnable function
Creates a new @code{Runnable} instance from a function.
Useful for passing the Java code that expects a @code{Runnable}.
You can get the result (a value or a thrown exception) using the
@code{getResult} method.
@end deffn

@deffn Procedure sleep time
Suspends the current thread for the specified time.
The @var{time} can be either a pure number (in secords),
or a quantity whose unit is a time unit (such as @code{10s}).
@end deffn

@node Processes, Miscellaneous, Threads, Top
@chapter Processes

@deffn Procedure command-line
Returns a nonempty list of strings. The first element is
an implementation-specific name for the running top-level
program. (For now this is just @code{"kawa"}, but it may
become something more useful in the future.)
The remaining elements are the command-line arguments,
as passed to the @code{main} method.
@end deffn

@defvar command-line-arguments
Any command-line arguments (following flags processed by Kawa itself)
are assigned to the global variable @samp{command-line-arguments},
which is a vector of strings.
@end defvar

@deffn Procedure process-command-line-assignments
Process any initial command-line options that set variables.
These have the form @code{@var{name}=@var{value}}.
Any such command-line options (at the start of the command-line)
are processed and removed from the command-line.
@example
$ kawa -- abc=123 def
#|kawa:1|# (command-line)
(kawa abc=123 def)
#|kawa:2|# (process-command-line-assignments)
#|kawa:3|# (command-line)
(kawa def)
#|kawa:4|# abc
123
@end example
This function is mostly useful for Kawa applications
compiled with the @code{--main} option.
(It is used to set XQuery @code{external} variables.)
@end deffn

@deffn Procedure exit [code]
Exits the Kawa interpreter, and ends the Java session.
The integer value @var{code} is returned to the operating
system.  If @var{code} is not specified, zero is returned,
indicating normal (non-error) termination.
If the @var{code} is @code{#f}, it
is treated as -1, which means an abnormal exit.
@end deffn

@deffn Procedure make-process command envp
Creates a @code{<java.lang.Process>} object, using the specified
@var{command} and @var{envp}.
The @var{command} is converted to an array of Java strings
(that is an object that has type @code{<java.lang.String[]>}.
It can be a Scheme vector or list (whose elements should be
Java strings or Scheme strings);  a Java array of Java strings;
or a Scheme string.  In the latter case, the command is converted
using @code{command-parse}.
The @var{envp} is process environment;  it should be either
a Java array of Java strings, or the special @code{#!null} value.
@end deffn

@deffn Procedure system command
Runs the specified @var{command}, and waits for it to finish.
Returns the return code from the command.  The return code is an integer,
where 0 conventionally means successful completion.
The @var{command} can be any of the types handled by @code{make-process}.
@end deffn

@defvar command-parse
The value of this variable should be a one-argument procedure.
It is used to convert a command from a Scheme string to a Java
array of the constituent "words".
The default binding, on Unix-like systems, returns a new command to
invoke @code{"/bin/sh" "-c"} concatenated with the command string;
on non-Unix-systems, it is bound to @code{tokenize-string-to-string-array}.
@end defvar

@deffn Procedure tokenize-string-to-string-array command
Uses a @code{java.util.StringTokenizer} to parse the @var{command} string
into an array of words.  This splits the @var{command} using spaces
to delimit words; there is no special processing for quotes or other
special characters.
(This is the same as what @code{java.lang.Runtime.exec(String)} does.)
@end deffn

@node Miscellaneous, Input-Output, Processes, Top
@chapter Miscellaneous

@deffn Procedure scheme-implementation-version
Returns the Kawa version number as a string.
@c (Compatible with slib.)
@end deffn

@defvar home-directory
A string containing the home directory of the user.
@end defvar

@deffn Procedure scheme-window [shared]
Create a read-eval-print-loop in a new top-level window.
If @var{shared} is true, it uses the same environment as the
current @code{(interaction-environment)};  if not (the default),
a new top-level environment is created.

You can create multiple top-level window that can co-exist.
They run in separate threads.
@end deffn

@deffn Syntax when condition form...
If @var{condition} is true, evaluate each @var{form} in order,
returning the value of the last one.
@end deffn

@deffn Syntax unless condition form...
If @var{condition} is false, evaluate each @var{form} in order,
returning the value of the last one.
@end deffn

@deffn Procedure vector-append @var{arg}...
Creates a new vector, containing the elements from all the @var{arg}s
appended together.   Each @var{arg} may be a vector or a list.
@end deffn

@deffn Syntax synchronized object form ...
Synchronize on the given @var{object}.  (This means getting an
exclusive lock on the object, by acquiring its @dfn{monitor}.)
Then execute the @var{form}s while holding the lock.
When the @var{form}s finish (normally or abnormally by throwing
an exception), the lock is released.
Returns the result of the last @var{form}.
Equivalent to the Java @code{synchronized} statement,
except that it may return a result.
@end deffn

@node Input-Output, Types, Miscellaneous, Top
@chapter Input, output, and file handling

Kawa has a number of useful tools for controlling input and output:

A programmable reader.

A powerful pretty-printer.

@menu
* Named output formats::
* Paths:: Paths - file name, URLs, and URIs
* Files:: File System Interface
* Resources::
* Ports::
* Format:: Formatted Output (Common-Lisp-style)
@end menu

@node Named output formats, Paths, , Input-Output
@section Named output formats

The @code{--output-format} (or @code{--format}) command-line switch
can be used to override the default format for how values are
printed on the standard output.  This format is used for values printed
by the read-eval-print interactive interface.  It is also used to
control how values are printed when Kawa evaluates a file named on the
command line (using the @code{-f} flag or a just a script name).
(It also effects applications compiled with the @code{--main} flag.)
It currently effects how values are printed by a @code{load},
though that may change.

The default format depends on the current programming language.
For Scheme, the default is @code{scheme} for read-eval-print
interaction, and @code{ignore} for files that are loaded.

The formats currently supported include the following:
@table @code
@item scheme
Values are printed in a format matching the Scheme programming language,
as if using @code{display}.  "Groups" or "elements" are written as lists.
@item readable-scheme
Like @code{scheme}, as if using @code{write}:
Values are generally printed in a way that they can
be read back by a Scheme reader.  For example, strings have quotation marks,
and character values are written like @samp{#\A}.
@item elisp
Values are printed in a format matching the Emacs Lisp programming language.
Mostly the same as @code{scheme}.
@item readable-elisp
Like @code{elisp}, but values are generally printed in a way that they can
be read back by an Emacs Lisp reader.  For example, strings have quotation
marks, and character values are written like @samp{?A}.
@item clisp
@itemx commonlisp
Values are printed in a format matching the Common Lisp programming language,
as if written by @code{princ}.
Mostly the same as @code{scheme}.
@item readable-clisp
@itemx readable-commonlisp
Like @code{clisp}, but as if written by @code{prin1}: values are generally
printed in a way that they can be read back by a Common Lisp reader.
For example, strings have quotation marks, and character values are
written like @samp{#\A}.
@item xml
@itemx xhtml
@itemx html
Values are printed in XML, XHTML, or HTML format.
This is discussed in more detail in @ref{Formatting XML}.
@item cgi
The output should be a follow the CGI standards.  I.e. assume that this
script is invoked by a web server as a CGI script/program, and that the
output should start with some response header,
followed by the actual response data.
To generate the response headers, use the @code{response-header} function.
If the @code{Content-type} response header has not been specified, and
it is required by the CGI standard, Kawa will attempt
to infer an appropriate @code{Content-type} depending on the following value.
@item ignore
Top-level values are ignored, instead of printed.
@end table

@node Paths, Resources, Named output formats, Input-Output
@section Paths - file name, URLs, and URIs

A @dfn{Path} is the name of a file or some other @dfn{resource}.
The path mechanism provides a layer of abstraction, so you can
use the same functions on either a filename or a URL/URI.
Functions that in standard Scheme take a filename
have been generalized to take a path or a path string,
as if using the @code{path} function below.  For example:
@example
(open-input-file "http://www.gnu.org/index.html")
(open-input-file (URI "ftp://ftp.gnu.org/README"))
@end example

@deffn Type path
A general path, which can be a @code{filename} or a @code{URI}.
It can be either a @code{filename} or a @code{URI}.
Represented using the abstract Java class @code{java.text.Path}.

Coercing a value to a @code{Path} is equivalent to
calling the @code{path} constructor documented below.
@end deffn

@deffn Constructor path arg
Coerces the @var{arg} to a @code{path}.
If @var{arg} is already a @code{path}, it is returned unchanged.
If @var{arg} is a @code{java.net.URI}, or a @code{java.net.URL}
then a @code{URI} value is returned.
If @var{arg} is a @code{java.io.File}, a @code{filepath} value is returned.
Otherwise, @var{arg} can be a Scheme string or a @code{java.lang.String}.
A @code{URI} value is returns if the string starts with a URI scheme
(such as @code{"http:"}),
and a @code{filepath} value is returned otherwise.
@end deffn

@deffn Predicate path? arg
True if @var{arg} is a @code{path} - i.e. an instance of a @code{gnu.text.Path}.
@end deffn

@deffn Type filepath
The name of a local file.
Represented using the Java class @code{gnu.text.FilePath},
which is a wrapper around @code{java.io.File}.
@end deffn

@deffn Predicate filepath? arg
True if @var{arg} is a @code{filepath} - i.e. an instance of
a @code{gnu.text.FilePath}.
@end deffn

@deffn Type URI
A Uniform Resource Indicator, which is a generalization of
the more familiar URL.  The general format is specified by
@uref{http://www.ietf.org/rfc/rfc2396.txt,
RFC 2396: Uniform Resource Identifiers (URI): Generic Syntax}.
Represented using the Java class @code{gnu.text.URIPath},
which is a wrapper around @code{java.net.URI}.
A URI can be a URL, or it be a relative URI.
@end deffn

@deffn Predicate URI? arg
True if @var{arg} is a @code{URI} - i.e. an instance of
a @code{gnu.text.URIPath}.
@end deffn

@deffn Type URL
A Uniform Resource Locator - a subtype of @code{URI}.
Represented using the Java class @code{gnu.text.URLPath},
which is a wrapper around a @code{java.net.URL}, in
addition to extending @code{gnu.text.URIPath}.
@end deffn

@subsection Extracting Path components

@deffn Procedure path-scheme arg
Returns the ``URI scheme'' of @var{arg} (coerced to a @code{path}) if it is
defined, or @code{#f} otherwise.  The URI scheme of a @code{filepath}
is @code{"file"} if the @code{filepath} is absolute, and @code{#f} otherwise.
@example
(path-scheme "http://gnu.org/") @result{} "http"
@end example
@end deffn

@deffn Procedure path-authority arg
Returns the authority part of @var{arg} (coerced to a @code{path}) if it is
defined, or @code{#f} otherwise.
The ``authority'' is usually the hostname, but may also include user-info
or a port-number.

@example
(path-authority "http://me@@localhost:8000/home") @result{} "me@@localhost:8000"
@end example
@end deffn

@deffn Procedure path-host arg
Returns the name name part of @var{arg} (coerced to a @code{path}) if it is
defined, or @code{#f} otherwise.

@example
(path-host "http://me@@localhost:8000/home") @result{} "localhost"
@end example
@end deffn

@deffn Procedure path-user-info arg
Returns the ``user info'' of @var{arg} (coerced to a @code{path}) if it is
specified, or @code{#f} otherwise.

@example
(path-host "http://me@@localhost:8000/home") @result{} "me"
@end example
@end deffn

@deffn Procedure path-port arg
Returns the port number of @var{arg} (coerced to a @code{path}) if it is
specified, or @code{-1} otherwise.  Even if there is a default port
associated with a URI scheme (such as 80 for @code{http}), the value
-1 is returned unless the port number is @emph{explictly} specified.

@example
(path-host "http://me@@localhost:8000/home") @result{} 8000
(path-host "http://me@@localhost/home") @result{} -1
@end example
@end deffn

@deffn Procedure path-file arg
Returns the ``path component'' of the @var{arg}
(coerced to a @code{path}).
(The name @code{path-path} might be more logical,
but it is obviously a bit awkward.)
The path component of a file name is the file name itself.
For a URI, it is the main hierarchical part of the URI,
without schema, authority, query, or fragment.
@example
(path-file "http://gnu.org/home/me.html?add-bug#body") @result{} "/home/me.html"
@end example
@end deffn

@deffn Procedure path-directory arg
If @var{arg} (coerced to a @code{path}) is directory,
return @var{arg}; otherwise return the ``parent'' path, without the
final component.
@example
(path-directory "http://gnu.org/home/me/index.html#body")
  @result{} (path "http://gnu.org/home/me/")
(path-directory "http://gnu.org/home/me/")
  @result{} (path "http://gnu.org/home/me/")
@end example
@code{(path-directory "./dir")} @code{@result{}} @code{(path "./dir")} if @code{dir} is a directory, and @code{(path ".")} otherwise.
@end deffn

@deffn Procedure path-parent arg
Returns the ``parent directory'' of @var{arg} (coerced to a @code{path}).
If @var{arg} is not a directory, same as @code{path-directory @var{arg}}.
@example
(path-parent "a/b/c") @result{} (path "a/b")
(path-parent "file:/a/b/c") @result{} (path "file:/a/b/c")
(path-parent "file:/a/b/c/") @result{} (path "file:/a/b/")
@end example
@end deffn

@deffn Procedure path-last arg
The last component of path component
of @var{arg} (coerced to a @code{path}).
Returns a substring of @code{(path-file @var{arg})}.
If that string ends with @samp{/} or the path separator,
that last character is ignored.
Returns the tail of the path-string, following
the last (non-final) @samp{/} or path separator.
@example
(path-last "http:/a/b/c") @result{} "c"
(path-last "http:/a/b/c/") @result{} "c"
(path-last "a/b/c") @result{} "c"
@end example
@end deffn

@deffn Procedure path-extension arg
Returns the ``extension'' of the @var{arg}
(coerced to a @code{path}).
@example
(path-extension "http://gnu.org/home/me.html?add-bug#body") @result{} "html"
(path-extension "/home/.init") @result{} #f
@end example
@end deffn

@deffn Procedure path-query arg
Returns the query part of @var{arg} (coerced to a @code{path}) if it is
defined, or @code{#f} otherwise.  The query part of a URI is the
part after @samp{?}.
@example
(path-query "http://gnu.org/home?add-bug") @result{} "add-bug"
@end example
@end deffn

@deffn Procedure path-fragment arg
Returns the fragment part of @var{arg} (coerced to a @code{path}) if it is
defined, or @code{#f} otherwise.  The fragment of a URI is the
part of after @samp{#}.
@example
(path-query "http://gnu.org/home#top") @result{} "top"
@end example
@end deffn

@deffn Procedure resolve-uri uri base
Returns a @var{uri} unchanged if it is an absolute URI.
Otherwise resolves it against a base URI @var{base},
which is normally (though not always) absolute.
@end deffn

@node Resources, Files, Paths, Input-Output
@section Resources

A resource is a file or other fixed data that an application may access.
Resources are part of the application and are shipped with it, but are
stored in external files.  Examples are images, sounds,
and translation (localization) of messages.
In the Java world a resource is commonly bundled in the same jar file
as the application itself.

@deffn Syntax resource-url resource-name
Returns a @code{URLPath} you can use as a @code{URL}, or
you can pass to it @code{open-input-file} to read the resource data.
The @var{resource-name} is a string which is passed to the
@code{ClassLoader} of the containing module.
If the module class is in a jar file, things will magically
work if the resource is in the same jar file, and @var{resource-name}
is a filename relative to the module class in the jar.
If the module is immediately evaluated, the @var{resource-name} is resolved
against the location of the module source file.
@end deffn

@deffn Syntax module-uri
Evaluates to a special URI that can be used to access resources
relative to the class of the containing module.
The URI has the form @code{"class-resource://@var{CurrentClass}/"}
in compiled code, to allow moving the classes/jars.
The current @code{ClassLoader} is associated with the URI, so accessing
resources using the URI will use that @code{ClassLoader}.
Therefore you should not create a @code{"class-resource:"} URI
except by using this function or @code{resolve-uri},
since that might try to use the wrong @code{ClassLoader}.

The macro @code{resource-url} works by using @code{module-uri}
and resolving that to a normal @code{URL}.
@end deffn

@node Files, Ports, Resources, Input-Output
@section File System Interface

@deffn Procedure file-exists? filename
Returns true iff the file named @var{filename} actually exists.
This function is defined on arbitrary @code{path} values:
for URI values we open a @code{URLConnection}
and invoke @code{getLastModified()}.
@end deffn

@deffn Procedure file-directory? filename
Returns true iff the file named @var{filename} actually exists
and is a directory.
This function is defined on arbitrary @code{path} values;
the default implementation for non-file objects is to
return @code{#t} iff the path string ends with the character @samp{/}.
@end deffn

@deffn Procedure file-readable? filename
Returns true iff the file named @var{filename} actually exists
and can be read from.
@end deffn

@deffn Procedure file-writable? filename
Returns true iff the file named @var{filename} actually exists
and can be writen to.
(Undefined if the @var{filename} does not exist,
but the file can be created in the directory.)
@end deffn

@deffn Procedure delete-file filename
Delete the file named @var{filename}.
On failure, throws an exception.
@end deffn

@deffn Procedure rename-file oldname newname
Renames the file named @var{oldname} to @var{newname}.
@end deffn

@deffn Procedure copy-file oldname newname-from path-to
Copy the file named @var{oldname} to @var{newname}.
The return value is unspecified.
@end deffn

@deffn Procedure create-directory dirname
Create a new directory named @var{dirname}.
Unspecified what happens on error (such as exiting file with the same name).
(Currently returns @code{#f} on error, but may change to be more compatible
with scsh.)
@end deffn

@deffn Procedure system-tmpdir
Return the name of the default directory for temporary files.
@end deffn

@deffn Procedure make-temporary-file [format]
Return a file with a name that does not match any existing file.
Use @var{format} (which defaults to @code{"kawa~d.tmp"}) to generate
a unique filename in @code{(system-tmpdir)}.
The current implementation is @emph{not} safe from race conditions;
this will be fixed in a future release (using Java2 features).
@end deffn

@node Ports, Format, Files, Input-Output
@section Ports

@deffn Procedure current-error-port
Return the port to which errors and warnings should be sent
(the @dfn{standard error} in Unix and C terminology).
@end deffn

@deffn Procedure read-line [port [handle-newline]]
Reads a line of input from @var{port}.
The @var{handle-newline} parameter determines what is done with
terminating end-of-line delimiter.
The default, @code{'trim}, ignores the delimiter;
@code{'peek} leaves the delimiter in the input stream;
@code{'concat} appends the delimiter to the returned value;
and @code{'split} returns the delimiter as a second value.
You can use the last three options to tell if the string was
terminated by end-or-line or by end-of-file.
@end deffn

@deffn Procedure open-input-string string
Takes a string and returns an input port that delivers characters
from the string. The port can be closed by @code{close-input-port},
though its storage will be reclaimed by the
garbage collector if it becomes inaccessible. 

@example
(define p
  (open-input-string "(a . (b c . ())) 34"))

(input-port? p)                 @result{}  #t
(read p)                        @result{}  (a b c)
(read p)                        @result{}  34
(eof-object? (peek-char p))     @result{}  #t
@end example
@end deffn

@deffn Procedure open-output-string
Returns an output port that will accumulate characters
for retrieval by @code{get-output-string}.
The port can be closed by the procedure @code{close-output-port},
though its storage will be reclaimed by the garbage collector
if it becomes inaccessible. 
@example
(let ((q (open-output-string))
  (x '(a b c)))
    (write (car x) q)
    (write (cdr x) q)
    (get-output-string q))        @result{}  "a(b c)"
@end example
@end deffn

@deffn Procedure get-output-string output-port
Given an output port created by @code{open-output-string},
returns a string consisting of the characters that have been
output to the port so far. 
@end deffn

@deffn Procedure call-with-input-string string proc
Create an input port that gets its data from @var{string},
call @var{proc} with that port as its one argument, and return
the result from the call of @var{proc}
@end deffn

@deffn Procedure call-with-output-string proc
Create an output port that writes its data to a @var{string},
and call @var{proc} with that port as its one argument.
Return a string consisting of the data written to the port.
@end deffn

@deffn Procedure force-output [port]
Forces any pending output on @var{port} to be delivered to the output
device and returns an unspecified value.  If the @var{port} argument is
omitted it defaults to the value returned by @code{(current-output-port)}.
@end deffn

An interactive input port has a prompt procedure associated with it.
The prompt procedure is called before a new line is read.  It is passed
the port as an argument, and returns a string, which gets printed as a prompt.

@deffn Procedure input-port-prompter port
Get the prompt procedure associated with @var{port}.
@end deffn

@deffn Procedure set-input-port-prompter! port prompter
Set the prompt procedure associated with @var{port} to @var{prompter},
which must be a one-argument procedure taking an input port,
and returning a string.
@end deffn

@deffn Procedure default-prompter port
The default prompt procedure.  It returns @code{"#|kawa:@var{L}|# "}, where
@var{L} is the current line number of @var{port}.
When reading a continuation line, the result
is @code{"#|@var{C}---:@var{L}|# "}, where @code{C} is the character returned
by @code{(input-port-read-state @var{port})}.
The prompt has the form of a comment to make it easier to cut-and-paste.
@end deffn

@deffn Function port-column input-port
@deffnx Function port-line input-port
Return the current column number or line number of @var{input-port},
using the current input port if none is specified.
If the number is unknown, the result is @code{#f}.  Otherwise,
the result is a 0-origin integer - i.e. the first character
of the first line is line 0, column 0.  (However, when you
display a file position, for example in an error message,
we recommend you add 1 to get 1-origin integers.  This is
because lines and column numbers traditionally start with
1, and that is what non-programmers will find most natural.)
@end deffn

@deffn Procedure set-port-line! port line
Set (0-origin) line number of the current line of @var{port} to @var{num}.
@end deffn

@deffn Procedure input-port-line-number port
Get the line number of the current line of @var{port},
which must be a (non-binary) input port.
The initial line is line 1.
Deprecated; replaced by @code{(+ 1 (port-line @var{port}))}.
@end deffn

@deffn Procedure set-input-port-line-number! port num
Set line number of the current line of @var{port} to @var{num}.
Deprecated;  replaced by @code{(set-port-line! @var{port} (- @var{num} 1))}.
@end deffn

@deffn Procedure input-port-column-number port 
Get the column number of the current line of @var{port}, 
which must be a (non-binary) input port.
The initial column is column 1.
Deprecated; replaced by @code{(+ 1 (port-column @var{port}))}.
@end deffn

@deffn Procedure input-port-read-state port
Returns a character indicating the current @code{read} state of the @var{port}.
Returns @code{#\Return} if not current doing a @var{read},
@code{#\"} if reading a string;  @code{#\|} if reading a comment;  @code{#\(}
if inside a list; and @code{#\Space} when otherwise in a @code{read}.
The result is intended for use by prompt prcedures, and is not necessarily
correct except when reading a new-line.
@end deffn

@defvar symbol-read-case
A symbol that controls how @code{read} handles letters when reading a symbol.
If the first letter is @samp{U}, then letters in symbols are upper-cased.
If the first letter is @samp{D} or @samp{L}, then letters
in symbols are down-cased.
If the first letter is @samp{I}, then the case of letters in symbols
is inverted.
Otherwise (the default), the letter is not changed.
(Letters following a @samp{\} are always unchanged.)
@end defvar

@defvar port-char-encoding
Controls how bytes in external files are converted to/from internal
Unicode characters.  Can be either a symbol or a boolean.
If @code{port-char-encoding} is @code{#f}, the file is assumed
to be a binary file and no conversion is done.
Otherwise, the file is a text file.  The default is @code{#t}, which
uses a locale-dependent conversion.  If @code{port-char-encoding}
is a symbol, it must be the name of a character encoding known to Java.
For all text files (that is if @code{port-char-encoding} is not @code{#f}),
on input a @code{#\Return} character or
a @code{#\Return} followed by @code{#\Newline}
are converted into plain @code{#\Newline}.

This variable is checked when the file is opened;  not when actually
reading or writing.  Here is an example of how you can safely
change the encoding temporarily:
@example
(define (open-binary-input-file name)
  (fluid-let ((port-char-encoding #f)) (open-input-file name)))
@end example
@end defvar

@defvar *print-base*
The number base (radix) to use by default when printing rational numbers.
Must be an integer between 2 and 36, and the default is of course 10.
For example setting @code{*print-base*} to 16 produces hexadecimal output.
@end defvar

@defvar *print-radix*
If true, prints an indicator of the radix used when printing rational numbers.
If @code{*print-base*} is respectively 2, 8, or 16, then
@code{#b}, @code{#o} or @code{#x} is written before the number;
otherwise @code{#@var{N}r} is written, where @code{@var{N}} is the base.
An exception is when  @code{*print-base*} is 10, in which case a period
is written @emph{after} the number, to match Common Lisp; this may
be inappropriate for Scheme, so is likely to change.
@end defvar

@defvar *print-right-margin*
The right margin (or line width) to use when pretty-printing.
@end defvar

@defvar *print-miser-width*
If this an integer, and the available width is less or equal to this value,
then the pretty printer switch to the more @dfn{miser} compact style.
@end defvar

@defvar *print-xml-indent*
When writing to XML, controls pretty-printing and indentation.
If the value is @code{'always} or  @code{'yes} force each element to
start on a new suitably-indented line.
If the value is @code{'pretty} only force new lines for elements that
won't fit completely on a line.
The the value is @code{'no} or unset, don't add extra whitespace.
@end defvar

@node Format, , Ports, Input-Output
@section Formatted Output (Common-Lisp-style)

@deffn Procedure format destination fmt . arguments
An almost complete implementation of Common LISP format description
according to the CL reference book @cite{Common LISP} from Guy L.
Steele, Digital Press.  Backward compatible to most of the available
Scheme format implementations.

Returns @code{#t}, @code{#f} or a string; has side effect of printing
according to @var{fmt}.  If @var{destination} is @code{#t},
the output is to the current output port and @code{#!void} is returned.  If
@var{destination} is @code{#f}, a formatted string is returned as the
result of the call.  If @var{destination} is a string,
@var{destination} is regarded as the format string; @var{fmt} is
then the first argument and the output is returned as a string. If
@var{destination} is a number, the output is to the current error port
if available by the implementation. Otherwise @var{destination} must be
an output port and @code{#!void} is returned.@refill

@var{fmt} must be a string or an instance of @code{gnu.text.MessageFormat}
or @code{java.text.MessageFormat}.  If @var{fmt} is a string,
it is parsed as if by @code{parse-format}.
@end deffn

@deffn Procedure parse-format format-string
Parses @code{format-string}, which is a string of the form of a Common LISP
format description.  Returns an instance of @code{gnu.text.ReportFormat},
which can be passed to the @code{format} function.
@end deffn

A format string passed to @code{format} or @code{parse-format}
consists of format directives (that start with @samp{~}),
and regular characters (that are written directly to the destination).
Most of the Common Lisp (and Slib) format directives are implemented.
Neither justification, nor pretty-printing are supported yet.

Plus of course, we need documentation for @code{format}!

@subsection Implemented CL Format Control Directives

Documentation syntax: Uppercase characters represent the corresponding
control directive characters. Lowercase characters represent control
directive parameter descriptions.

@table @asis
@cindex ~a
@item @code{~A}
Any (print as @code{display} does).
@table @asis
@item @code{~@@A}
left pad.
@item @code{~@var{mincol},@var{colinc},@var{minpad},@var{padchar}A}
full padding.
@end table
@cindex ~s
@item @code{~S}
S-expression (print as @code{write} does).
@table @asis
@item @code{~@@S}
left pad.
@item @code{~@var{mincol},@var{colinc},@var{minpad},@var{padchar}S}
full padding.
@end table

@cindex ~c
@item @code{~C}
Character.
@table @asis
@item @code{~@@C}
prints a character as the reader can understand it (i.e. @code{#\} prefixing).
@item @code{~:C}
prints a character as emacs does (eg. @code{^C} for ASCII 03).
@end table
@end table

@subsection Formatting Integers

@table @asis
@cindex ~d
@item @code{~D}
Decimal.
@table @asis
@item @code{~@@D}
print number sign always.
@item @code{~:D}
print comma separated.
@item @code{~@var{mincol},@var{padchar},@var{commachar},@var{commawidth}D}
padding.
@end table
@cindex ~x
@item @code{~X}
Hexadecimal.
@table @asis
@item @code{~@@X}
print number sign always.
@item @code{~:X}
print comma separated.
@item @code{~@var{mincol},@var{padchar},@var{commachar},@var{commawidth}X}
padding.
@end table
@cindex ~o
@item @code{~O}
Octal.
@table @asis
@item @code{~@@O}
print number sign always.
@item @code{~:O}
print comma separated.
@item @code{~@var{mincol},@var{padchar},@var{commachar},@var{commawidth}O}
padding.
@end table
@cindex ~b
@item @code{~B}
Binary.
@table @asis
@item @code{~@@B}
print number sign always.
@item @code{~:B}
print comma separated.
@item @code{~@var{mincol},@var{padchar},@var{commachar},@var{commawidth}B}
padding.
@end table
@cindex ~r
@item @code{~@var{n}R}
Radix @var{n}.
@table @asis
@item @code{~@var{n},@var{mincol},@var{padchar},@var{commachar},@var{commawidth}R}
padding.
@end table
@item @code{~@@R}
print a number as a Roman numeral.
@item @code{~:@@R}
print a number as an ``old fashioned'' Roman numeral.
@item @code{~:R}
print a number as an ordinal English number.
@item @code{~R}
print a number as a cardinal English number.
@cindex ~p
@item @code{~P}
Plural.
@table @asis
@item @code{~@@P}
prints @code{y} and @code{ies}.
@item @code{~:P}
as @code{~P but jumps 1 argument backward.}
@item @code{~:@@P}
as @code{~@@P but jumps 1 argument backward.}
@end table
@end table

@var{commawidth} is the number of characters between two comma characters.


@subsection Formatting real numbers

@table @asis
@cindex ~f
@item @code{~F}
Fixed-format floating-point (prints a flonum like @var{mmm.nnn}).
@table @asis
@item @code{~@var{width},@var{digits},@var{scale},@var{overflowchar},@var{padchar}F}
@item @code{~@@F}
If the number is positive a plus sign is printed.
@end table
@end table

@table @asis
@cindex ~e
@item @code{~E}
Exponential floating-point (prints a flonum like @var{mmm.nnn}@code{E}@var{ee})
@table @asis
@item @code{~@var{width},@var{digits},@var{exponentdigits},@var{scale},@var{overflowchar},@var{padchar},@var{exponentchar}E}
@item @code{~@@E}
If the number is positive a plus sign is printed.
@end table
@end table

@table @asis
@cindex ~g
@item @code{~G}
General floating-point (prints a flonum either fixed or exponential).
@table @asis
@item @code{~@var{width},@var{digits},@var{exponentdigits},@var{scale},@var{overflowchar},@var{padchar},@var{exponentchar}G}
@item @code{~@@G}
If the number is positive a plus sign is printed.
@end table
A slight difference from Common Lisp:  If the number is printed
in fixed form and the fraction is zero,
then a zero digit is printed for the fraction, if allowed by the @var{width}
and @var{digits} is unspecified.
@end table

@table @asis
@cindex ~$
@item @code{~$}
Dollars floating-point (prints a flonum in fixed with signs separated).
@table @asis
@item @code{~@var{digits},@var{scale},@var{width},@var{padchar}$}
@item @code{~@@$}
If the number is positive a plus sign is printed.
@item @code{~:@@$}
A sign is always printed and appears before the padding.
@item @code{~:$}
The sign appears before the padding.
@end table
@end table

@subsection Miscellaneous formatting operators

@table @asis
@cindex ~%
@item @code{~%}
Newline.
@table @asis
@item @code{~@var{n}%}
print @var{n} newlines.
@end table
@cindex ~&
@item @code{~&}
print newline if not at the beginning of the output line.
@table @asis
@item @code{~@var{n}&}
prints @code{~&} and then @var{n-1} newlines.
@end table
@cindex ~|
@item @code{~|}
Page Separator.
@table @asis
@item @code{~@var{n}|}
print @var{n} page separators.
@end table
@cindex ~~
@item @code{~~}
Tilde.
@table @asis
@item @code{~@var{n}~}
print @var{n} tildes.
@end table
@cindex ~@i{newline}
@item @code{~}<newline>
Continuation Line.
@table @asis
@item @code{~:}<newline>
newline is ignored, white space left.
@item @code{~@@}<newline>
newline is left, white space ignored.
@end table
@cindex ~t
@item @code{~T}
Tabulation.
@table @asis
@item @code{~@@T}
relative tabulation.
@item @code{~@var{colnum},@var{colinc}T}
full tabulation.
@end table
@cindex ~?
@item @code{~?}
Indirection (expects indirect arguments as a list).
@table @asis
@item @code{~@@?}
extracts indirect arguments from format arguments.
@end table
@cindex ~(
@item @code{~(@var{str}~)}
Case conversion (converts by @code{string-downcase}).
@table @asis
@item @code{~:(@var{str}~)}
converts by @code{string-capitalize}.
@item @code{~@@(@var{str}~)}
converts by @code{string-capitalize-first}.
@item @code{~:@@(@var{str}~)}
converts by @code{string-upcase}.
@end table
@cindex ~*
@item @code{~*}
Argument Jumping (jumps 1 argument forward).
@table @asis
@item @code{~@var{n}*}
jumps @var{n} arguments forward.
@item @code{~:*}
jumps 1 argument backward.
@item @code{~@var{n}:*}
jumps @var{n} arguments backward.
@item @code{~@@*}
jumps to the 0th argument.
@item @code{~@var{n}@@*}
jumps to the @var{n}th argument (beginning from 0)
@end table
@item @code{~[@var{str0}~;@var{str1}~;...~;@var{strn}~]}
Conditional Expression (numerical clause conditional).
@table @asis
@cindex ~[
@item @code{~@var{n}[}
take argument from @var{n}.
@item @code{~@@[}
true test conditional.
@item @code{~:[}
if-else-then conditional.
@cindex ~;
@item @code{~;}
clause separator.
@item @code{~:;}
default clause follows.
@end table
@item @code{~@{@var{str}~@}}
Iteration (args come from the next argument (a list)).
@table @asis
@item @code{~@var{n}@{}
at most @var{n} iterations.
@cindex ~@{
@item @code{~:@{}
args from next arg (a list of lists).
@item @code{~@@@{}
args from the rest of arguments.
@item @code{~:@@@{}
args from the rest args (lists).
@end table
@cindex ~^
@item @code{~^}
Up and out.
@table @asis
@item @code{~@var{n}^}
aborts if @var{n} = 0
@item @code{~@var{n},@var{m}^}
aborts if @var{n} = @var{m}
@item @code{~@var{n},@var{m},@var{k}^}
aborts if @var{n} <= @var{m} <= @var{k}
@end table
@end table

@subsection Unimplemented CL Format Control Directives

@table @asis
@item @code{~:A}
print @code{#f} as an empty list (see below).
@item @code{~:S}
print @code{#f} as an empty list (see below).
@item @code{~<~>}
Justification.
@item @code{~:^}
@end table

@subsection Extended, Replaced and Additional Control Directives

These are not necesasrily implemented in Kawa!

@table @asis
@item @code{~I}
print a R4RS complex number as @code{~F~@@Fi} with passed parameters for
@code{~F}.
@item @code{~Y}
Pretty print formatting of an argument for scheme code lists.
@item @code{~K}
Same as @code{~?.}
@item @code{~!}
Flushes the output if format @var{destination} is a port.
@item @code{~_}
Print a @code{#\space} character
@table @asis
@item @code{~@var{n}_}
print @var{n} @code{#\space} characters.
@end table

@item @code{~@var{n}C}
Takes @var{n} as an integer representation for a character. No arguments
are consumed. @var{n} is converted to a character by
@code{integer->char}.  @var{n} must be a positive decimal number.@refill
@item @code{~:S}
Print out readproof.  Prints out internal objects represented as
@code{#<...>} as strings @code{"#<...>"} so that the format output can always
be processed by @code{read}.
@refill
@item @code{~:A}
Print out readproof.  Prints out internal objects represented as
@code{#<...>} as strings @code{"#<...>"} so that the format output can always
be processed by @code{read}.
@refill
@item @code{~F, ~E, ~G, ~$}
may also print number strings, i.e. passing a number as a string and
format it accordingly.
@end table

@node Types, Objects Classes and Modules, Input-Output, Top
@chapter Types

A @dfn{type} is a set of values, plus an associated set of operations
valid on those values.
Types are useful for catching errors ("type-checking"), documenting
the programmer's intent, and to help the compiler generate better code.
Types in some languages (such as C) appear in programs,
but do not exist at run-time.  In such languages, all type-checking
is done at compile-time.  Other languages (such as standard Scheme)
do not have types as such, but they have @dfn{predicates}, which
allow you to check if a value is a member of certain sets;  also,
the primitive functions will check at run-time if the arguments
are members of the allowed sets.  Other languages, including Java
and Common Lisp, provide a combination:  Types may be used as specifiers
to guide the compiler, but also exist as actual run-time values.
In Java, for each class, there is a corresponding @code{java.lang.Class}
run-time object, as well as an associated type (the set of values
of that class, plus its sub-classes, plus @code{null}).

Kawa, like Java, has first-class types, that is types exist as
objects you can pass around at run-time.  For each Java type,
there is a corresponding Kawa type (but not necessarily vice
versa).  It would be nice if we could represent run-time
type values using @code{java.lang.Class} objects, but unfortunately
that does not work very well.  One reason is that we need
to be able to refer to types and classes that do not exist yet,
because we are in the processing of compiling them.  Another
reason is that we want to be able to distinuish between different
types that are implemented using the same Java class.

Various Kawa constructs require or allow a type to be specified.
Those specifications consist of @dfn{type expressions}, which
is evaluated to yield a type value.  The current Kawa compiler
is rather simple-minded, and in many places only allows simple
types that the compiler can evaluate at compile-time.
More specifically, it only allows simple @dfn{type names}
that map to primitive Java types or java classes.

@display
@stxdef{type} @stxref{expression}
@stxdef{opt-type-specifier} [@stxlit{::} @stxref{type}]
@end display

@menu
* Standard Types::
* Declaring Types of Variables::
* Type tests and conversions::
@end menu

@node Standard Types, Declaring Types of Variables, , Types
@section Standard Types

These types are predefined with the following names.

Instead if plain @code{@var{typename}} you can also use
the syntax @code{<@var{typename}>} with angle brackets,
but that syntax is no longer recommended, because it doesn't
``fit'' as well with some ways type names are used.

To find which Java classes these types map into, look in
@code{kawa/standard/Scheme.java}.

Note that the value of these variables are instances
of @code{gnu.bytecode.Type},
not (as you might at first expect) @code{java.lang.Class}.

@defvar Object
An arbitrary Scheme value - and hence an arbitrary Java object.
@end defvar

@defvar number
The type of Scheme numbers.
@end defvar

@defvar quantity
The type of quantities optionally with units.
This is a sub-type of @code{number}.
@end defvar

@defvar complex
The type of complex numbers.
This is a sub-type of @code{quantity}.
@end defvar

@defvar real
The type of real numbers.
This is a sub-type of @code{complex}.
@end defvar

@defvar rational
The type of exact rationl numbers.
This is a sub-type of @code{real}.
@end defvar

@defvar integer
The type of exact Scheme integers.
This is a sub-type of @code{rational}.
@end defvar

@defvar symbol
The type of Scheme symbols.
(Implemented using the Java class @code{gnu.mapping.Symbol}.)
(Compatibility note: Previous versions of Kawa implemented
a simple Scheme symbol using an interned @code{java.lang.String}.)
@end defvar

@defvar keyword
The type of keyword values.  @xref{Keywords}.
@end defvar

@defvar list
The type of Scheme lists (pure and impure, including the empty list).
@end defvar

@defvar pair
The type of Scheme pairs.  This is a sub-type of @code{list}.
@end defvar

@defvar string
The type of Scheme strings.
(Implemented using @code{java.lang.String} for immutable strings,
and @code{gnu.lists.FString} for mutable strings.
Both of these implement the interface @code{java.lang.CharSequence}.
In the future, we may change the representation for strings
containing ``surrogate characters'', for efficient indexing.)
(Compatibility note: Previous versions of Kawa implemented
always used @code{gnu.lists.FString}.)
@end defvar

@defvar character
The type of Scheme character values.  This is a sub-type of
@code{Object}, in contrast to type @code{char}, which is the
primitive Java @code{char} type.
@end defvar

@defvar vector
The type of Scheme vectors.
@end defvar

@defvar procedure
The type of Scheme procedures.
@end defvar

@defvar input-port
The type of Scheme input ports.
@end defvar

@defvar output-port
The type of Scheme output ports.
@end defvar

@defvar String
This type name is a special case.  It specifies the class
@code{java.lang.String}.
However, coercing a value to @code{String} is done by
invoking the @code{toString} method on the value to be coerced.
Thus it "works" for all objects.
It also works for @code{#!null}.

When Scheme code invokes a Java methods any parameter
whose type is @code{java.lang.String} is converted
as if it was declared as a @code{String}.
@end defvar

More will be added later.

A type specifier can also be one of the primitive Java types.
The numeric types @code{long}, @code{int}, @code{short},
@code{byte}, @code{float}, and @code{double} are converted from the
corresponding Scheme number classes.  Similarly, @code{char}
can be converted to and from Scheme characters.  The type
@code{boolean} matches any object, and the result is @code{false}
if and only if the actual argument is @code{#f}.
(The value @code{#f} is identical to @code{Boolean.FALSE},
and @code{#t} is identical to @code{Boolean.TRUE}.)
The return type @code{void} indicates that no value is returned.

A type specifier can also be a fully-qualified Java class name
(for example @code{java.lang.StringBuffer}).  In that case,
the actual argument is cast at run time to the named class.
Also, @code{java.lang.StringBuffer[]} represents
an array of references to @code{java.lang.StringBuffer} objects.

@node Declaring Types of Variables,  Type tests and conversions, Standard Types, Types
@section Declaring Types of Variables

@deffn Syntax let @stxlit{((}name [@stxlit{::} type] init@stxlit{)} ...@stxlit{)} body
Declare new locals variables with the given @var{name}, initial value
@var{init}, and optional type specification @var{type}.
If @var{type} is specified, then the expression @var{init} is evaluated,
the result coerced to @var{type}, and then assigned to the variable.
If @var{type} is not specified, it defaults to @code{Object}.
@end deffn

@deffn Syntax let* @stxlit{((}name [@stxlit{::} type] init@stxlit{)} ...@stxlit{)} body
@end deffn

@deffn Syntax letrec @stxlit{((}name [@stxlit{::} type] init@stxlit{)} ...@stxlit{)} body
@end deffn

@deffn Syntax define [@stxlit{::} type] value
@end deffn

See also @code{define-private}, and @code{define-constant}.

@node Type tests and conversions, , Declaring Types of Variables, Types
@section Type tests and conversions

Scheme defines a number of standard type testing predicates.
For example @code{(vector? x)} is @code{#t} if and only if
@code{x} is a vector.

Kawa generalizes this to arbitrary type names:
If @var{T} is a type-name (that is in scope at compile-time),
then @code{@var{T}?} is a one-argument function that returns
@code{#t} if the argument is an instance of the type @code{@var{T}},
and @code{#f} otherwise:
@example
(gnu.lists.FVector? #(123)) @result{} #t
(let ((iarr (int[] 10))) (int[]? iarr)) @result{} #t 
@end example
In general:
@example
(@var{T}? @var{x}) @result{} (instance? @var{x} @var{T})
@end example

@deffn Procedure instance? value type
Returns @code{#t} iff @var{value} is an instance of type @var{type}.
(Undefined if @var{type} is a primitive type, such as @code{int}.)
@end deffn

@deffn Procedure as type value
Converts or coerces @var{value} to a value of type @var{type}.
Throws an exception if that cannot be done.
Not supported for @var{type} to be a primitive type such as @code{<int>}.
@end deffn

@node Objects Classes and Modules, XML tools, Types, Top
@chapter Object, Classes and Modules

Kawa provides various ways to define, create, and access Java objects.
Here are the currently supported features.

The Kawa module system is based on the features of the Java class system.

@menu
* Defining new classes::
* Anonymous classes::
* Enumerations::          Enumeration types
* Annotations::
* Module classes::        Modules and how they are compiled to classes
* Record types::          Defining Record Types
* Dynamic records::       Creating New Record Types On-the-fly
* Method operations::     Calling Java methods from Scheme
* Allocating objects::
* Field operations::      Accessing fields of Java objects
* Mangling::              Mapping Scheme names to Java names
* Scheme types in Java::
* Array operations::      Using Java arrays
* Loading Java functions into Scheme::
* Evaluating Scheme expressions from Java::
@end menu

@deffn Syntax this
Returns the "this object" - the current instance of the current class.
The current implementation is incomplete, not robust, and not
well defined.  However, it will have to do for now.
Note:  "@code{this}" is a macro, not a variable, so you have to write
it using parentheses: @samp{(this)}.  A planned extension will
allow an optional class specifier (needed for nested clases).
@end deffn

@node Defining new classes
@section Defining new classes

Kawa provides various mechanisms for defining new classes.
The @code{define-class} and @code{define-simple-class} forms
will usually be the preferred mechanisms.  They have basically
the same syntax, but have a couple of differences.
@code{define-class} allows multiple inheritance as well as true nested
(first-class) class objects.  However, the implementation
is more complex: code using it is slightly slower, and the mapping to
Java classes is a little less obvious.   (Each Scheme class is implemented
as a pair of an interface and an implementation class.)
A class defined by @code{define-simple-class} is slightly more
efficient, and it is easier to access it from Java code.

The syntax of @code{define-class} are mostly compatible with that
in the Guile and Stk dialects of Scheme.

@deffn Syntax define-class @stxref{class-name} @stxlit{(}supers ...@stxlit{)} (@stxref{annotation}|@stxref{option-pair})* @stxref{field-or-method-decl} ...
@deffnx Syntax define-simple-class @stxref{class-name} @stxlit{(}supers ...@stxlit{)} (@stxref{annotation}|@stxref{option-pair})*  @stxref{field-or-method-decl} ...

Defines a new class named @var{class-name}.  If @code{define-simple-class} is
used, creates a normal Java class named @var{class-name} in the current package.
(If @var{class-name} has the form @code{<xyz>} the Java implementation
type is named @code{xyz}.)  For @code{define-class} the implementation is
unspecified.  In most cases, the compiler creates a class pair,
consisting of a Java interface and a Java implementation class.
@end deffn
@display
@stxdef{class-name} @stxref{identifier}
@stxdef{option-pair} @var{option-keyword} @var{option-value}
@stxdef{field-or-method-decl} @stxref{field-decl} | @stxref{method-decl}
@end display

@subsection General class properties

The class inherits from the classes and interfaces listed in @var{supers}.
This is a list of names of classes that are in scope (perhaps imported
using @code{require}), or names for existing classes or interfaces
optionally surrounded by @code{<>}, such as @code{<gnu.lists.Sequence>}.
If @code{define-simple-class} is used, at most one of these may be
the name of a normal Java class or classes defined using
@code{define-simple-class}; the rest must be interfaces or classes
defined using @code{define-class}.
If @code{define-class} is used, @emph{all} of the classes listed
in @var{supers} should be interfaces or classes defined using
@code{define-class}.

@table @asis
@item @stxlit{interface:} @var{make-interface}
Specifies whether Kawa generates a Java class, interface, or both.
If @var{make-interface} is @code{#t}, then a Java interface is generated.
In that case all the supertypes must be interfaces, and
all the declared methods must be abstract.
If @var{make-interface} is @code{#f}, then a Java class is generated.
If @code{interface:}  is unspecified, the default is @code{#f}
for @code{define-simple-class}.  For @code{define-class} the default
is to generate an interface, and in addition (if needed) a helper
class that implements the interface.  (In that case any non-abstract methods
are compiled to static methods.  The methods that implement the interface
are just wrapper methods that call the real static methods.  This
allows Kawa to implement true multiple inheritance.)

@item @stxlit{access:} @var{kind}
Specifies the Java access permission on the class.
Can be one of @code{'public} (which is the default in Kawa),
@code{'package} (which the default "unnamed" permission in Java code),
@code{'protected}, @code{'private},
@code{'volatile}, or @code{'transient}.
Can also be used to specify @code{final} or @code{enum}, as in Java.
Can also be a list, as for example:
@example
access: '(protected volatile)
@end example

@item @stxlit{class-name:} @code{"}@var{cname}@code{"}
Specifies the Java name of the created class.
The @var{name} specified after @code{define-class}
or @code{define-simple-class} is the @emph{Scheme name},
i.e. the name of a Scheme variable that is bound to the class.
The Java name is by default derived from the Scheme name,
but you can override the default with a @code{class-name:} specifier.
If the @var{cname} has no periods, then it is a name in
the package of the main (module) class.
If the @var{cname} starts with a period,
then you get a class nested within the module class.
In this case the actual class name is @var{moduleClass}@code{$}@var{rname},
where @var{rname} is @var{cname} without the initial period.
To force a class in the top-level (unnamed) package (something
not recommended) write a period at the end of the @var{cname}.
@end table

@subsection Declaring fields

@display
@stxdef{field-decl} @stxlit{(}@stxref{field-name} (@stxref{annotation} | @stxref{opt-type-specifier} | @stxref{field-option})*@stxlit{)}
@stxdef{field-name} @stxref{identifier}
@stxdef{field-option} @stxref{keyword} @stxref{expression}
@end display

As a matter of style the following order is suggested, though this not enforced:
@display
@stxlit{(}@stxref{field-name} @stxref{annotation}* @stxref{opt-type-specifier} @stxref{field-option}*@stxlit{)}
@end display

Each @var{field-decl} declares a instance "slot" (field)
with the given @var{field-name}. 
By default it is publicly visible, but you can specify
a different visiblity with the @code{access:} specifier.
The following @var{field-option} @var{keyword}s are implemented:
@table @asis
@item @stxlit{type:} @stxref{type}
Specifies that @var{type} is the type of (the values of) the field.
Equivalent to @samp{:: @var{type}}.
@item @stxlit{allocation:} @var{kind}
If @var{kind} is @code{'class} or @code{'static} a single slot is shared
between all instances of the class (and its sub-classes).
Not yet implemented for @code{define-class},
only for @code{define-simple-class}.
In Java terms this is a @code{static} field.

If @var{kind} is @code{'instance} then
each instance has a separate value "slot", and they
are not shared. In Java terms, this is a non-@code{static} field.
This is the default.

@c You can use a keyword like @code{class:} or a string like @code{"class"}
@c if you prefer instead of a quoted symbol like @code{'class};
@c the latter is recommended.
@item @stxlit{access:} @var{kind}
Specifies the Java access permission on the field.
Can be one of @code{'private}, @code{'protected},
@code{'public} (which is the default in Kawa),
or @code{'package} (which the default "unnamed" permission
in Java code).
Can also be used to specify @code{volatile}, @code{transient},
@code{enum}, or @code{final}, as in Java.
@item @stxlit{init:} @var{expr}
An expression used to initialize the slot.
The expression is evaluated in a scope that includes the field and
method names of the current class.
@item @stxlit{init-form:} @var{expr}
An expression used to initialize the slot.
The lexical environment of the @var{expr} is that of the @code{define-class};
it does @emph{not} include the field and method names of the current class.
or @code{define-simple-class}.
@item @stxlit{init-value:} @var{value}
A value expression used to initialize the slot.
For now this is synonymous with @var{init-form:}, but that may change
(depending on what other implementation do), so to be safe only use
@code{init-value:} with a literal.
@item @stxlit{init-keyword:} @code{@var{name}:}
A keyword that that can be used to initialize instance in @code{make} calls.
For now, this is ignored, and @var{name} should be the same as the
field's @var{field-name}.
@end table

The @var{field-name} can be left out.  That indicates a "dummy slot",
which is useful for initialization not tied to a specific field.
In Java terms this is an instance or static initializer, i.e., a
block of code executed when a new instance is created or the class is loaded.

In this example, @code{x} is the only actual field.  It is first
initialized to 10, but if @code{(some-condition)} is true
then its value is doubled.
@example
(define-simple-class <my-class> ()
  (allocation: 'class
   init: (perform-actions-when-the-class-is-initizalized))
  (x init: 10)
  (init: (if (some-condition) (set! x (* x 2)))))
@end example

@subsection Declaring methods

@display
@stxdef{method-decl} @stxlit{((}@stxref{method-name} @stxref{formal-arguments}@stxlit{)}
    (@stxref{annotation} | @stxref{opt-return-type} | @stxref{option-pair})* [@stxref{deprecated-return-specifier}] @stxref{body}@stxlit{)}
@stxdef{method-name} @stxref{identifier}
@stxdef{deprecated-return-specifier} @stxref{identifier}
@end display

Each @var{method-decl} declares a method,
which is by default public and non-static, and whose name is @var{method-name}.
(If @var{method-name} is not a valid
Java method name, it is mapped to something reasonable.
For example @code{foo-bar?} is mapped to @code{isFooBar}.)
The types of the method arguments can be specified in the
@var{formal-arguments}.  The return type can be specified by
a @var{opt-return-type}, @var{deprecated-return-specifier},
or is otherwise the type of the @var{body}.
Currently, the @var{formal-arguments} cannot contain optional, rest,
or keyword parameters.  (The plan is to allow optional parameters,
implemented using multiple overloaded methods.)

A @var{method-decl} in a @code{define-simple-class}
can have the following @var{option-keyword}s:
@table @asis
@item @stxlit{access:} @var{kind}
Specifies the Java access permission on the method.
Can be one of @code{'private}, @code{'protected},
@code{'public}, or @code{'package}.
@item @stxlit{allocation:} @var{kind}
If @var{kind} is @code{'class} or @code{'static} creates a static method.
@item @stxlit{throws:} ( @var{exception-class-name} ... )
Specifies a list of checked exception that the method may throw.
Equivalent to a @code{throws} specification in Java code.
For example:
@example
(define-simple-class T
  (prefix)
  ((lookup name) throws: (java.io.FileNotFoundException)
   (make java.io.FileReader (string-append prefix name))))
@end example
@end table

The scope of the @var{body} of a method includes the @var{field-decl}s
and @var{field-decl}s of the body, including those inherited from
superclasses and implemented interfaces.

If the @var{body} is the special form @code{#!abstract},
then the method is abstract.  This means the method must
be overridden in a subclass, and you're not allowed to
create an instance of the enclosing class.

@example
(define-simple-class Searchable () interface: #t
  ((search value) :: boolean #!abstract))
@end example

The special @var{method-name} @samp{*init*} can be used to name
a non-default constructor (only if @var{make-interface} discussed above
is @code{#f}).
It can be used to initialize a freshly-allocated instance
using passed-in parameters.
You can call a superclass or a sibling constructor using
the @code{invoke-special} special function.
(This is general but admittedly a bit verbose; a more compact
form may be added in the future.)
See the example below.

@subsection Example

In the following example we define a simple class @code{2d-vector}
and a class @code{3d-vector} that extends it.  (This is for illustration
only - defining 3-dimensional points as an extension
of 2-dimensional points does not really make sense.)

@example
(define-simple-class 2d-vector ()
  (x ::double init-keyword: x:)
  ;; Alternative type-specification syntax.
  (y type: double init-keyword: y:)
  (zero-2d :: 2d-vector allocation: 'static
   init-value: (2d-vector 0))
  ;; An object initializer (constructor) method.
  ((*init* (x0 ::double) (y0 ::double))
   (set! x x0)
   (set! y y0))
  ((*init* (xy0 ::double))
   ;; Call above 2-argument constructor.
   (invoke-special 2d-vector (this) '*init* xy0 xy0))
  ;; Need a default constructor as well.
  ((*init*) #!void)
  ((add (other ::2d-vector)) ::2d-vector
   ;; Kawa compiles this using primitive Java types!
   (2d-vector
     x: (+ x other:x)
     y: (+ y other:y)))
  ((scale (factor ::double)) ::2d-vector
   (2d-vector x: (* factor x) y: (* factor y))))

(define-simple-class 3d-vector (2d-vector)
  (z type: double init-value: 0.0 init-keyword: z:)
  ;; A constructor which calls the superclass constructor.
  ((*init* (x0 ::double) (y0 ::double) (z0 ::double))
   (invoke-special 2d-vector (this) '*init* x0 y0)
   (set! z z0))
  ;; Need a default constructor.
  ((*init*) #!void)
  ((scale (factor ::double)) ::2d-vector
   ;; Note we cannot override the return type to 3d-vector
   ;; because Kawa doesn't yet support covariant return types.
   (3d-vector
     x: (* factor x)
     y: (* factor (this):y) ;; Alternative syntax.
     z: (* factor z))))
@end example

Note we define both explicit non-default constructor methods,
and we associate fields with keywords, so they can be named
when allocating an object.  Using keywords requires a default constructor,
and since having non-default constructors suppresses
the implicit default constructor we have to explicitly define it.
Using both styles of constructors is rather redundant, though.

@subsection Synchronized methods
@cindex synchronized methods
Kawa doesn't directly support marking a method as @code{synchronized},
but you can get the same effect using a @code{synchronized} expression:

@example
(define-simple-class <Bar> ()
  ;; non-static method
  ((foo) :: void
   (synchronized (this)
		 (synchronized-block)))
  ;; static method
  ((baz) allocation: 'static :: void
   (synchronized <Bar>
		 (synchronized-block))))
@end example

@node Anonymous classes
@section Anonymous classes

@deffn Syntax object @stxlit{(}supers ...@stxlit{)} field-or-method-decl ...
Returns a new instance of an anonymous (inner) class.
The syntax is similar to @code{define-class}.
@display
@stxdef{object-field-or-method-decl} @stxref{object-field-decl} | @stxref{method-decl}
@stxdef{object-field-decl} @stxlit{(}@stxref{field-name} (@stxref{annotation} | @stxref{opt-type-specifier} | @stxref{field-option})*  [@stxref{object-init}] @stxlit{)}
@stxdef{object-init} @stxref{expression}
@end display

Returns a new instance of a unique (anonymous) class.
The class inherits from the list of @var{supers}, where at most one of the
elements should be the base class being extended from, and the rest
are interfaces.

This is roughly equivalent to:
@example
(begin
  (define-simple-class @var{hname} (@var{supers} ...) @var{field-or-method-decl} ...)
  (make @var{hname}))
@end example

A @var{field-decl} is as for @code{define-class}, except
that we also allow an abbreviated syntax.
Each @var{field-decl} declares a public instance field.
If @var{object-finit} is given, it is an expression whose value
becomes the initial value of the field.
The @var{object-init} is evaluated at the same time as the @code{object}
expression is evaluated,
in a scope where all the @var{field-name}s are visible.

A @var{method-decl} is as for @code{define-class}.
@end deffn

@subsection Lambda as shorthand for anonymous class
@anchor{SAM-conversion}
An anonymous class is commonly used in the Java platform where a
function language would use a lambda expression.
Examples are call-back handlers, events handlers, and @code{run} methods.
In these cases Kawa lets you use a lambda expression as a short-hand
for an anonymous class.  For example:
@example
(button:addActionListener
  (lambda (e) (do-something)))
@end example
is equivalent to:
@example
(button:addActionListener
  (object (java.awt.event.ActionListener)
    ((actionPerformed (e ::java.awt.event.ActionEvent))::void
     (do-something))))
@end example
This is possible when the required type is an interface or
abstract class with a Single (exactly one) Abstract Methods.
Such a class is sometypes called a @dfn{SAM-type}, and the
conversion from a lambda expression to an anonymous class
is sometimes called @dfn{SAM-conversion}.

Note that Kawa can also infer the parameter and return types
of a method that overrides a method in a super-class.

@node Enumerations
@section Enumeration types

An enumeration type is a set of named atomic enumeration values
that are distinct from other values.  You define the type
using @code{define-enum}, and you reference enumeration values
using colon notation:
@example
(define-enum colors (red blue green))
(define favorite-color colors:green)
@end example
Displaying an enum just prints the enum name,
but readable output using @code{write} (or the @code{~s} @code{format}
specifier) prepends the type name:
@example
(format "~a" favorite-color) @result{} "green"
(format "~s" favorite-color) @result{} "colors:green"
@end example
The static @code{values} method returns a Java array of the enumeration
values, in declaration order, while @code{ordinal} yields the index
of an enumeration value:
@example
(colors:values) @result{} [red blue green]
((colors:values) 1) @result{} blue
(favorite-color:ordinal) @result{} 2
@end example
If you invoke the enumeration type as a function,
it will map the name (as a string) to the corresponding value.
(This uses the @code{valueOf} method.)
@example
(colors "red") @result{} red
(colors "RED") @result{} throws IllegalArgumentException
(eq? favorite-color (colors:valueOf "green")) @result{} #t
@end example

Kawa enumerations are based on Java enumerations.
Thus the above is similar to a Java5 @code{enum} declaration,
and the type @code{colors} above extends @code{java.lang.Enum}.

@deffn Syntax define-enum enum-type-name @var{option-pair}... @stxlit{(}enum-value-name ...@stxlit{)} @var{field-or-method-decl}...
This declares a new enumeration type @var{enum-type-name},
whose enumerations values are the @var{enum-value-name} list.
You can specify extra options and members using
@var{option-pair} and @var{field-or-method-decl},
which are as in @code{define-simple-class}.
(The @var{define-enum} syntax is similar to a
@code{define-simple-class} that extends @code{java.lang.Enum}.)
@end deffn

(Note that R6RS has a separate Enumerations library @code{(rnrs enum)}.
Unfortunately, this is not compatible with standard Java enums.
R6RS enums are simple symbols, which means you cannot distinguish
two enum values from different enumeration types if they have the
same value, nor from a vanilla symbol.  That makes them less useful.)

@node Annotations
@section Annotations of declarations

The Java platform lets you associate with each declaration zero or more
@uref{http://download.oracle.com/javase/1.5.0/docs/guide/language/annotations.html, annotations}.
They provide an extensible mechanism to associate properties
with declarations.
Kawa support for annotations is not complete (the most important
functionality missing is being able to declare annotation types),
but is fairly functional.
Here is a simple example illustring use of
@uref{http://jcp.org/en/jsr/detail?id=222,JAXB annotations}:
an @code{XmlRootElement} annotation on a class,
and an @code{XmlElement} annotation on a field:
@example
(define-alias XmlRootElement javax.xml.bind.annotation.XmlRootElement)
(define-alias XmlElement javax.xml.bind.annotation.XmlElement)
(define-simple-class Bib ( ) (@@XmlRootElement name: "bib")
  (books (@@XmlElement name: "book" type: Book) ::java.util.ArrayList))
(define-simple-class Book () ...)
@end example

@uref{http://per.bothner.com/blog/2011/Using-JAXB-annotations, This tutorial}
explains the JAXB example in depth.

Here is the syntax:
@display
@stxdef{annotation} @stxlit{(@@}@stxref{annotation-typename} @stxref{annotations-element-values}@stxlit{)}
@stxdef{annotations-element-values} @stxref{annotation-element-value}
  | @stxref{annotation-element-pair} ...
@stxdef{annotation-element-pair} @stxref{keyword} @stxref{annotation-element-value}
@stxdef{annotation-element-value} @stxref{expression}
@stxdef{annotation-typename} @stxref{expression}
@end display

An @var{annotations-element-values} consisting of just
a single @var{annotation-element-value} is equivalent to an
@var{annotation-element-pair} with a @code{value:} keyword.

Each @var{keyword} must correspond to the name of
an element (a zero-argument method) in the annotation type.
The corresponding @var{annotation-element-value} must be compatible with the
element type (return type of the method) of the annotation type.

Allowed element types are of the following kinds:
@itemize @bullet
@item
Primitive types, where the @var{annotation-element-value} must
be number or boolean coercible to the element type.
@item
Strings, where the @var{annotation-element-value} is normally a string literal.
@item
Classes, where the @var{annotation-element-value} is normally
a classname.
@item
Enumeration types. The value usually has the form @code{@var{ClassName}:@var{enumFieldname}}.
@item
Nested annotation types, where the  @var{annotation-element-value} must
be a compatible @var{annotation} value.
@item
An array of one of the allowable types.
An array constructor expression works, but using the
square bracket syntax is recommended.
@end itemize

Annotations are usually used in declarations,
where they are required to be ``constant-folded'' to compile-time
constant annotation values.
This is so they can be written to class files.
However, in other contexts an annotation can be used as an expression
with general sub-expressions evaluated at run-time:
@example
(define bk-name "book")
(define be (@@XmlElement name: bk-name type: Book))
(be:name) @result{} "book"
@end example
(This may have limited usefulness:  There are some bugs, including
lack of support for default values for annotation elements.
These bugs can be fixed if someone reports a need for
runtime construction of annotation values.)

@node Module classes
@section Modules and how they are compiled to classes

A @dfn{module} is a set of definitions that the module @dfn{exports},
as well as some @dfn{actions} (expressions evaluated for their side effect).
The top-level forms in a Scheme source file compile a module;
the source file is the @dfn{module source}.
When Kawa compiles the module source, the result is the
@dfn{module class}.  Each exported definition is translated to
a public field in the module class.

There are two kinds of module class:
A @dfn{static module} is a class (or gets compiled to a class)
all of whose public fields a static, and that does not have a
public constructor.  A JVM can only have a single global instance of
a static module.
An @dfn{instance module} has a public default constructor,
and usually has at least one non-static public field.
There can be multiple instances
of an instance module; each instance is called a @dfn{module instance}.
However, only a single instance of a module can be @dfn{registered}
in an environment, so in most cases there is only a single
instance of instance modules.  Registering an instance in an environment
means creating a binding mapping a magic name (derived from the class name)
to the instance.

In fact, any Java class class that has the properties of either
an instance module or a static module, is a module, and can be
loaded or imported as such;  the class need not have written
using Scheme.

@subsection Name visibility

The definitions that a module exports are accessible to other modules.
These are the "public" definitions, to use Java terminology.
By default, all the identifiers declared at the top-level of a module
are exported, except those defined using @code{define-private}.
However, a major purpose of using modules is to control the set of
names exported.  One reason is to reduce the chance of accidental
name conflicts between separately developed modules.  An even more
important reason is to enforce an interface:  Client modules should
only use the names that are part of a documented interface, and should
not use internal implementation procedures (since those may change).

If there is a @code{module-export} declaration in the module, then
only those names listed in a @code{module-export} are exported.
There can be more than one @code{module-export}, and they can be
anywhere in the Scheme file.  As a matter of good style, I recommend
a single @code{module-export} near the beginning of the file.

@deffn Syntax module-export name ...
Make the definition for each @var{name} be exported.
Note that it is an error if there is no definition for @var{name}
in the current module, or if it is defined using @code{define-private}.
@end deffn

In this module, @code{fact} is public and @code{worker} is private:
@example
(module-export fact)
(define (worker x) ...)
(define (fact x) ...)
@end example

Alternatively, you can write:
@example
(define-private (worker x) ...)
(define (fact x) ...)
@end example

@subsection Definitions

In addition to @code{define} (which can take an optional type specifier),
Kawa has some extra definition forms.

@deffn Syntax define-private name [:: type] value
@deffnx Syntax define-private (name formals) body
Same as @code{define}, except that @code{name} is not exported.
@end deffn

@deffn Syntax define-constant name [:: type] value
Definites @var{name} to have the given @var{value}.
The value is readonly, and you cannot assign to it.
(This is not fully enforced.)
If the definition is at module level, then the compiler
will create a @code{final} field with the given name and type.
The @var{value} is evaluated as normal; however, if it is a
compile-time constant, it defaults to being static.
@end deffn

@deffn Syntax define-variable name [init]
If @var{init} is specified and @var{name} does not have a global variable
binding, then @var{init} is evaluated, and @var{name} bound to the result.
Otherwise, the value bound to @var{name} does not change.
(Note that @var{init} is not evaluated
if @var{name} does have a global variable binding.)

Also, declares to the compiler that @var{name} will be looked up
in the dynamic environment. This can be useful for shutting up
warnings from @code{--warn-undefined-variable}.

This is similar to the Common Lisp @code{defvar} form.
However, the Kawa version is (currently) only allowed at module level.
@end deffn

For @code{define-namespace} and @code{define-private-namespace}
see @ref{Namespaces}.

@subsection How a module becomes a class

If you want to just use a Scheme module as a module (i.e. @code{load}
or @code{require} it), you don't care how it gets translated
into a module class.  However, Kawa gives you some control over how this
is done, and you can use a Scheme module to define a class which
you can use with other Java classes.  This style of class definition
is an alternative to @code{define-class},
which lets you define classes and instances fairly conveniently.

The default name of the module class is the main part of the
filename of the Scheme source file (with directories and extensions
sripped off).  That can be overridden by the @code{-T} Kawa
command-line flag.  The package-prefix specified by the @code{-P}
flag is prepended to give the fully-qualified class name.

@deffn Syntax module-name <name>
Sets the name of the generated class, overriding the default.
If there is no @samp{.} in the @var{name}, the package-prefix
(specified by the @code{-P} Kawa command-line flag) is prepended.
@end deffn

By default, the base class of the generated module class is unspecified;
you cannot count on it being more specific than @code{Object}.
However, you can override it with @code{module-extends}.

@deffn Syntax module-extends <class>
Specifies that the class generated from the immediately surrounding
module should extend (be a sub-class of) the class @code{<@var{class}>}.
@end deffn

@deffn Syntax module-implements <interface> ...
Specifies that the class generated from the immediately surrounding
module should implement the interfaces listed.
@end deffn

Note that the compiler does @emph{not} currently check that all the
abstract methods requires by the base class or implemented interfaces
are actually provided, and have the correct signatures.  This will
hopefully be fixed, but for now, if you are forgot a method, you will
probably get a verifier error

For each top-level exported definition the compiler creates a
corresponding public field with a similar (mangled) name.
By default, there is some indirection:  The value of the Scheme variable
is not that of the field itself.  Instead, the field is a
@code{gnu.mapping.Symbol} object, and the value Scheme variable is
defined to be the value stored in the @code{Symbol}.
Howewer, if you specify an explicit type, then the field will
have the specified type, instead of being a @code{Symbol}.
The indirection using @code{Symbol} is also avoided if you use
@code{define-constant}.

If the Scheme definition defines a procedure (which is not re-assigned
in the module), then the compiler assumes the variable as bound as a
constant procedure.  The compiler generates one or more methods
corresponding to the body of the Scheme procedure. It also generates
a public field with the same name; the value of the field is an
instance of a subclass of @code{<gnu.mapping.Procedure>} which when
applied will execute the correct method (depending on the actual arguments).
The field is used when the procedure used as a value (such as being passed
as an argument to @code{map}), but when the compiler is able to do so,
it will generate code to call the correct method directly.

You can control the signature of the generated method by declaring
the parameter types and the return type of the method.  See the
applet (@pxref{Applet compilation}) example for how this can be done.
If the procedures has optional parameters, then the compiler will
generate multiple methods, one for each argument list length.
(In rare cases the default expression may be such that this is
not possible, in which case an "variable argument list" method
is generated instead.  This only happens when there is a nested
scope @emph{inside} the default expression, which is very contrived.)
If there are @code{#!keyword} or @code{#!rest} arguments, the compiler
generate a "variable argument list" method.  This is a method whose
last parameter is either an array or a @code{<list>}, and whose
name has @code{$V} appended to indicate the last parameter is a list.

Top-leval macros (defined using either @code{define-syntax}
or @code{defmacro}) create a field whose type is currently a sub-class of
@code{kawa.lang.Syntax};  this allows importing modules to detect
that the field is a macro and apply the macro at compile time.

@deffn Syntax module-static name ...
@deffnx Syntax module-static @code{#t}
@deffnx Syntax module-static @code{#f}
@deffnx Syntax module-static @code{'init-run}
Control whether the generated fields and methods are static.
If @code{#t}  or @code{'init-run} is specified, then the module will be a
static module, @emph{all} definitions will be static.
If @code{'init-run} is specified, in addition the module body
is evaluated in the class's static initializer.
(Otherwise, it is run the first time it is @code{require}'d.)
Otherwise, the module is an instance module.  However, the @var{name}s
that are explicitly listed will be compiled to static fields and methods.
If @code{#f} is specified, then all exported names will
be compiled to non-static (instance) fields and methods.

By default, if no @code{module-static} is specified:
@enumerate
@item
If there is a @code{module-extends} or @code{module-implements}
declaration, or one of the @code{--applet} or @code{--servlet}
caommand-line flags was specified, then @code{(module-static #f)} is implied.
@item
If one of the command-line flags
@code{--no-module-static}, @code{--module-nonstatic},
@code{--module-static}, or @code{--module-static-run} was specified,
the the default @code{#f}, @code{#f}, @code{#t}, or @code{'init-run},
respectively.
@item
Otherwise the default is @code{(module-static #t)}.
(It used to be @code{(module-static #f)} in older Kawa versions.)
@end enumerate

Note @code{(module-static #t)} usually produces more efficient
code, and is recommended if a module contains only procedure or macro
definitions.  (This may become the default.)
However, a static module means that all environments in a JVM
share the same bindings, which you may not want if you use
multiple top-level environments.
@end deffn

Unfortuntely, the Java class verifier does not allow fields to have
arbitrary names.  Therefore, the name of a field that represents a
Scheme variable is "mangled" (@pxref{Mangling}) into an acceptable Java name.
The implementation can recover the original name of a field @code{X}
as @code{((gnu.mapping.Named) X).getName()} because all the standard
compiler-generate field types implemented the @code{Named} interface.

The top-level actions of a module will get compiled to a @code{run}
method.  If there is an explicit @code{method-extends}, then the
module class will also automatically implement @code{java.lang.Runnable}.
(Otherwise, the class does not implement @code{Runnable}, since in that
case the @code{run} method return an @code{Object} rather than @code{void}.
This will likely change.)

@subsection Requiring (importing) a module

You can import a module into the current namespace with @code{require}.

@deffn Syntax require @stxlit{'}featureName
@deffnx Syntax require classname [@stxlit{"}sourcepath@stxlit{"}]
@deffnx Syntax require @stxlit{"}sourcepath@stxlit{"}
Search for a matching module (class), and add the names
exported by that module to the current set of visible names.
Normally, the module is specified using @var{classname}.
The module can be static module (all public fields must be static),
or an instance module (it has a public default constructor).

If the module is a instance module and if no module instance for that class
has been registered in the current environment, then a new instance
is created and registered (using a "magic" identifier).
If the module class either inherits from @code{gnu.expr.ModuleBody}
or implements @code{java.lang.Runnable} then the corresponding @code{run}
method is executed.  (This is done @emph{after} the instance is
registered so that cycles can be handled.)  These actions (creating,
registering, and running the module instance) are done both at compile
time and at run time, if necessary.

All the public fields of the module class are then incorporated
in the current set of local visible names in the current module.
(This is for both instance and static modules.)
This is done at compile time - no new bindings are created at run-time
(except for the magic binding used to register the module instance),
and the imported bindings are private to the current module.
References to the imported bindings will be compiled as field
references, using the module instance (except for static fields).

If a @code{@stxlit{"}@var{sourcepath}@stxlit{"}} is specified then
that is used to locate the source file for the module, and if necessary,
compile it.

If a @code{'@var{featurename}} is specified then the
@var{featurename} is looked up (at compile time) in the "feature table"
which yields the implementing @var{classname}.
@end deffn

@deffn Syntax import import-set ...
Similar functionality as @code{require}, but specified by R6RS.
@display
@stxdef{import-set} @var{library-reference}
  | @stxlit{(library} @var{library-reference} @stxlit{)}
  | @stxlit{(only} @var{import-set} @var{identifier} ...@stxlit{)}
  | @stxlit{(except} @var{import-set} @var{identifier} ...@stxlit{)}
  | @stxlit{(prefix} @var{import-set} @var{identifier} @stxlit{)}
  | @stxlit{(rename} @var{import-set} @stxlit{(} @var{identifier1} @var{identifier2} @stxlit{)} ...@stxlit{)}
@stxdef{library-reference} @stxlit{(} @var{identifier}+ @stxlit{)}
@end display

A @var{library-reference} is mapped to a class name by concatenating
all the identifiers, separated by dots.
For example:
@example
(import (gnu kawa slib srfi37))
@end example
is equivalent to:
@example
(require gnu.kawa.slib.srfi37)
@end example

By default, all of an imported library's exported bindings are made
visible within an importing library using the names given to the
bindings by the imported library.  The precise set of bindings to be
imported and the names of those bindings can be adjusted with the
@code{only}, @code{except}, @code{prefix}, and @code{ rename} forms as
described below.

@itemize
@item 
An @code{only} form produces a subset of the bindings from another
@meta{import-set}, including only the listed @meta{identifier}s.  The
included @meta{identifier}s must be in the original @meta{import-set}.

@item 
An @code{except} form produces a subset of the bindings from another
@meta{import-set}, including all but the listed @meta{identifier}s.  All
of the excluded @meta{identifier}s must be in the original @meta{import-set}.

@item 
A @code{prefix} form adds the @meta{identifier} prefix to each name from
another @meta{import-set}.

@item 
A @code{rename} form:

@example
(rename (@var{identifier1} @var{identifier2}) @dots{})
@end example
@noindent
removes the bindings for @code{@var{identifier1} @dots{}} to form an
intermediate @meta{import-set}, then adds the bindings back for the
corresponding @code{@var{identifier2} @dots{}} to form the final
@meta{import-set}.  Each @var{identifier1} must be in the original
@meta{import-set}, each @var{identifier2} must not be in the
intermediate @meta{import-set}, and the @var{identifier2}s must be
distinct.
@end itemize
@end deffn

@deffn Syntax provide @stxlit{'}featurename
Declare that @code{'@var{featurename}} is available.
A following @code{cond-expand} in this scope will match @var{featurename}.
@end deffn

Using @code{require} and @code{provide} with @var{featurename}s is
similar to the same-named macros in SLib, Emacs, and Common Lisp.
However, in Kawa these are not functions, but instead they
are syntax forms that are processed at compile time.  That is
why only quoted @var{featurename}s are supported.
This is consistent with Kawa emphasis on compilation and
static binding.

For some examples, you may want to look in the @code{gnu/kawa/slib}
directory.

@node Record types, Dynamic records, Module classes, Objects Classes and Modules
@section Record types

The @code{define-record-type} form can be used for creating new data
types, called record types. A predicate, constructor, and field
accessors and modifiers are defined for each record type.
The @code{define-record-type} feature is specified
by @uref{http://srfi.schemers.org/srfi-9/srfi-9.html,SRFI-9},
which is implemented by many modern Scheme implementations.

@deffn Syntax define-record-type @var{type-name} (@var{constructor-name} @var{field-tag} ...) @var{predicate-name} (@var{field-tag} @var{accessor-name} [@var{modifier-name}]) ...

The form @code{define-record-type} is generative: each use creates a new
record type that is distinct from all existing types, including other
record types and Scheme's predefined types. Record-type definitions may
only occur at top-level (there are two possible semantics for `internal'
record-type definitions, generative and nongenerative, and no consensus
as to which is better).

An instance of @code{define-record-type} is equivalent to the following definitions:
@itemize
@item
The @var{type-name} is bound to a representation of the record type
itself.
@item
The @var{constructor-name} is bound to a procedure that takes
as many arguments as there are @var{field-tag}s in the
@code{(@var{constructor-name} ...)} subform and returns
a new @var{type-name} record. Fields whose tags are listed with
@var{constructor-name} have the corresponding argument as their initial
value. The initial values of all other fields are unspecified.
@item
The @var{predicate-name} is a predicate that returns @code{#t}
when given a value returned by @var{constructor-name}
and @code{#f} for everything else.
@item
Each @var{accessor-name} is a procedure that takes a record of
type @var{type-name} and returns the current value of the corresponding field.
It is an error to pass an accessor a value which is not a record of the
appropriate type.
@item
Each @var{modifier-name} is a procedure that takes a record of
type @var{type-name} and a value which becomes the new value of
the corresponding field.
The result (in Kawa) is the empty value @code{#!void}.
It is an error to pass a
modifier a first argument which is not a record of the appropriate type.
@end itemize

Set!ing the value of any of these identifiers has no effect on the
behavior of any of their original values.
@end deffn

Here is an example of how you can define a record type named @code{pare}
with two fields @code{x} and @code{y}:
@example
(define-record-type pare
  (kons x y)
  pare?
  (x kar set-kar!)
  (y kdr))
@end example

The above defines @code{kons} to be a constructor,
@code{kar} and @code{kdr} to be accessors,
@code{set-kar!} to be a modifier,
and @code{pare?} to be a predicate for @code{pare}s.
@example
(pare? (kons 1 2))        @result{} #t
(pare? (cons 1 2))        @result{} #f
(kar (kons 1 2))          @result{} 1
(kdr (kons 1 2))          @result{} 2
(let ((k (kons 1 2)))
  (set-kar! k 3)
  (kar k))                @result{} 3
@end example

The Kawa compiler creates a new Java class with a name derived from
the @var{type-name}.  If the @var{type-name} is valid Java class name,
that becomes the name of the Java class.  If the @var{type-name} has
the form @code{<@var{name}>} (for example @code{<pare>}), then @var{name}
is used, if possible, for the Java class name.  Otherwise, the name
of the Java class is derived by "mangling" the @var{type-name}.
In any case, the package is the same as that of the surrounding module.

Kawa generates efficient code for the resulting functions,
without needing to use run-time reflection.

@node Dynamic records, Method operations, Record types, Objects Classes and Modules
@section Creating New Record Types On-the-fly

Calling the @code{make-record-type} procedure creates a new record data
type at run-time, without any compile-time support.
It is primarily provided for compatibility; in most cases it is better
to use the @code{define-record-type} form (@pxref{Record types}).

@deffn Procedure make-record-type type-name field-names
Returns a @dfn{record-type descriptor}, a value representing a new data
type disjoint from all others.  The @var{type-name} argument must be a
string, but is only used for debugging purposes (such as the printed
representation of a record of the new type).  The @var{field-names}
argument is a list of symbols naming the @dfn{fields} of a record of the
new type.  It is an error if the list contains any duplicates.
@end deffn

@c @deffn Procedure make-record-sub-type type-name field-names rtd
@c Returns a @dfn{record-type descriptor}, a value representing a new data
@c type, disjoint from all others.  The @var{type-name} argument must be a
@c string.  The @var{field-names} argument is a list of symbols naming the
@c additional @dfn{fields} to be appended to @var{field-names} of
@c @var{rtd}.  It is an error if the combinded list contains any
@c duplicates.@refill
@c
@c Record-modifiers and record-accessors for @var{rtd} work for the new
@c record-sub-type as well.  But record-modifiers and record-accessors for
@c the new record-sub-type will not neccessarily work for @var{rtd}.@refill
@c @end deffn

@deffn Procedure record-constructor rtd [field-names]
Returns a procedure for constructing new members of the type represented
by @var{rtd}.  The returned procedure accepts exactly as many arguments
as there are symbols in the given list, @var{field-names}; these are
used, in order, as the initial values of those fields in a new record,
which is returned by the constructor procedure.  The values of any
fields not named in that list are unspecified.  The @var{field-names}
argument defaults to the list of field names in the call to
@code{make-record-type} that created the type represented by @var{rtd};
if the @var{field-names} argument is provided, it is an error if it
contains any duplicates or any symbols not in the default list.

@c In Kawa, @var{rtd} may be any @code{Class} that has a public default
@c constructor, as long as the @var{field-names} are public instance
@c fields.  (The fields should have type @code{Object} -- unless you
@c know what you are doing!)
@end deffn

@deffn Procedure record-predicate rtd
Returns a procedure for testing membership in the type represented by
@var{rtd}.  The returned procedure accepts exactly one argument and
returns a true value if the argument is a member of the indicated record
type; it returns a false value otherwise.

@c In Kawa, the returned procedure checks if the argument is an instance
@c of @var{rtd} or one of its sub-classes.
@end deffn

@c @deffn Procedure record-sub-predicate rtd
@c Returns a procedure for testing membership in the type represented by
@c @var{rtd} or its parents.  The returned procedure accepts exactly one
@c argument and returns a true value if the argument is a member of the
@c indicated record type or its parents; it returns a false value
@c otherwise.@refill
@c @end deffn

@deffn Procedure record-accessor rtd field-name
Returns a procedure for reading the value of a particular field of a
member of the type represented by @var{rtd}.  The returned procedure
accepts exactly one argument which must be a record of the appropriate
type; it returns the current value of the field named by the symbol
@var{field-name} in that record.  The symbol @var{field-name} must be a
member of the list of field-names in the call to @code{make-record-type}
that created the type represented by @var{rtd}.
@end deffn

@deffn Procedure record-modifier rtd field-name
Returns a procedure for writing the value of a particular field of a
member of the type represented by @var{rtd}.  The returned procedure
accepts exactly two arguments: first, a record of the appropriate type,
and second, an arbitrary Scheme value; it modifies the field named by
the symbol @var{field-name} in that record to contain the given value.
The returned value of the modifier procedure is unspecified.  The symbol
@var{field-name} must be a member of the list of field-names in the call
to @code{make-record-type} that created the type represented by @var{rtd}.
@end deffn

@deffn Procedure record? obj
Returns a true value if @var{obj} is a record of any type and a false
value otherwise.
@end deffn

@deffn Procedure record-type-descriptor record
Returns a record-type descriptor representing the type of the given
record.  That is, for example, if the returned descriptor were passed to
@code{record-predicate}, the resulting predicate would return a true
value when passed the given record.
@end deffn

@deffn Procedure record-type-name rtd
Returns the type-name associated with the type represented by rtd.  The
returned value is @code{eqv?} to the @var{type-name} argument given in
the call to @code{make-record-type} that created the type represented by
@var{rtd}.@refill
@end deffn

@deffn Procedure record-type-field-names rtd
Returns a list of the symbols naming the fields in members of the type
represented by @var{rtd}.  The returned value is @code{equal?} to the
field-names argument given in the call to @code{make-record-type} that
created the type represented by @var{rtd}.@refill
@end deffn

Records are extensions of the class @code{Record}.
These procedures use the Java 1.1 reflection facility.

@node Method operations, Allocating objects, Dynamic records, Objects Classes and Modules
@section Calling Java methods from Scheme

You can call a Java method as if it were a Scheme procedure
using various mechanisms.

@subsection Using colon notation

The general form of the @uref{PathExpressions.html,colon notation} is this:
@example
@var{container}@var{:}@var{part-name}
@end example
This evaluates to the ``part'' named @var{part-name} in a given @var{container}.
If the @var{container} is a class (i.e. a @code{java.lang.Class} or
a @code{gnu.bytecode.ClassType}), then the ``parts'' of
the class are its static methods and fields.

The simplest case is when the class is a fully-qualified class name:
@example
(java.lang.Math:sqrt 9.0) @result{} 3.0
@end example
This is only allowed when the name is of a class that exists
and is accessible both at compile-time and run-time,
and the name is not otherwise lexically bound.

You can also for the @var{container} use an expression that
evalutes to a type or class.  Most commonly you'd use
a class identifier, but you could also evaluate an
expression at run-time (in which case Kawa may have to use slower reflection):
@example
(let ((math java.lang.Math)) math:sqrt 9.0) @result{} 3.0
@end example

@subsection Using a namespace prefix

You can also use @code{define-namespace} to define an alias for a Java class:
@example
(define-namespace Int32 "class:java.lang.Integer")
@end example
In this example the name @code{Int32} is a @dfn{namespace alias}
for the namespace whose full name is @code{"class:java.lang.Integer"}.
The full name should be the 6 characters @code{"class:"} followed
by the fully-qualified name of a Java class.

Instead of a @var{vamespace-uri} you can use a variable that names
a class, usually of the form @code{<@var{classname}>}.
The following is equivalent to the above:
@example
(define-namespace Int32 <java.lang.Integer>)
@end example
However, there is one important difference: The @code{<@var{classname}>}
is first searched in the lexical scope.
It may resolve to a class defined in the current compilation unit
(perhaps defined using @code{define-simple-class}),
or imported from another module,
or an alias (such as from @code{define-alias}).
Only if @code{<@var{classname}>} is @emph{not} found in the current
scope is it tried as the class name @var{classname}.

You can name a method using a @dfn{qualified name} containing a colon.
The part of the name before the colon is a namespace alias (in
this case @code{Int32}), and the part of the name after the colon is the
method name.  For example:
@example
(Int32:toHexString 255) @result{} "ff"
@end example
This invokes the static method @code{toHexString} in the
Java class @code{java.lang.Integer}, passing it the argument @code{255},
and returning the Java String @code{"ff"}.  (Note this is not the
same as a Scheme string!)

The general syntax is
@example
(@var{prefix}:@var{method-name} @var{arg} ...)
@end example
This invokes the method named @var{method-name} in the class corresponding
to @var{prefix}, and the @var{arg}s are the method arguments.

You can use the method name @code{new} to construct new objects:
@example
(Int32:new '|255|)
@end example
This is equivalent to the Java expression @code{new Integer("255")}.
You can also write:
@example
(Int32:new "255")
@end example
Kawa is smart enough to convert the Kawa string to a Java String.

@subsection Invoking non-static methods

To invoke a non-static method you can use a special prefix @code{*}:
@example
(*:toString (list 9 8 7))
@end example
The general syntax is
@example
(*:@var{method-name} @var{instance} @var{arg} ...)
@end example
This invokes the method named @var{method-name}
with @var{instance} as the target object, and the @var{arg}s are
the method arguments.

Alternatively, you can invoke a non-static method using an explicit
@var{prefix}:
@example
(@var{prefix}:@var{method-name} @var{instance} @var{arg} ...)
@end example
Assuming that @var{prefix} is bound to @var{class} then the
above is equivalent to:
@example
(*:@var{method-name} (as @var{class} @var{instance}) @var{arg} ...)
@end example
For example:
@example
(Int32:doubleValue (Int32:new "00255"))
@end example
This returns the @code{double} value @code{255.0}.

As a shorthand, you can use the name of a Java class instead of a
namespace alias:
@example
(java.lang.Integer:toHexString 255)
(java.lang.Object:toString some-value)
@end example
If Kawa sees a qualified name with a prefix that is not defined @emph{and}
that matches the name of a known class, then Kawa will automatically
treat the prefix
as a nickname for namespace uri like @code{class:java.lang.Integer}.
Both conditions should be true at both compile-time and run-time.
However, using an explicit @code{define-namespace} is recommended.

As a final shorthand you can use an identifier in handle brackets,
such as an existing type alias like @code{<list>}.
The following are all equivalent:
@example
(<list>:list3 'a 'b 'c)
@end example
This is equivalent to:
@example
(define-namespace @var{prefix} <list>
(@var{prefix}:list3 'a 'b 'c)
@end example
for some otherwise-unused @var{prefix}.

@subsection Invoking a method with the @code{invoke} function

If you prefer, you can instead use the following functions.
(There is also an older deprecated lower-level interface
(@pxref{Low-level Method invocation}.)

@deffn Procedure invoke-static class name args ...
The @var{class} can be a @code{java.lang.Class}, a
@code{gnu.bytecode.ClassType}, or a @code{symbol} or @code{string}
that names a Java class.  The @var{name} can be @code{symbol} or
@code{string} that names one or more methods in the Java class.

Any accessible methods (static or instance) in the specified @var{class}
(or its super-classes) that match "@var{name}" or "@var{name}$V" collectively
form a generic procedure.  When the procedure is applied to the argument list,
the most specific applicable method is chosen depending on the
argument list;  that method is then
called with the given arguments.  Iff the method is an instance method,
the first actual argument is used as the @code{this} argument.  If there are
no applicable methods (or no methods at all!), or there is no "best"
method, @code{WrongType} is thrown.

An example:
@example
(invoke-static java.lang.Thread 'sleep 100)
@end example

The behavior of interpreted code and compiled code is not
identical, though you should get the same result either way
unless you have designed the classes rather strangely.  The
details will be nailed down later, but the basic idea is that
the compiler will "inline" the @code{invoke-static} call
if it can pick a single "best" matching method.
@end deffn

@deffn Procedure invoke object name args ...
The @var{name} can be @code{<symbol>} or
@code{<string>} that names one or more methods in the Java class.

Any accessible methods (static or instance) in the specified @var{class}
(or its super-classes) that match "@var{name}" or "@var{name}$V" collectively
form a generic procedure.  When the procedure is applied to the argument list,
the most specific applicable method is chosen depending on the
argument list;  that method is then
called with the given arguments.  Iff the method is an instance method,
the @var{object} is used as the @code{this} argument;
otherwise @var{object} is prepended to the @var{args} list.  If there are
no applicable methods (or no methods at all!), or there is no "best"
method, @code{WrongType} is thrown.

The behavior of interpreted code and compiled code is not
indentical, though you should get the same result either way
unless you have designed the classes rather strangely.  The
details will be nailed down later, but the basic idea is that
the compiler will "inline" the @code{invoke-static} call
if it can pick a single "best" matching method.

If the compiler cannot determine the method to call (assuming
the method name is constant), the compiler has to generate code
at run-time to find the correct method.  This is much slower,
so the compiler will print a warning.  To avoid a waning, you can
use a type declaration, or insert a cast:
@example
(invoke (as java.util.Date my-date) 'setDate cur-date)
@end example
or
@example
(let ((my-date ::java.util.Date (calculate-date))
      (cur-date ::int (get-cur-date)))
  (invoke my-date 'setDate cur-date))
@end example
@end deffn

@deffn Procedure invoke-special class receiver-object name arg ...
The @var{class} can be a @code{java.lang.Class}, a
@code{gnu.bytecode.ClassType}, or a @code{symbol} or @code{string}
that names a Java class.  
The @var{name} can be @code{symbol} or
@code{string} that names one or more methods in the Java class.

This procedure is very similar to @code{invoke} and @code{invoke-static}
and invokes the specified method, ignoring any methods in subclasses
that might overide it.  One interesting use is to invoke a method in
your super-class like the Java language @code{super} keyword.

Any methods in the specified @var{class} that match "@var{name}" or
"@var{name}$V" collectively form a generic procedure.  That generic
procedure is then applied as in @code{invoke} using the
@code{receiver-object} and the arguments (if any).

The compiler must be able to inline this procedure (because you cannot
force a specific method to be called using reflection).  Therefore the
@var{class} and @var{name} must resolve at compile-time to a specific
method.

@example
(define-simple-class <MyClass> (<java.util.Date>)
  ((get-year) :: <int>
   (+ (invoke-special <java.util.Date> (this) 'get-year)) 1900)
  ((set-year (year :: <int>)) :: <void>
   (invoke-special <java.util.Date> (this) 'set-year (- year 1900))))
@end example
@end deffn

@deffn Procedure class-methods class name
Return a generic function containing those methods of @var{class}
that match the name @var{name}, in the sense of @code{invoke-static}.
Same as:
@example
(lambda args (apply invoke-static (cons class (cons name args))))
@end example
@end deffn

Some examples using these functions are @samp{vectors.scm}
and @samp{characters.scm} the directory @samp{kawa/lib} in
the Kawa sources.

@subsection Method names

All of the above select a method to invoke base on specified
method name and argments.  If specified name is not a Java name,
it is "mangled" (@pxref{Mangling}) into a valid Java name.
All accessible methods whose names match are considered.
Methods that match after appending @code{$V} or @code{$X} or @code{$V$X}
are also considered.  A @code{$V} suffix matches a variable
number of arguments:  any excess arguments are collect into an
@code{gnu.lists.LList} or a Java array (depending on the final parameter type).
A @code{$X} specifies that the method expects an extra implicit
@code{CallContext} parameter.  In that case the method's result is written
to the @code{CallContext}, so the method result type must be @code{void}.

(Kawa compiles a procedure with a @code{#!rest} or keyword args
whose name is @code{@var{fn}} to a method named @code{@var{fn}$V}.
It adds an implicit parameter for the extra arguments.
By default this extra extra parameter is a Scheme list,
but you can specify a Java array type instead.  In tha case the
array element type must be compatible with all the extra arguments.)

@node Allocating objects, Field operations, Method operations, Objects Classes and Modules
@section  Allocating objects

The recommended way to create an instance of a type @var{T}
is to ``call'' @var{T} as if it were a function, with the
arguments used to initialize the object.
If @code{T} is a class and @code{T} has a matching constructor,
then the arguments will used for constructor arguments:
@example
(java.util.StringTokenizer "this/is/a/test" "/")
@end example
(You can think of the type @var{T} as being
coerced to an instance-constructor function.)

If @code{T} is a container or collection type,
then typically the arguments will be used to specify
the child or component values.
Many standard Scheme procedures fit this convention.
For example in Kawa @code{list} and @code{vector} evaluate to
types, rather than procedures as in standard Scheme,
but because types can be used as constructor functions it just works:
@example
(list 'a (+ 3 4) 'c) @result{} (a 7 c)
(vector 'a 'b 'c) @result{} #(a b c)
@end example
Any class @code{T} that has a default constructor
and an @code{add} method can be initialized this way.
Examples are @code{java.util} collection classes,
and @code{jawa.awt} and @code{javax.swing} containers.
@example
(java.util.ArrayList 11 22 33) @result{} [11, 22, 333]
@end example
The above expression is equivalent to:
@example
(let ((tmp (java.util.ArrayList)))
  (tmp:add 11)
  (tmp:add 22)
  (tmp:add 33)
  tmp)
@end example

Allocating Java arrays (@pxref{Creating-new-Java-arrays}) uses a
similar pattern:
@example
(int[] 2 3 5 7 11)
@end example

Sometimes you want to set some named property to an initial value.
You can do that using a keyword argument.  For example:
@example
(javax.swing.JButton text: "Do it!" tool-tip-text: "do it")
@end example

This is equivalent to using @dfn{setter methods}:
@example
(let ((tmp (javax.swing.JButton)))
  (tmp:setText "Do it!")
  (tmp:setToolTipText "do it")
  tmp)
@end example

A keyword argument @code{@var{key-name}}@stxlit{:} can
can translated to either a @code{@stxlit{set}@var{KeyName}@stxlit{:}}
or a  @code{@stxlit{add}@var{KeyName}@stxlit{:}} method.
The latter makes it convenient to add listeners:

@example
(javax.swing.JButton
  text: "Do it!"
  action-listener:
   (object (java.awt.event.ActionListener)
     ((actionPerformed e) (do-the-action))))
@end example
This is equivalent to: 
@example
(let ((tmp (javax.swing.JButton)))
  (tmp:setText "Do it!")
  (tmp:addActionListener
    (object (java.awt.event.ActionListener)
      ((actionPerformed e) (do-the-action))))
  tmp)
@end example

Making use of so-called ``SAM-conversion'' (@pxref{SAM-conversion})
 makes it even more convenient:
@example
(javax.swing.JButton
  text: "Do it!"
  action-listener:
   (lambda (e) (do-the-action)))
@end example

The general case allows for a mix of
constructor arguments, property keywords, and child values:
@display
@var{class-type} @stxref{constructor-value}... @stxref{property-initializer}... @stxref{child-value}...
@stxdef{constructor-value} @stxref{expression}
@stxdef{property-initializer} @stxref{keyword} @stxref{expression}
@stxdef{child-value} @stxref{expression}
@end display

First an object is constructed with the @var{constructor-value} arguments
(if any) passed to the object constructor; 
then named properties (if any) are used to initialize named properties;
and then remaining arguments are used to add child values.

There is an ambiguity if there is no @var{property-initializer} -
we can't distinguish between a @var{constructor-value}
and a @var{child-value}.
In that case, if there is a matching constructor method, then all of the
arguments are constructor arguments;
otherwise, there must a default constructor, and all
of the arguments are @var{child-value} arguments.

There is a trick you can you if you need both
@var{constructor-value} and @var{child-value} arguments:
separate them with an ``empty keyword'' @code{||:}.
This matches a method named @code{add}, which means that
the next argument effectively a @var{child-value} - as do
all the remaining arguments. Example:
@example
(let ((vec #(1 2 3)))
  (java.util.ArrayList vec ||: 4 5 6))
  @result{} [1, 2, 3, 4, 5, 6]
@end example

The compiler rewrites these allocations expression
to generated efficient bytecode, assuming that the ``function''
being applied is a type known by the compiler.
Most of the above expressions also work if the type is applied
at run-time, in which case Kawa has to use slower reflection:
@example
(define iarr int[])
(apply iarr (list 3 4 5)) @result{} [3 4 5]
@end example
However @code{add@var{Xxx}} methods and SAM-conversion
are currently only recognized in the case of a class known at compile-time,
not at run-time.

Here is a working Swing demo illustrating many of these techniques:

@example
(define-alias JButton javax.swing.JButton)
(define-simple-class HBox (javax.swing.Box)
  ((*init*) (invoke-special javax.swing.Box (this) '*init* 0)))
(define-alias JFrame javax.swing.JFrame)
(define-alias Box javax.swing.Box)

(define value 0)

(define txt
  (javax.swing.JLabel
   text: "0"))

(define (set-value i)
  (set! value i)
  (set! txt:text (number->string i)))

(define fr
  (JFrame
     title: "Hello!"
     (Box 1#|VERTICAL|# ||:
      (javax.swing.Box:createGlue)
      txt
      (javax.swing.Box:createGlue)
      (HBox
       (JButton ;; uses 1-argument constructor
	"Decrement" ;; constructor argument
	tool-tip-text: "decrement"
	action-listener: (lambda (e) (set-value (- value 1))))
       (javax.swing.Box:createGlue)
       (JButton ;; uses 0-argument constructor
	text: "Increment"
	tool-tip-text: "increment"
	action-listener: (lambda (e) (set-value (+ value 1))))))))
(fr:setSize 200 100)
(set! fr:visible #t)
@end example

If you prefer, you can use the older @code{make} special function:

@deffn Procedure make type args ...
Constructs a new object instance of the specified @var{type},
which must be either a @code{java.lang.Class} or a
@code{<gnu.bytecode.ClassType>}.
Equivalent to:
@example
@var{type} @var{args} ...
@end example
@end deffn

Another (semi-deprecated) function is to use the colon notation
with the @code{new} pseudo-function.
The following three are all equivalent:
@example
(java.awt.Point:new x: 4 y: 3)
(make java.awt.Point: x: 4 y: 3)
(java.awt.Point x: 4 y: 3)
@end example 

@node Field operations, Mangling, Allocating objects, Objects Classes and Modules
@section Accessing fields of Java objects

The recommmended way to access fields 
uses the namespace-colon syntax described in @pxref{Method operations}.
The difference is that instead of a method name following the colon
there is field name a following the colon @emph{and} a period.

To access an static field named @var{field-name} use this syntax
@example
(@var{prefix}:.@var{field-name} @var{instance})
@end example
The @var{prefix} can be as discussed in @xref{Method operations}.
Here are 5 equivalent ways:
@example
(java.lang.Integer:.MAX_VALUE)
(<java.lang.Integer>:.MAX_VALUE)
(define-namespace Int32 <java.lang.Integer>)
(Int32:.MAX_VALUE)
(define-namespace Integer "class:java.lang.Integer")
(Integer:.MAX_VALUE)
(define-alias j.l.Integer java.lang.Integer)
(j.l.Integer:.MAX_VALUE)
@end example
You can set a static field using this syntax:
@example
(set! (@var{prefix}:.@var{field-name}) @var{new-value})
@end example

The special field name @code{class} can be used to extract the
@code{java.lang.Class} object for a class-type.  For example:
@example
(java.util.Vector:.class) @result{} class java.util.Vector
@end example

To access a instance field named @var{field-name} use the following syntax.
Note the period before the @var{field-name}.
@example
(*:.@var{field-name} @var{instance})
@end example
This syntax works with @code{set!} - to set the field use this syntax:
@example
(set! (*:.@var{field-name} @var{instance}) @var{new-value})
@end example
Here is an example:
@example
(define p (list 3 4 5))
(*:.cdr p) @result{} (4 5)
(set! (*:.cdr p) (list 6 7))
p @result{} (3 6 7)
@end example

You can specify an explicit class:
@example
(@var{prefix}:.@var{field-name} @var{instance})
@end example
If @var{prefix} is bound to @code{<@var{class}>}, then the above
is equivalent to:
@example
(*:.@var{field-name} (as <@var{class}> @var{instance}))
@end example

@subsection Using field and static-field methods

Kawa has both a high-level interface and a low-level interface for accessing
the fields of Java objects and static fields.
The lower-level interfaces are macros that return functions.
These functions can be inlined, producing efficient code.
The higher-level functions are less verbose and more convenient.

@deffn Procedure field object fieldname
Get the instance field with the given @var{fieldname} from the given
@var{Object}.  Returns the value of the field, which must be accessible.
This procedure has a @code{setter}, and so can be used as the first
operand to @code{set!}.

The field name is "mangled" (@pxref{Mangling}) into a valid Java name.
If there is no accessible field whose name is @code{"@var{fieldname}"},
we look for a no-argument method whose name is
@code{"get@var{Fieldname}"} (or @code{"is@var{Fieldname}"} for a
boolean property).

If @var{object} is a primitive Java array, then @var{fieldname} can only
be @code{'length}, and the result is the number of elements of the array.
@end deffn

@deffn Procedure static-field class fieldname
Get the static field with the given @var{fieldname} from the given
@var{class}.  Returns the value of the field, which must be accessible.
This procedure has a @code{setter}, and so can be used as the first
operand to @code{set!}.

If the @var{fieldname} is the special name @code{class},
then it returns the @code{java.lang.Class} object corresponding to
@var{class} (which is usually a @code{gnu.bytecode.ClassType} object).
@end deffn

Examples:
@example
(static-field <java.lang.System> 'err)
;; Copy the car field of b into a.
(set! (field a 'car) (field b 'car))
@end example

@deffn Procedure slot-ref object fieldname
A synonym for @code{(field @var{object} @var{fieldname})}.
@end deffn

@deffn Procedure slot-set! object fieldname value
A synonym for @code{(set! (field @var{object} @var{fieldname}) @var{value})}.
@end deffn

@node Mangling, Scheme types in Java, Field operations, Objects Classes and Modules
@section Mapping Scheme names to Java names

Programs use "names" to refer to various values and procedures.
The definition of what is a "name" is different in different
programming languages.  A name in Scheme (and other Lisp-like
languages) can in principle contain any character (if using a
suitable quoting convention), but typically names consist of
"words" (one or more letters) separated by hyphens, such
as @samp{make-temporary-file}.  Digits
and some special symbols are also used.  Standard Scheme
is case-insensitive;  this means that the names @samp{loop},
@samp{Loop}, and @samp{LOOP} are all the same name.  Kawa
is by default case-sensitive, but we recommend that you
avoid using upper-case letters as a general rule.

The Java language and the Java virtual machine uses names for
classes, variables, fields and methods.  These names can
contain upper- and lower-case letters, digits, and the special
symbols @samp{_} and @samp{$}.

Given a name in a Scheme program,
Kawa needs to map that name into a valid Java name.  A typical
Scheme name such as @samp{make-temporary-file} is not a valid
Java name.  The convention for Java names is to use
"mixed-case" words, such as @samp{makeTemporaryFile}.
So Kawa will translate a Scheme-style name into a Java-style
name.  The basic rule is simple:  Hyphens are dropped, and
a letter that follows a hyphen is translated to its
upper-case (actually "title-case") equivalent.  Otherwise,
letters are translated as is.

Some special characters are handled specially.  A final @samp{?}
is replaced by an @emph{initial} @samp{is}, with the following
letter converted to titlecase.  Thus @samp{number?} is
converted to @samp{isNumber} (which fits with Java conventions),
and @samp{file-exists?} is converted to @samp{isFileExists}
(which doesn't really).
The pair @samp{->} is translated to @samp{$To$}.
For example @samp{list->string} is translated to @samp{list$To$string}.

Some symbols are mapped to a mnemonic sequence, starting with a dollar-sign,
followed by a two-character abbreviation.  For example, the less-than
symbol @samp{<} is mangled as @samp{$Ls}.
See the source code to the @code{mangleName} method in the
@code{gnu.expr.Compilation} class for the full list.
Characters that do not have a mnemonic abbreviation are
mangled as @samp{$} followed by a four-hex-digit unicode value.
For example @samp{Tamil vowel sign ai} is mangled as @samp{$0bc8}.

Note that this mapping may map different Scheme names to the
same Java name.  For example @samp{string?}, @samp{String?},
@samp{is-string}, @samp{is-String},
and @samp{isString} are all mapped to the same Java identifier
@samp{isString}.  Code that uses such "Java-clashing" names
is @emph{not} supported.  There is very partial support for
renaming names in the case of a clash, and there may be better
support in the future.  However, some of the nice features of
Kawa depend on being able to map Scheme name to Java names
naturally, so we urge you to @emph{not} write code that
"mixes" naming conventions by using (say) the names @samp{open-file}
and @samp{openFile} to name two different objects.

The above mangling is used to generate Java method names.
Each top-level definition is also mapped to a Java field.
The name of this field is also mangled, but using a mostly
reversible mapping:  The Scheme function @samp{file-exists?}
is mapped to the method name @samp{file$Mnexists$Qu}.
Because @samp{$} is used to encode special characters, you
should avoid using it in names in your source file.

@node Scheme types in Java, Array operations, Mangling, Objects Classes and Modules
@section Scheme types in Java

All Scheme values are implemented by sub-classes of @samp{java.lang.Object}.

Scheme symbols are implemented using @code{java.lang.String}.
(Don't be confused by the fact the Scheme sybols are represented
using Java Strings, while Scheme strings are represented by
@code{gnu.lists.FString}.  It is just that the semantics of Java strings
match Scheme symbols, but do not match mutable Scheme strings.)
Interned symbols are presented as interned Strings.
(Note that with JDK 1.1 string literals are automatically interned.)

Scheme integers are implemented by @code{gnu.math.IntNum}.
Use the make static function to create a new IntNum from an int or a long.
Use the intValue or longValue methods to get the int or long value of
an IntNum.

A Scheme "flonum" is implemented by @code{gnu.math.DFloNum}.

A Scheme pair is implemented by @code{gnu.lists.Pair}.

A Scheme vector is implemented by @code{gnu.lists.FVectror}.

Scheme characters are implemented using @code{gnu.text.Char}.

Scheme strings are implemented using @code{gnu.lists.FString}.

Scheme procedures are all sub-classes of @code{gnu.mapping.Procedure}.
The "action" of a @samp{Procedure} is invoked by using one of
the @samp{apply*} methods:  @samp{apply0}, @samp{apply1},
@samp{apply2}, @samp{apply3}, @samp{apply4}, or @samp{applyN}.
Various sub-class of @samp{Procedure} provide defaults
for the various @samp{apply*} methods.  For example,
a @samp{Procedure2} is used by 2-argument procedures.
The @samp{Procedure2} class provides implementations of all
the @samp{apply*} methods @emph{except} @samp{apply2},
which must be provided by any class that extends @code{Procedure2}.

@node Array operations, Loading Java functions into Scheme, Scheme types in Java, Objects Classes and Modules
@section Using Java Arrays

@subsection Creating new Java arrays
@anchor{Creating-new-Java-arrays}
To allocate a Java array you can use the array type specifier
as a constructor function.  For example, to allocate an array with room for 10 elements
each of each is a primitive @code{int}:
@example
(int[] length: 10)
@end example

You can specify the initial elements instead of the length:
@example
(object[] 31 32 33 34)
@end example
This creates a 4-length array, initialized to the given values.

Note this is a variation of the generation object-allocation
(@pxref{Allocating objects}) pattern.  You can explicitly
use the @code{make} function, if you prefer:
@example
(make object[] 31 32 33 34)
@end example

If you specify a length, you can also specify initial values for selected
elements.
If you specify an index, in the form of a literal integer-valued keyword,
then following elements are placed starting at that position.
@example
(int[] length: 100 10 12 80: 15 16 50: 13 14)
@end example
This creates an array with 100 elements.  Most of them are initialized
to the default value of zero,
but elements with indexes 0, 1, 50, 51, 80, 81 are initialized
to the values 10, 12, 13, 14, 15, 16, respectively.

@subsection Accessing Java array elements

You can access the elements of a Java array by treating it as
a one-argument function, where the argument is the index:
@example
(define primes (integer[] 2 3 5 7 11 13))
(primes 0) @result{} 2
(primes 5) @result{} 13
@end example

You can set an element by treating the array as a function
with a @code{setter}:
@example
(set! (primes 0) -2)
(set! (primes 3) -7)
primes @result{} [-2 3 5 -7 11 13]
@end example

To get the number of elements of an array, you can treat
it as having a @code{length} field:
@example
primes:length @result{} 6
@end example

Here is a longer example.  This is the actual definition of the
standard @code{gcd} function.  Note the @code{args} variable
receives all the arguments on the form of an @code{integer} array.
(This uses the Java5 varargs feature.)
@example
(define (gcd #!rest (args ::integer[])) ::integer
  (let ((n ::int args:length))
    (if (= n 0)
	0
	(let ((result ::integer (args 0)))
	  (do ((i ::int 1 (+ i 1)))
	      ((>= i n) result)
	    (set! result (gnu.math.IntNum:gcd result (args i))))))))
@end example

The above example generates good code,
thanks to judicious use of casts and type specifications.
In general, if Kawa knows that
a ``function'' is an array then it will generate efficient
bytecode instructions for array operations.

@subsection Old low-level array macros

The deprecated @ref{Low-level array macros} are also supported.

@node Loading Java functions into Scheme, Evaluating Scheme expressions from Java, Array operations, Objects Classes and Modules
@section Loading Java functions into Scheme

When @code{kawa -C} compiles (@pxref{Files compilation}) a Scheme module
it creates a class that implements the @code{java.lang.Runnable} interface.
(Usually it is a class that extends the @code{gnu.expr.ModuleBody}.)
It is actually fairly easy to write similar "modules" by hand in Java,
which is useful when you want to extend Kawa with  new "primitive functions"
written in Java.  For each function you need to create an object that
extends @code{gnu.mapping.Procedure}, and then bind it in the global
environment.  We will look at these two operations.

There are multiple ways you can create a @code{Procedure} object.  Below
is a simple example, using the @code{Procedure1} class, which is class
extending @code{Procedure} that can be useful for one-argument
procedure.  You can use other classes to write procedures.  For example
a @code{ProcedureN} takes a variable number of arguments, and you must
define @code{applyN(Object[] args)} method instead of @code{apply1}.
(You may notice that some builtin classes extend @code{CpsProcedure}.
Doing so allows has certain advantages, including support for
full tail-recursion, but it has some costs, and is a bit trickier.)

@example
import gnu.mapping.*;
import gnu.math.*;
public class MyFunc extends Procedure1
@{
  // An "argument" that is part of each procedure instance.
  private Object arg0;

  public MyFunc(String name, Object arg0)
  @{
    super(name);
    this.arg0 = arg0;
  @}

  public Object apply1 (Object arg1)
  @{
    // Here you can so whatever you want. In this example,
    // we return a pair of the argument and arg0.
    return gnu.lists.Pair.make(arg0, arg1);
  @}
@}
@end example

You can create a @code{MyFunc} instance and call it from Java:
@example
  Procedure myfunc1 = new MyFunc("my-func-1", Boolean.FALSE);
  Object aresult = myfunc1.apply1(some_object);
@end example
The name @code{my-func-1} is used when @code{myfunc1} is printed
or when @code{myfunc1.toString()} is called.  However,
the Scheme variable @code{my-func-1} is still not bound.
To define the function to Scheme, we can create
a "module", which is a class intended to be loaded
into the top-level environment.  The provides the definitions to be
loaded, as well as any actions to be performed on loading 

@example
public class MyModule
@{
  // Define a function instance.
  public static final MyFunc myfunc1
    = new MyFunc("my-func-1", IntNum.make(1));
@}
@end example

If you use Scheme you can use @code{require}:
@example
#|kawa:1|# (require <MyModule>)
#|kawa:2|# (my-func-1 0)
(1 0)
@end example

Note that @code{require} magically defines @code{my-func-1} without
you telling it to.  For each public final
field, the name and value of the field are entered in the
top-level environment when the class is loaded.  (If there are
non-static fields, or the class implements @code{Runnable}, then
an instance of the object is created, if one isn't available.)
If the field value is a @code{Procedure} (or implements @code{Named}),
then the name bound to the procedure is used instead of the field name.
That is why the variable that gets bound in the Scheme environment is
@code{my-func-1}, not @code{myfunc1}.

Instead of @code{(require <MyModule>)}, you can do @code{(load "MyModule")}
or @code{(load "MyModule.class")}.
If you're not using Scheme, you can use Kawa's @code{-f} option:
@example
$ kawa -f MyModule --xquery --
#|kawa:1|# my-func-1(3+4)
<list>1 7</list>
@end example

If you need to do some more complex calculations when a module is loaded,
you can put them in a @code{run} method, and have the module
implement @code{Runnable}:

@example
public class MyModule implements Runnable
@{
  public void run ()
  @{
    Interpreter interp = Interpreter.getInterpreter();
    Object arg = Boolean.TRUE;
    interp.defineFunction (new MyFunc ("my-func-t", arg));
    System.err.println("MyModule loaded");
  @}
@}
@end example

Loading @code{MyModule} causes @code{"MyModule loaded"} to be printed,
and @code{my-func-t} to be defined.  Using @code{Interpreter}'s
@code{defineFunction} method is recommended because it does the righ
things even for languages like Common Lisp that use separate
"namespaces" for variables and functions.

A final trick is that you can have a @code{Procedure} be its own module:

@example
import gnu.mapping.*;
import gnu.math.*;
public class MyFunc2 extends Procedure2
@{
  public MyFunc(String name)
  @{
    super(name);
  @}

  public Object apply2 (Object arg1, arg2)
  @{
    return gnu.lists.Pair.make(arg1, arg2);
  @}

  public static final MyFunc myfunc1 = new MyFunc("my-func-2);
@}
@end example

@node Evaluating Scheme expressions from Java, , Loading Java functions into Scheme, Objects Classes and Modules
@section Evaluating Scheme expressions from Java

The following methods are recommended if you need to evaluate a
Scheme expression from a Java method.
(Some details (such as the @samp{throws} lists) may change.)

@deftypefn {Static method} void Scheme.registerEnvironment ()
Initializes the Scheme environment.  Maybe needed if you
try to load a module compiled from a Scheme source file.
@end deftypefn

@deftypefn {Static method} Object Scheme.eval (InPort @var{port}, Environment @var{env})
Read expressions from @var{port}, and evaluate them in the
@var{env} environment, until end-of-file is reached.
Return the value of the last expression,
or @code{Interpreter.voidObject} if there is no expression.
@end deftypefn

@deftypefn {Static method} Object Scheme.eval (String @var{string}, Environment @var{env})
Read expressions from @var{string}, and evaluate them in the
@var{env} environment, until the end of the string is reached.
Return the value of the last expression,
or @code{Interpreter.voidObject} if there is no expression.
@end deftypefn

@deftypefn {Static method} Object Scheme.eval (Object @var{sexpr}, Environment @var{env})
The @var{sexpr} is an S-expression (as may be returned by @code{read}).
Evaluate it in the @var{env} environment, and return the result.
@end deftypefn

For the @code{Environment} in most cases you could use
@samp{Environment.current()}.  Before you start, you
need to initialize the global environment,
which you can with
@example
Environment.setCurrent(new Scheme().getEnvironment());
@end example

Alternatively, rather than setting the global environment,
you can use this style:
@example
Scheme scm = new Scheme();
Object x = scm.eval("(+ 3 2)");
System.out.println(x);
@end example

@node XML tools, Low-level functions, Objects Classes and Modules, Top
@chapter Working with XML and HTML

Kawa has a number of features for working with XML, HTML,
and generated web pages.

In Kawa you don't write XML or HTML directly.
Instead you write expressions that evaluate to ``node objects''
corresponding to elements, attributes, and text.
You then write these node objects using either an XML or HTML format.

Many web-page-generating tools require you to work directly
with raw HTML, as for example:
@example
(display "<p>Don't use the <code>&lt;blink&gt;</code> tag.</p>")
@end example

In Kawa you would instead do:
@example
(display (html:p "Don't use the " (html:code "<blink>") " tag."))
@end example

The conversion from node objects to XML or HTML is handled by
the formatter (or serializer).
Some advantages of doing it this way are:
@itemize
@item
You don't have to worry about quoting special characters.
Missing or incorrect quoting is a common source of bugs
and security problems on systems that work directly with text, such as PHP.
@item
Some errors such as mismatched element tags are automatically avoided.
@item
The generated generated XML can be validated as it is generated,
or even using compile-time type-checking.  (Kawa doesn't yet do either.)
@item
In application that also reads XML,
you can treat XML that is read in and XML that is generated using
the same functions.
@end itemize

@menu
* Formatting XML::
* Creating HTML nodes::
* Creating XML nodes::
* XML literals::
* Server-side scripts::  Writing web-server-side Kawa scripts
* Self-configuring page scripts::
* Servlets::             Installing Kawa programs as Servlets
* CGI scripts::          Installing Kawa programs as CGI scripts
* HTTP requests::        Functions for accessing HTTP requests
* HTTP response::        Functions for generating HTTP response
* XML beyond Scheme::    Using non-Scheme languages for XML/HTML
@end menu

@node Formatting XML, Creating HTML nodes, , XML tools
@section Formatting XML

The easiest way to generate HTML or XML output is to run Kawa
with the appropriate @ref{Named output formats, , @code{--output-format} option}.

The intentation is that these output modes should be compatible with
@uref{http://www.w3.org/TR/2006/PR-xslt-xquery-serialization-20061121/,
XSLT 2.0 and XQuery 1.0 Serialization}.
(However, that specifies many options, most
of which have not yet been implemented.

@table @code
@item xml
Values are printed in XML format.
"Groups" or "elements" are written as using xml element syntax.
Plain characters (such as @samp{<}) are escaped (such as @samp{&lt;}).
@item xhtml
Same as @code{xml}, but follows the xhtml compatibility guidelines.
@item html
Values are printed in HTML format.
Mostly same as @code{xml} format, but certain elements without body,
are written without a closing tag.   For example @code{<img>} is written
without @code{</img>}, which would be illegal for html, but required for xml.
Plain characters (such as @samp{<}) are not escaped inside @code{<script>}
or @code{<style>} elements.
@end table

To illustrate:
@example
$ kawa --output-format html
#|kawa:1|# (html:img src:"img.jpg")
<img src="img.jpg">
@end example
@example
$ kawa --output-format xhtml
#|kawa:1|# (html:img src:"img.jpg")
<img xmlns="http://www.w3.org/1999/xhtml" src="img.jpg" />
@end example
@example
$ kawa --output-format xml
#|kawa:1|# (html:img src:"img.jpg")
<img xmlns="http://www.w3.org/1999/xhtml" src="img.jpg"></img>
@end example
And here is the default @code{scheme} formatting:
@example
$ kawa
#|kawa:1|# (html:img src:"img.jpg")
(@{http://www.w3.org/1999/xhtml@}img src: img.jpg )
@end example

@deffn Procedure as-xml value
Return a value (or multiple values) that when printed will
print @var{value} in XML syntax.
@example
(require 'xml)
(as-xml (make-element 'p "Some " (make-element 'em "text") "."))
@end example
prints @code{<p>Some <em>text</em>.</p>}.
@end deffn

@deffn Procedure unescaped-data data
Creates a special value which causes @code{data} to be printed,
as is, without normal escaping.  For example, when the output format
is XML, then printing @code{"<?xml?>"} prints as @samp{&lt;?xml?&gt;},
but @code{(unescaped-data "<?xml?>")} prints as  @samp{<?xml?>}.
@end deffn

@node Creating HTML nodes, Creating XML nodes, Formatting XML, XML tools
@section Creating HTML nodes

The @code{html} prefix names a special namespace
(@pxref{Namespaces}) of functions to create HTML element nodes.
For example, @code{html:em} is a constructor that
when called creates a element node whose tag is @code{em}.
If this element node is formatted as HTML, the
result has an @code{<em>} tag.

@deffn Syntax html:@var{tag} attributes ... content ...
Creates an element node whose tag is @var{tag}.
The parameters are first zero or more attributes, followed
by zero of more child values.
An attribute is either an attribute value (possibly
created using @code{make-attribute}), or a pair of arguments:
A keyword followed by the attribute value.
Child values are usually either strings (text content),
or nested element nodes, but can also be comment or processing-instruction
nodes.
@example
(html:a href: "http://gnu.org/" "the "(html:i "GNU")" homepage")
@end example
@end deffn

The compound identifier @code{html:@var{tag}} is actually
a type: When you call it as a function you're using Kawa's
standard coercion of a type to its constructor function.
This means you can do type tests:
@example
(define some-node ...)
(if (instance? some-node html:blink)
  (error "blinking not allowed!"))
@end example

Object identity is currently not fully specified.  Specifically,
it is undefined if a nested (child) element node is copied
``by value'' or ``by reference''.  This is related to whether
nodes have a parent reference.  In the XPath/XQuery data model
nodes do have a parent reference, and child nodes are conceptually
copied.  (In the actual implemention copying is commonly avoided.)
Kawa/Scheme currently followed the XQuery copying semantics,
which may not be the most appropriate for Scheme.

@node Creating XML nodes, XML literals, Creating HTML nodes, XML tools
@section Creating XML nodes

The XML data model is similar to HTML, with one important addition:
XML tags may be @dfn{qualified names}, which are similar
to @ref{Namespaces, , compound symbols}.

You must do this to use the following types and functions:
@example
(require 'xml)
@end example

The following types and functions assume:
@example
(require 'xml)
@end example

@deffn Procedure make-element tag [attribute ...] child ...
Create a representation of a XML element, corresponding to
@example
<@var{tag} @var{attribute}...>@var{child}...</@var{tag}>
@end example
The result is a @code{TreeList}, though if the result context is a consumer
the result is instead "written" to the consumer.
Thus nested calls to @code{make-element} only result in a
single @code{TreeList}.
More generally, whether an @var{attribute} or @var{child} is includded
by copying or by reference is (for now) undefined.
The @var{tag} should currently be a symbol, though in the future it should
be a qualified name.
An @var{attribute} is typically a call to @code{make-attribute},
but it can be any attribute-valued expression.
@example
(make-element 'p
	      "The time is now: "
	      (make-element 'code (make <java.util.Date>)))
@end example
@end deffn

@deffn Procedure element-name element
Returns the name (tag) of the element node, as a symbol (QName).
@end deffn

@deffn Procedure make-attribute name value...
Create an "attribute", which is a name-value pair.
For now, @var{name} should be a symbol.
@end deffn

@deffn Procedure attribute-name element
Returns the name of the attribute node, as a symbol (QName).
@end deffn

@deffn Type comment
Instances of this type represent comment values,
specifically including comments in XML files.
Comment nodes are currently ignored when printing using Scheme formatting,
though that may change.
@end deffn
@deffn Constructor comment comment-text
Create a comment object with the specified @var{comment-text}.
@end deffn

@deffn Type processing-instruction
Instances of this type represent ``processing instructions'',
such as may appear in XML files.
Processing-instruction nodes are currently ignored when printing using
Scheme formatting, though that may change.
@end deffn
@deffn Constructor processing-instruction target contents
Crreate a processing-instruction object with the specified @var{target}
(a simple symbol) and @var{contents} (a string).
@end deffn

@node XML literals, Server-side scripts, Creating XML nodes, XML tools
@section XML literals

You can write XML literals directly in Scheme code,
following a @code{#}.
Notice that the outermost element needs to be prefixed
by @code{#}, but nested elements do (and must not).
@example
#<p>The result is <b>final</b>!</p>
@end example

Actually, these are not really literals since they can contain
enclosed expressions:
@example
#<em>The result is &@{result@}.</em>
@end example
The value of @var{result} is substituted into the output,
in a similar way to quasi-quotation.
(If you try to quote one of these ``XML literals'',
what you get is unspecified and is subject to change.)

An @var{xml-literal} is usually an element constructor,
but there some rarely used forms (processing-instructions,
comments, and CDATA section) we'll cover later.

@display
@stxdef{xml-literal} @stxlit{#}@stxref{xml-constructor}
@stxdef{xml-constructor} @stxref{xml-element-constructor}
  | @stxref{xml-PI-constructor}
  | @stxref{xml-comment-constructor}
  | @stxref{xml-CDATA-constructor}
@end display

@subsection Element constructors

@display
@stxdef{xml-element-constructor}
    @stxlit{<}@stxref{QName} @stxref{xml-attribute}*@stxlit{>}@stxref{xml-element-datum}...@stxlit{</}@stxref{QName} @stxlit{>}
  | @stxlit{<}@stxref{xml-name-form} @stxref{xml-attribute}*@stxlit{>}@stxref{xml-element-datum}...@stxlit{</>}
  | @stxlit{<}@var{xml-name-form} @stxref{xml-attribute}*@stxlit{/>}
@stxdef{xml-name-form} @stxref{QName}
  | @stxref{xml-enclosed-expression}
@stxdef{xml-enclosed-expression}
    @stxlitlbrace{}@stxref{expression}@stxlitat{}
  | @stxlit{(}@stxref{expression}...@stxlit{)}
@end display

The first @var{xml-element-constructor} variant uses a literal @var{QName},
and looks like standard non-empty XML element, where the starting @var{QName}
and the ending @var{QName} must match exactly:

@example
#<a href="next.html">Next</a>
@end example

As a convenience, you can leave out the ending tag(s):
@example
<para>This is a paragraph in <emphasis>DocBook</> syntax.</>
@end example

You can use an expression to compute the element tag at runtime -
in that case you @emph{must} leave out the ending tag:
@example
#<p>This is <(if be-bold 'strong 'em)>important</>!</p>
@end example

You can use arbitrary @var{expression} inside curly braces,
as long as it evaluates to a symbol.
You can leave out the curly braces
if the @var{expression} is a simple parenthesised compound expression.
The previous example is equivalent to:
@example
#<p>This is <@{(if be-bold 'strong 'em)@}>important</>!</p>
@end example

The third @var{xml-element-constructor} variant above is an XML
``empty element''; it is equivalent to the second variant
when there are no @var{xml-element-datum} items.

(Note that every well-formed XML element, as defined in the XML specifications,
is a valid @var{xml-element-constructor}, but not vice versa.)

@subsection Elements contents (children)

The ``contents'' (children) of an element
are a sequence of character (text) data, and nested nodes.
The characters @code{&}, @code{<}, and @code{>} are special,
and need to be escaped.

@display
@stxdef{xml-element-datum}
    any character except @code{&}, or @code{<}.
  | @stxref{xml-constructor}
  | @stxref{xml-escaped}
@stxdef{xml-escaped}
    @stxlit{&}@stxref{xml-enclosed-expression}
  | @stxlit{&}@stxref{xml-entity-name}@stxlit{;}
  | @stxref{xml-character-reference}
@stxdef{xml-character-reference}
    @stxlit{&#}@stxref{digit}+@stxlit{;}
  | @stxlit{&#x}@stxref{hex-digit}+@stxlit{;}
@end display

Here is an example shows both hex and decimal character references:
@example
#<p>A&#66;C&#x44;E</p>  @result{}  <p>ABCDE</p>
@end example

@display
@stxdef{xml-entity-name} @stxref{identifier}
@end display
Currently, the only supported values for @var{xml-entity-name}
are the builtin XML names @code{lt}, @code{gt}, @code{amp},
@code{quot}, and @code{apos}, which stand for the characters
@code{<}, @code{>}, @code{&}, @code{"}, and @code{'}, respectively.
The following two expressions are equivalent:
@example
#<p>&lt; &gt; &amp; &quot; &apos;</p>
#<p>&@{"< > & \" '"@}</p>
@end example

@subsection Attributes

@display
@stxdef{xml-attribute}
    @stxref{xml-name-form}@stxlit{=}@stxref{xml-attribute-value}
@stxdef{xml-attribute-value}
    @stxlit{"}@stxref{quot-attribute-datum}*@stxlit{"}
  | @stxlit{'}@stxref{apos-attribute-datum}*@stxlit{'}
@stxdef{quot-attribute-datum}
    any character except @code{"}, @code{&}, or @code{<}.
  | @stxref{xml-escaped}
@stxdef{apos-attribute-datum}
    any character except @code{'}, @code{&}, or @code{<}.
  | @stxref{xml-escaped}
@end display

If the @var{xml-name-form} is either @code{xmlns} or
a compound named with the prefix @code{xmlns}, then
technically we have a namespace declaration, rather than
an attribute.

@subsection QNames and namespaces

The names of elements and attributes are @dfn{qualified names}
(QNames), which are represented using compound symbols (@pxref{Namespaces}).
The lexical syntax for a QName is either a simple identifier,
or a (prefix,local-name) pair:

@display
@stxdef{QName} @stxref{xml-local-part}
   | @stxref{xml-prefix}@stxlit{:}@stxref{xml-local-part}
@stxdef{xml-local-part} @stxref{identifier}
@stxdef{xml-prefix} @stxref{identifier}
@end display

An @var{xml-prefix} is an alias for a namespace-uri,
and the mapping between them is defined by a namespace-declaration.
You can either use a @code{define-namespace} form, or you
can use a @dfn{namespace declaration attribute}:

@display
@stxdef{xml-namespace-declaration-attribute}
    @stxlit{xmlns:}@stxref{xml-prefix}@stxlit{=}@stxref{xml-attribute-value}
  | @stxlit{xmlns=}@stxref{xml-attribute-value}
@end display

The former declares @var{xml-prefix} as a namespace alias for
the namespace-uri specified by @var{xml-attribute-value}
(which must be a compile-time constant).
The second declares that @var{xml-attribute-value} is the default
namespace for simple (unprefixed) element tags.
(A default namespace declaration is ignored for attribute names.)

@example
(let ((qn (element-name #<gnu:b xmlns:gnu="http://gnu.org/"/>)))
  (list (symbol-local-name qn)
        (symbol-prefix qn)
        (symbol-namespace-uri qn)))
@result{} ("b" "gnu" "http://gnu.org/")

@end example

@subsection Other XML types

@subsubsection Processing instructions

An @var{xml-PI-constructor} can be used to create an XML
@dfn{processing instruction}, which can be used to pass
instructions or annotations to an XML processor (or tool).
(Alternatively, you can use the @code{processing-instruction}
type constructor.)

@display
@stxdef{xml-PI-constructor} @stxlit{<?}@stxref{xml-PI-target} @stxref{xml-PI-content}@stxlit{?>}
@stxdef{xml-PI-target} @var{NCname} (i.e. a simple (non-compound) identifier)
@stxdef{xml-PI-content} any characters, not containing @code{?>}.
@end display

For example, the DocBook XSLT stylesheets can use the @code{dbhtml}
instructions to specify that a specific chapter should be
written to a named HTML file:
@example
#<chapter><?dbhtml filename="intro.html" ?>
<title>Introduction</title>
...
</chapter>
@end example

@subsubsection XML comments

You can cause XML comments to be emitted in the XML output document.
Such comments can be useful for humans reading the XML document,
but are usually ignored by programs.
(Alternatively, you can use the @code{comment} type constructor.)

@display
@stxdef{xml-comment-constructor} @stxlit{<!--}@stxref{xml-comment-content}@stxlit{-->}
@stxdef{xml-comment-content} any characters, not containing @code{--}.
@end display

@subsubsection CDATA sections

A @code{CDATA} section can be used to avoid excessive use of
@var{xml-entity-ref} such as @code{&amp;} in element content.

@display
@stxdef{xml-CDATA-constructor} @stxlit{<![CDATA[}@stxref{xml-CDATA-content}@stxlit{]]>}
@stxdef{xml-CDATA-content} any characters, not containing @code{]]>}.
@end display

The following are equivalent:
@example
#<p>Specal characters <![CDATA[< > & ' "]]> here.</p>
#<p>Specal characters &lt; &gt; &amp; &quot; &apos; here.</p>
@end example

Kawa remembers that you used a @code{CDATA} section in
the @var{xml-element-constructor} and will write it out
using a @code{CDATA} constructor.

@node Server-side scripts, Self-configuring page scripts, XML literals, XML tools
@section Web page scripts

A Kawa @dfn{web page script} is a Kawa program that is invoked
by a web server because the server received an HTTP request.
The result of evaluating the top-level expressions becomes
the HTTP response that the servlet sends back to the client, usually a browser.

A web page script may be as simple as:
@example
(format "The time is <~s>." (java.util.Date))
@end example
This returns a response of consisting of a formatted string
giving the current time.
The string would interpreted as @code{text/plain} content:
The angle brackets are regular characters, and not
HTML tag markers.

The script can alternatively evaluate to XML/HTML node
values, for example those created by @ref{XML literals}:
@example
#<p>Hello, <b>&(request-remote-host)</b>!</p>
@end example
In this case the response would be @code{text/html} or similar content:
The angle brackets should be interpreted by the browser as HTML tag markers.
The function @code{request-remote-host} is available (automatically)
to web page scripts; it returns the host that made the HTTP request,
which is then interpolated into the response.

Following sections will go into more details about how
to write web page scripts.  You can do so in any supported
Kawa language, including Scheme, BRL, KRL, or XQuery.

A web server will use a URL mapping to map a request URL
to a specific web page script.  This can be done in a
number of different ways:
@itemize
@item
The easiest to manage is to use Kawa's mechanism for
@ref{Self-configuring page scripts}.  Ths is especially
easy if you the web server built in to JDK 6, since no
configuration files are needed.
You can also use a ``serlvet engine'' like Tomcat or Glassfish.

@item
You can explicitly compile the web page script to a servlet,
in the same way Java servlets are compiled.
This can then be installed ("deployed") in a servlet-supporting
web server, such a Tomcat or Glassfish.  @xref{Servlets}.
@item
You can run the servlet as a @ref{CGI scripts,CGI script}.
@end itemize

For details on how to extract information from the request
see @ref{HTTP requests}.
For details on how the response is created see @ref{HTTP response,Generating HTTP responses}.
If the response is HTML or XML, you may want to
read @ref{Creating HTML nodes}, or @ref{Creating XML nodes},
or @ref{XML literals}.

Here are some examples, starting with a simple @code{hello.scm}:
@example
(response-content-type 'text/html) ; Optional
(html:p
  "The request URL was: " (request-url))
(make-element 'p
  (let ((query (request-query-string)))
    (if query
      (values-append "The query string was: " query)
      "There was no query string.")))
@end example
This returns two @code{<p>} (paragraph) elements: One using
@code{make-element} and one using the @code{html:p} constructor.
Or you may prefer to use @ref{XML literals}.

The same program using KRL:
@example
<p>The request URL was: [(request-url)]</p>,
<p>[(let ((query (request-query-string)))
    (if query
      (begin ]The query string was: [query)

      ]There was no query string.[))]</p>
@end example

You can also use XQuery:
@example
<p>The request URL was: @{request-url()@}</p>
<p>@{let $query := request-query-string() return
    if ($query)
    then ("The query string was: ",$query)
    else "There was no query string."@}</p>
@end example

@node Self-configuring page scripts, Servlets, Server-side scripts, XML tools
@section Self-configuring web page scripts

Kawa makes it easy to set up a web site without configuration
files.  Instead, the mapping from request URL to web page script
matches the layout of files in the application directory.

Many web servers make it easy to execute a script using a script
processor which is selected depending on the extension of the
requested URL. That is why you see lots of URLs that end in
@code{.cgi}, @code{.php}, or @code{.jsp}. This is bad, because it
exposes the server-side implementation to the user: Not only are such
URLs ugly, but they make it difficult to change the server without
breaking people's bookmarks and search engines. A server will usually
provide a mechanism to use prettier URLs, but doing so requires extra
effort, so many web-masters don't.

If you want a script to be executed in response to a URL
@code{http://host/app/foo/bar} you give the script the name
@code{app/foo/bar}, in the appropriate server ``application''
directory (as explained below). You get to pick the name @code{bar}.
Or you can use the name @code{bar.html}, even though the file named
@code{bar.html} isn't actually
an html file - rather it produces html when evaluated. Or better: just use
a name without an extension at all.
Kawa figures
out what kind of script it is based on the content of the file,
rather than the file name.  Once Kawa has
found a script, it looks at the first line to see if it can recognize
the kind (language) of the script. Normally this would be a comment
that contains the name of a programming language that Kawa
knows about.  For example:
@example
;; Hello world page script written in -*- scheme -*- 
#<p>Hello, <b>&(request-remote-host)</b>!</p>
@end example
(Using the funny-looking string @code{-*- scheme -*-} has the
bonus is that it recognized by the Emacs text editor.)

A script named @code{+default+} is run if there isn't a matching script.
For example assume the following is a file named @code{+default}.
@example
;; This is -*- scheme -*-
(make-element 'p "servlet-path: " (request-servlet-path))
@end example
This becomes the default script for HTTP requests that aren't handled
by a more specific script. 
The @code{request-servlet-path} function
returns the "servlet path", which is the part of the requested URL
that is relative to the current web application. Thus a request for
@code{http://host:port/app/this/is/a/test} will return:
@example
servlet-path: /this/is/a/test
@end example

@subsection Using the JDK 6 built-in web server

The easiest way to run a Kawa web server is to
use the web server built in to JDK 6, the standard Java 6 distribution
shipped by Sun/Oracle.

@example
kawa --http-auto-handler @var{context-path} @var{appdir} --http-start @var{port}
@end example

This starts a web server that listens on the given @var{port},
using the files in directory @var{appdir} to handle
requests that start with the given @var{context-path}.

You can specify multiple @code{--http-auto-handler} options.

For example use the files in the current directory to handle
all requests on the standard port 80 do:
@example
kawa --http-auto-handler / . --http-start 80
@end example

There are some examples in the @code{testsuite/webtest} directory
the Kawa source distribution.  You can start the server thus:
@example
bin/kawa --http-auto-handler / testsuite/webtest/ --http-start 8888
@end example
and then for example browse to @code{http://localhost:8888/adder.scm}.

@subsection Using a servlet container

You can also can use a ``servlet container''
such as Tomcat or Glassfish with self-configuring script.
See @ref{Servlets} for information on how to install
these servers, and the concept of web applications.
Once you have these server installed, you create a
web application with the following in the
@code{@var{appdir}/WEB-INF/web.xml} configuration file:
@example
<web-app>
  <display-name>Kawa auto-servlet</display-name>
  <servlet>
    <servlet-name>KawaPageServlet</servlet-name>
    <servlet-class>gnu.kawa.servlet.KawaPageServlet</servlet-class>
  </servlet>
  <servlet-mapping>
    <servlet-name>KawaPageServlet</servlet-name>
    <url-pattern>/*</url-pattern>
  </servlet-mapping>
</web-app>
@end example
This creates a web application where all URLs
are handled by the @code{gnu.kawa.servlet.KawaPageServlet} servlet class,
which is included in the Kawa jar file.
The @code{KawaPageServlet} class handles the searching
and compiling described in this page.

@subsection Finding a matching script

When Kawa receives a request for:
@example
http://host:port/appname/a/b/anything
@end example
it will look for a file:
@example
@var{appdir}/a/b/anything
@end example

If such a file exists, the script will be executed, as described
below. If not, it will look for a file name @code{+default+} in the same
directory. If that desn't exist either, it will look for @code{+default+}
in the parent
directory, then the grand-parent directory, and so on until it gets to
the appname web application root directory. So the default script is
this: @code{@var{appdir}/+default}.

If that doesn't exist then Kawa returns a 404 "page not found" error. 

@subsection Determining script language

Once Kawa has found a script file corresponding to a request URL,
it needs to determine if this is a data file or a web page script,
and in the latter case, what language it is written in.

Kawa recognizes the following "magic strings" in the first line of a script:

@table @code
@item kawa:scheme
The Scheme language.

@item kawa:xquery
The XQuery language.

@item kawa:@var{language}
Some other language known to Kawa.
@end table

Kawa also recognizes Emacs-style "mode specifiers":

@table @code
@item -*- scheme -*-
The Scheme language.
@item -*- xquery -*-
The XQuery language (though Emacs doesn't know about XQuery).
@item -*- emacs-lisp -*-
@itemx -*- elisp -*-
The Emacs Lisp extension language.
@item -*- common-lisp -*-
@itemx -*- lisp -*-
    The Common Lisp language.
@end table

Also, it also recognizes comments in the first two columns of the line:
@table @code
@item ;;
A Scheme or Lisp comment - assumed to be in the Scheme language.
@item (:
Start of an XQuery comment, so assumed to be in the XQuery language.
@end table

If Kawa doesn't recognize the language of a script (and it
isn't named +default+) then it assumes the file is a data file. It
asks the servlet engine to figure out the content type (using the
getMimeType method of ServletContext), and just copies the file into
the response.

@subsection Compilation and caching

Kawa automatically compiles a script into a class. The
class is internal to the server, and is not written out to
disk. (There is an unsupported option to write the compiled file to a
class file, but there is no support to use previously-compiled
classes.) The server then creates a module instance to handle the
actual request, and runs the body (the @code{run} method)
of the script class. On subsequence
requests for the same script, the same class and instance are reused;
only the @code{run} is re-executed.

If the script is changed, then it is re-compiled and a new module
instance created. This makes it very easy to develop and modify a
script. (Kawa for performance reasons doesn't check more
than once a second whether a script has been modified.)

@node Servlets, CGI scripts, Self-configuring page scripts, XML tools
@section Installing web page scripts as Servlets

You can compile a Kawa program to a @uref{http://en.wikipedia.org/wiki/Java_Servlet,Servlet}, and run it
in a servlet engine (a Servlet-aware web server).
One or more servlets are installed together as a web application.
This section includes specific information for
the Tomcat and Glassfish web servers.

@subsection Creating a web application

A @dfn{web application} is a group of data, servlets, and
configuration files to handle a related set of URLs.
The @uref{http://jcp.org/aboutJava/communityprocess/final/jsr315/index.html,
servlet specification}
specifies the directory structure of a web application.

Assume the web application is called @code{myapp}, and lives in a
directory with the same name.  The application normally handles
requests for URLs that start with @code{http://example.com/myapp}.
Most files in the application directory are used to handle
requests with corresponding URL.  For example,
a file @code{myapp/list/help.html} would be the response
to the request @code{http://example.com/myapp/list/help.html}.

The directory @code{WEB-INF} is special.  It contains configuration
files, library code, and other server data.

So to create the @code{myapp} application, start with:
@example
mkdir myapp
cd myapp
mkdir WEB-INF WEB-INF/lib WEB-INF/classes
@end example

Copy the Kawa jar from the @code{lib} direcory.
(You can also use a ``hard'' link, but symbolic links may not
work, for security systems.)
@example
cp @var{kawa-home}/kawa-@value{VERSION}.jar WEB-INF/lib/kawa.jar
@end example

You should also create the file @code{WEB-INF/web.xml}.
For now, this is is just a place-holder:
@example
<web-app>
  <display-name>My Application</display-name>
</web-app>
@end example

@subsection Compiling a web page script to a servlet

Assume for simplicity that the source files
are in the @code{WEB-INF/classes} directory, and make that the
current directory:
@example
cd .../myapp/WEB-INF/classes
@end example

Depending on the source language, you compile your script
sing the @code{--servlet} switch:
@example
kawa --servlet -C hello.scm
@end example
or:
@example
kawa --servlet --krl -C hello.krl
@end example
or:
@example
kawa --servlet --xquery -C hello.xql
@end example

This lets the web-application find the compiled servlets.
Finally, you just need to add the new servlet to
the @code{WEB-INF/web.xml} file:
@example
<web-app>
  <display-name>My Application</display-name>

  <servlet>
    <selvlet-name>MyHello</servlet-name>
    <selvlet-class>hello</servlet-class>
  </servlet>

  <servlet-mapping>
    <selvlet-name>MyHello</servlet-name>
    <url-pattern>/hello</url-pattern>
  </servlet-mapping>
</web-app>
@end example

The @code{<servlet>} clause says that the servlet named
@code{MyHello} is implemented by the Java class @code{hello}.
The @code{<servlet-mapping>} clause says that a request
URL @code{/hello} should be handled by the servlet named @code{MyHello}.
The URL is relative to the application context path,
so the actual URL would be @code{http://example.com/myapp/hello}.

@subsection Installing a servlet under Tomcat
@cindex Tomcat

Apache's @uref{http://tomcat.apache.org/,Tomcat} is an open-source
implementation of the servlet specifications.
After you @uref{http://tomcat.apache.org/download-60.cgi, download it},
uncompress it in some convenient location,
which is commonly referred to as @code{$CATALINA_HOME}.

To install your web application, copy/move its directory
to be in the @code{$CATALINA_HOME/webapps} directory.
Thus for the example above you would have
a @code{$CATALINA_HOME/webapps/myapp} directory.

To start or stop Tomcat use the scripts in @code{$CATALINA_HOME/bin}.
For example to start Tomcat on a GNU/Linux system run
@code{$CATALINA_HOME/bin/startup.sh}.  This will start a web server
that listens on the default port of 8080,
so you can browse the above example at @code{http://localhost:8080/myapp/hello}.

If you're running Fedora GNU/Linux, you can use the @code{tomcat6} package:
@example
# yum install tomcat6
# export CATALINA_HOME=/usr/share/tomcat6
@end example
You can the manage Tomcat like other system services.
You can install webapps under @code{$CATALINA_HOME/webapps}.

@subsection Installing a servlet under Glassfish
@cindex Glassfish

@uref{https://glassfish.dev.java.net/,Glassfish} from Oracle/Sun
is a open-source ``application server'' that implements
Java EE 6, including the 3.0 servlet specification.
After you @uref{https://glassfish.dev.java.net/downloads/3.0.1-final.html, download it}, uncompress it in some convenient location.
This location is called @var{as-install-parent} in the
@uref{http://docs.sun.com/app/docs/doc/820-7689/aboaa?a=view,Quick Start Guide}.
The commands you will use is most in @code{@var{as-install}/bin},
where @var{as-install} is @code{@var{as-install}/glassfish}.

To start the server, do:
@example
@var{as-install}/bin/startserv
@end example
or under under Windows:
@example
@var{as-install}\bin\startserv.bat
@end example
The default post to listen to is @code{8080};
you can the port (and lots of other properties)
using the adminstration console at port @code{4848}.

A web application does not need to be any particular
location, instead you just install it with this command:
@example
@var{as-install}/bin/adadmin deploy @var{appdir}
@end example
where @var{appdir} is the application directory - @code{myapp} in the example.
(Use @code{asadmin.bat} under Windows.)

@subsection Servlet-specific script functions

The following functions only work within a servlet container.
To use these functions, first do:
@example
(require 'servlets)
@end example

You can conditionalize your code to check for servlets, like this:

@example
(cond-expand
 (in-servlet
   (require 'servlets)
   (format "[servlet-context: ~s]" (current-servlet-context)))
 (else
   "[Not in a servlet]"))
@end example

@deffn Procedure current-servlet
When called from a Kawa servlet handler, returns the
actual @code{javax.servlet.http.HttpServlet} instance.
@end deffn

@deffn Procedure current-servlet-context
Returns the context of the currently executing servlet,
as an instance of @code{javax.servlet.ServletContext}.
@end deffn

@deffn Procedure current-servlet-config
Returns the @code{ServletConfig} of the currently executing servlet.
@end deffn

@deffn Procedure get-request
Return the current servlet request, as an instance of
@code{javax.servlet.http.HttpServletRequest}.
@end deffn

@deffn Procedure get-response
Return the current servlet response, as an instance of
@code{javax.servlet.http.HttpServletResponse}.
@end deffn

@deffn Procedure request-servlet-path
Get the servlet path of the current request.
Similar to @code{request-script-path}, but not always the same,
depending on configuration, and does @emph{not} end with a @code{"/"}.
@end deffn

@deffn Procedure request-path-info
Get the path info of the current request.
Corresponds to the CGI variable @code{PATH_INFO}.
@end deffn

@deffn Procedure servlet-context-realpath [path]
Returns the file path of the current servlet's "Web application".
@end deffn

@node CGI scripts, HTTP requests, Servlets, XML tools
@section Installing Kawa programs as CGI scripts

The recommended way to have a web-server run a Kawa program
as a CGI script is to compile the Kawa program to a servlet
(as explained in @ref{Server-side scripts}, and then use
Kawa's supplied CGI-to-servlet bridge.

First, compile your program to one or more class files
as explained in @ref{Server-side scripts}.  For example:
@example
kawa --servlet --xquery -C hello.xql
@end example

Then copy the resulting @code{.class} files to your server's
CGI directory.  On Red Hat GNU/Linux, you can do the following (as root):
@example
cp hello*.class /var/www/cgi-bin/
@end example

Next find the @code{cgi-servlet} program that Kawa builds and installs.
If you installed Kawa in the default place, it will be in
@code{/usr/local/bin/cgi-servlet}.
(You'll have this if you installed Kawa from source, but not
if you're just using Kawa @code{.jar} file.)
Copy this program into the same CGI directory:
@example
cp /usr/local/bin/cgi-servlet /var/www/cgi-bin/
@end example

You can link instead of copying:
@example
ln -s /usr/local/bin/cgi-servlet /var/www/cgi-bin/
@end example
However, because of security issues this may not work, so it is
safer to copy the file.  However, if you already have a copy
of @code{cgi-servlet} in the CGI-directory, it is safe to make
a hard link instead of making an extra copy.

Make sure the files have the correct permissions:
@example
chmod a+r /var/www/cgi-bin/hello*.class /var/www/cgi-bin/hello
chmod a+x /var/www/cgi-bin/hello
@end example

Now you should be able to run the Kawa program,
using the URL @url{http://localhost/cgi-bin/hello}.
It may take a few seconds to get the reply, mainly because of the
start-up time of the Java VM.  That is why servlets are
preferred.  Using the CGI interface can still be useful
for testing or when you can't run servlets.

@node HTTP requests, HTTP response, CGI scripts, XML tools
@section Functions for accessing HTTP requests

The following functions are useful for accessing
properties of a HTTP request, in a Kawa program that is
run either as a servlet or a CGI script.  These functions
can be used from plain Scheme, from KRL (whether
in BRL-compatible mode or not), and from XQuery.

The examples below assume the request @code{http://example.com:8080/myapp/foo/bar?val1=xyz&val2=abc}, where @code{myapp} is the application context.
We also assume that this is handled by a script @code{foo/+default+}.

@subsection Request URL components

@deffn Procedure request-URI
Returns the URI of the request, as a value of type @code{URI}.
This excludes the server specification,
but includes the query string.
(It is the combination of CGI variables @code{SCRIPT_NAME},
@code{PATH_INFO}, and @code{QUERY_STRING}.
Using servlets terminology, it is the combination of
Context Path, Servlet Path, PathInfo, and Query String.)
@example
(request-URI) @result{} "/myapp/foo/bar?val1=xyz&val2=abc"
@end example
@end deffn

@deffn Procedure request-path
Returns the URI of the request, as a value of type @code{URI}.
This excludes the server specification and the query string.
Equivalent to @code{(path-file (request-URI))}.
(It is the combination of CGI variables @code{SCRIPT_NAME}, and
@code{PATH_INFO}.
Same as the concatenation of @code{(request-context-path)},
@code{(request-script-path)}, and @code{(request-local-path)}.
Using servlets terminology, it is the combination of
Context Path, Servlet Path, and PathInfo.)
@example
(request-path) @result{} "/myapp/foo/bar"
@end example
@end deffn

@deffn Procedure request-uri
This function is deprecated, because of possible confusion
with @code{request-URI}.  Use @code{request-path} instead.
@end deffn

@deffn Procedure request-url
Returns the complete URL of the request, except the query string.
The result is a @code{java.lang.StringBuffer}.
@example
(request-url) @result{} "http://example.com:8080/myapp/foo/bar"
@end example
@end deffn

@deffn Procedure request-context-path
Returns the context path, relative to the server root.
This is an initial substring of the @code{(request-path)}.
Similar to the Context Path of a servlet request,
except that it ends with a @code{"/"}.
@example
(request-context-path) @result{} "/myapp/"
@end example
@end deffn

@deffn Procedure request-script-path
Returns the path of the script, relative to the context.
This is either an empty string, or a string that ends with @code{"/"},
but does not start with one. (The reason for this is to produce URIs
that work better with operations like @code{resolve-uri}.)
This is conceptually similar to @code{request-servlet-path},
though not always the same, and the @code{"/"} conventions differ.
@example
(request-script-path) @result{} "foo/"
@end example
@end deffn

@deffn Procedure request-local-path
Returns the remainder of the @code{request-path},
relative to the @code{request-script-path}.
@example
(request-local-path) @result{} "bar"
@end example
@end deffn

@deffn Procedure request-query-string
Returns the query string from an HTTP request.  The query string is
the part of the request URL after a question mark.
Returns false if there was no query string.
Corresponds to the CGI variable @code{QUERY_STRING}.
@example
(request-query-string) @result{} "val1=xyz&val2=abc"
@end example
@end deffn

@subsection Request parameters

Request parameters are used for data returned from forms,
and for other uses.
They may be encoded in the query string or in the request body.

@deffn Procedure request-parameter name [default]
If there is a parameter with the given name (a string),
return the (first) corresponding value, as a string.
Otherwise, return the @var{default} value,
or @code{#!null} if there is no @var{default}.
@example
(request-parameter "val1") @result{} "xyz"
(request-parameter "val9" "(missing)") @result{} "(missing)"
@end example
@end deffn

@deffn Procedure request-parameters name
If there is are one or more parameter with the given name (a string),
return them all (as multiple values).
Otherwise, return no values (i.e. @code{(values)}).
@example
(request-parameters "val1") @result{} "xyz"
(request-parameters "val9") @result{} #!void
@end example
@end deffn

@deffn Procedure request-parameter-map
Request a map of all the parameters.
This is a map from strings to a sequence of strings.
(Specifically, a @code{java.util.Map<String,java.util.List<String>>}.)
@end deffn

@subsection Request headers

The request headers are a set of (keyword, string)-pairs
transmitted as part of the HTTP request, before the request body.

@deffn Procedure request-header name
If there is a header with the given @var{name} (a string),
return the corresponding value string.
Otherwise, return @code{#!null}.
@example
(request-header "accept-language") @result{} "en-us,en;q=0.5"
@end example
@end deffn

@deffn Procedure request-header-map
Request a map of all the headers.
This is a map from strings to a sequence of strings.
(Specifically, a @code{java.util.Map<String,java.util.List<String>>}.)
@end deffn

@subsection Request body

@deffn Procedure request-input-port
Return a textual input port for reading the request body,
as a sequence of characters.
@end deffn

@deffn Procedure request-input-stream
Return a binary input stream for reading the request body,
as a sequence of bytes.
@end deffn

@deffn Procedure request-body-string
Return the entire request body as a string
@end deffn

@subsection Request IP addresses and ports

Information about the interface and port on which the request was received.

@deffn Procedure request-local-socket-address
The local address on which the request was received.
This is the combination of @code{(request-local-host)}
and @code{(request-local-port)}, as an instance of
@code{java.net.InetSocketAddress}.
@end deffn
@deffn Procedure request-local-host
Get the IP address of the interface on which request was received,
as an @code{java.net.InetAddress}.
@end deffn
@deffn Procedure request-local-IP-address
Get the IP address of the interface on which request was received,
a string in numeric form:
@example
(request-local-host) @result{} "127.0.0.1"
@end example
@end deffn
@deffn Procedure request-local-port
Get the port this request was received on.
@example
(request-local-port) @result{} 8080
@end example
@end deffn

Information about the interface and port of the remote client that invoked the request.

@deffn Procedure request-remote-socket-address
The address of the remote client (usually a web browser)
which invoked the request.
This is the combination of @code{(request-remove-host)}
and @code{(request-remote-port)}, as an instance of
@code{java.net.InetSocketAddress}.
@end deffn
@deffn Procedure request-remote-host
Get the IP address of the remote client which invoked the request,
as an @code{java.net.InetAddress}.
@end deffn
@deffn Procedure request-remote-IP-address
Get the IP address of the remote client which invoked the request,
as a string in numeric form.
@example
(request-remote-host) @result{} "123.45.6.7"
@end example
@end deffn
@deffn Procedure request-remote-port
The port used by the remote client.
@end deffn

@subsection Miscellaneous request properties

@deffn Procedure request-path-translated
Map the request-path to a file name (a string)
in the server application directory.
Corresponds to the CGI variable @code{PATH_TRANSLATED}.
@end deffn

@deffn Procedure request-method
Returns the method of the HTTP request, usually @code{"GET"}
or @code{"POST"}.  Corresponds to the CGI variable @code{REQUEST_METHOD}.
@end deffn

@deffn Procedure request-scheme
Returns the scheme (protocol) of the request.
Usually @code{"http"}, or @code{"https"}.
@end deffn

@node HTTP response, XML beyond Scheme, HTTP requests, XML tools
@section Generating HTTP responses

The result of evaluating the top-level expressions of a web page script
becomes the HTTP response that the servlet sends back to the browser.
The result is typically an HTML/XML element code object
Kawa will automatically format the result as appropriate for the type.
Before the main part of the response there may be
special "response header values",
as created by the @code{response-header} function.
Kawa will use the response header values to set various
required and optional fields of the HTTP response.
Note that @code{response-header} does not actually do anything
until it is "printed" to the standard output.
Note also that a @code{"Content-Type"} response value is
special since it controls the formatting of the following
non-response-header values.

@deffn Procedure response-header key value
Create the response header @samp{@var{key}: @var{value}} in the HTTP
response.  The result is a "response header value" (of some unspecified
type).  It does not directly set or print a response header, but only
does so when you actually "print" its value to the response output stream.
@end deffn

@deffn Procedure response-content-type type
Species the content-type of the result - for example @code{"text/plain"}.
Convenience function for @code{(response-header "Content-Type" @var{type})}.
@end deffn

@deffn Procedure error-response code [message]
Creates a response-header with an error code of @var{code} and a
response message of @var{message}.
(For now this is the same as @code{response-status}.)

Note this also returns a response-header value, which does not actually
do anything unless it is returned as the result of executing a servlet body.
@end deffn

@deffn Procedure response-status code [message]
Creates a response-header with an status code of @var{code} and a
response message of @var{message}.
(For now this is the same as @code{error-response}.)
@end deffn

@node XML beyond Scheme, , HTTP response, XML tools
@section Using non-Scheme languages for XML/HTML 

@subsection XQuery language

Bundled with Kawa is a fairly complete implementation of W3C's
new @uref{http://www.w3c.org/XML/Query,XML Query language}.
If you start Kawa with the @code{--xquery} it selects the "XQuery"
source language; this also prints output using XML syntax.
See the @uref{http://www.gnu.org/software/qexo/,Qexo (Kawa-XQuery) home page}
for examples and more information.

@subsection XSL transformations

There is an experimental implementation of the XSLT (XML Stylesheet
Language Transformations) language.  Selecting @code{--xslt} at the
Kawa command line will parse a source file according to the syntax
on an XSLT stylesheet.
See the @uref{http://www.gnu.org/software/qexo/xslt.html,Kawa-XSLT page}
for more information.

@menu
* KRL::              KRL - The Kawa Report Language for generating XML/HTML
@end menu

@node KRL, , ,  XML beyond Scheme
@subsection KRL - The Kawa Report Language for generating XML/HTML

KRL (the "Kawa Report Language") is powerful Kawa dialect for embedding
Scheme code in text files such as HTML or XML templates.  You select
the KRL language by specifying @code{--krl} on the Kawa command line.

KRL is based on on @uref{http://brl.sourceforge.net/,BRL},
Bruce Lewis's "Beautiful Report Language", and
uses some of BRL's code, but there are some experimental differences,
and the implementation core is different.  You can run KRL in
BRL-compatility-mode by specifying @code{--brl} instead of @code{--krl}.

@subsection Differences between KRL and BRL

This section summarizes the known differences between KRL and BRL.
Unless otherwise specified, KRL in BRL-compatibility mode will
act as BRL.

@itemize
@item
In BRL a normal Scheme string @code{"mystring"} is the same
as the inverted quote string @code{]mystring[}, and both are instances
of the type @code{<string>}.
In KRL @code{"mystring"} is a normal Scheme string of type @code{<string>},
but @code{]mystring[} is special type that suppresses output escaping.
(It is equivalent to @code{(unescaped-data "mystring")}.)
@item
When BRL writes out a string, it does not do any processing
to escape special characters like @code{<}.  However, KRL in its default
mode does normally escape characters and strings.  Thus @code{"<a>"}
is written as @code{&lt;a&gr;}.
You can stop it from doing this by overriding the output format, for example
by specifying @code{--output-format scheme} on the Kawa command line,
or by using the @code{unescaped-data} function.
@item
Various Scheme syntax forms, including @code{lambda},
take a @stxref{body}, which is a list of one or more declarations and
expressions.  In normal Scheme and in BRL the value of a @var{body}
is the value of the last expression.  In KRL the value of a @var{body}
is the concatenation of all the values of the expressions,
as if using @code{values-append}.
@item
In BRL a word starting with a colon is a keyword.
In KRL a word starting with a colon is an identifier, which by
default is bound to the @code{make-element} function specialized
to take the rest of the word as the tag name (first argument).
@item
BRL has an extensive utility library.  Most of this has not yet been ported
to KRL, even in BRL-compatibility mode.
@end itemize

@node Low-level functions, FAQs, XML tools, Top
@chapter Deprecated low-level functions

These sections document older and less convenient ways
to call Java methods, access Java fields, and use Java arrays.

@menu
* Low-level Method invocation::
* Low-level Field operations::
* Low-level array macros::
@end menu

@node Low-level Method invocation, Low-level Field operations, , Low-level functions
@section Low-level Method invocation

The following lower-level primitives require you to specify
the parameter and return types explicitly.
You should probably use the functions @code{invoke} and @code{invoke-static}
(@pxref{Method operations}) instead.

@deffn Syntax primitive-constructor class (argtype ...)
Returns a new anonymous procedure, which when called will create
a new object of the specified class, and will then call the
constructor matching the specified argument types.
@end deffn

@deffn Syntax primitive-virtual-method class method rtype (argtype ...)
Returns a new anonymous procedure, which when called will
invoke the instance method whose name is the string @var{method}
in the class whose name is @var{class}.
@end deffn

@deffn Syntax primitive-static-method class method rtype (argtype ...)
Returns a new anonymous procedure, which when called will
invoke the static method whose name is the string @var{method}
in the class whose name is @var{class}.
@end deffn

@deffn Syntax primitive-interface-method interface method rtype (argtype ...)
Returns a new anonymous procedure, which when called will
invoke the matching method from the interface whose name is @var{interface}.
@end deffn

The macros return procedure values, just like @code{lambda}.
If the macros are used directly as the procedure of a procedure call,
then kawa can inline the correct bytecodes to call the specified methods.
(Note also that neither macro
checks that there really is a method that matches the specification.)
Otherwise, the Java reflection facility is used.

@node Low-level Field operations, Low-level array macros, Low-level Method invocation, Low-level functions
@section Low-level field operations

The following macros evaluate to procedures that can be used to
access or change the fields of objects or static fields.
The compiler can inline each to a single bytecode instruction
(not counting type conversion).

These macros are deprecated.
The @code{fields} and @code{static-field} functions
(@pxref{Field operations}) are easier to use, more powerful, and
just as efficient.  However, the high-level functions currently do
not provide access to non-public fields.

@deffn Syntax primitive-get-field class fname ftype
Use this to access a field named @var{fname} having type @var{type} in
class @var{class}.  Evaluates to a new one-argument procedure,
whose argument is a reference to an object of the specified @var{class}.
Calling that procedure returns the value of the specified field.
@end deffn

@deffn Syntax primitive-set-field class fname ftype
Use this to change a field named @var{fname} having type @var{type} in
class @var{class}.  Evaluates to a new two-argument procedure,
whose first argument is a reference to an object of the
specified @var{class}, and the second argument is the new value.
Calling that procedure sets the field to the specified value.
(This macro's name does not end in a @samp{!}, because it does not actually
set the field.  Rather, it returns a function for setting the field.)
@end deffn

@deffn Syntax primitive-get-static class fname ftype
Like @code{primitive-get-field}, but used to access static fields.
Returns a zero-argument function, which when called returns
the value of the static field.
@end deffn

@deffn Syntax primitive-set-static class fname ftype
Like @code{primitive-set-field}, but used to modify static fields.
Returns a one-argument function, which when called sets the
value of the static field to the argument.
@end deffn

@node Low-level array macros, , Low-level Field operations, Low-level functions
@section Old low-level array macros

The following macros evaluate to procedures that can be used to
manipulate primitive Java array objects.
The compiler can inline each to a single bytecode instruction
(not counting type conversion).

@deffn Syntax primitive-array-new element-type
Evaluates to a one-argument procedure.  Applying the resulting procedure to
an integer count allocates a new Java array of the specified length,
and whose elements have type @var{element-type}.
@end deffn

@deffn Syntax primitive-array-set element-type
Evaluates to a three-argument procedure.  The first argument of
the resulting procedure must be an array whose elements have type
@var{element-type};  the second argument is an index;  and the third
argument is a value (coercible to @var{element-type}) which replaces
the value specified by the index in the given array.
@end deffn

@deffn Syntax primitive-array-get element-type
Evaluates to a two-argument procedure.  The first argument of
the resulting procedure must be an array whose elements have type
@var{element-type};  the second argument is an index.
Applying the procedure returns the element at the specified index.
@end deffn

@deffn Syntax primitive-array-length element-type
Evaluates to a one-argument procedure.  The argument of
the resulting procedure must be an array whose elements have type
@var{element-type}.
Applying the procedure returns the length of the array.
(Alternatively, you can use @code{(field @var{array} 'length)}.)
@end deffn

@node FAQs, Community, Low-level functions, Top
@chapter Frequently Asked Questions

@subsubsection What is the equivalent of Java import?

Kawa's @code{import} follows R6RS, so it is bit like
Java's @code{import static TypeName.*} (static-import-on-demand) declaration.

Kawa doesn't have a direct equivalent of
Java's @code{import TypeName} (single-type-import) declaration,
but @code{define-alias} provides similar functionality:
@example
(define-alias StrBuf java.lang.StringBuffer)
@end example
This has the advantage that you can pick an arbitrary name as an alias.

There is no direct equivalent to Java's @code{import PackageOrTypeName.*}
(type-import-on-demand) declaration, but you can alias a package:
@example
(define-alias jutil java.util)
(define mylist :: jutil:List (jutil:ArrayList))
@end example

You can also use @code{define-namespace} to introduce an abbreviation or
renaming of a class name, but as a matter of style @code{define-alias}
is preferred.

@subsubsection How do I refer to a Java member (nested) class?

Consider the Java SE member class @code{javax.swing.text.AbstractDocument.Content}.
Using the Java syntax doesn't work in Kawa.
Inside you should use Kawa's colon operator:
@example
javax.swing.text.AbstractDocument:Content
@end example
Alternatively, you can use the internal JVM class name:
@example
javax.swing.text.AbstractDocument$Content
@end example

@node Community, License, FAQs, Top
@chapter The Kawa Community

@menu
* Reporting bugs::       Where to report bugs
* Mailing lists::        Where to discuss changes, etc
* Support::              Technical support for Kawa
* Projects::             Projects using Kawa
* Ideas and tasks::      Ideas and tasks for contributing to Kawa
@end menu

@node Reporting bugs, Mailing lists, , Community
@section Reporting bugs

To report a bug or feature request for Kawa (including Qexo or JEmacs), it is
best to use the
@uref{http://savannah.gnu.org/bugs/?func=additem&group=kawa,bug-submission page}.
You can browse and comment on existing bug reports
using the @uref{http://savannah.gnu.org/bugs/?group=kawa, Kawa Bugzilla page}.

When a bug report is created or modified, mail is automatically sent to the
@email{bug-kawa@@gnu.org} list.  You can subscribe, unsubscribe, or browse
the archives through the
@uref{http://mail.gnu.org/mailman/listinfo/bug-kawa,
@code{bug-kawa} web interface}.

@node Mailing lists, Support, Reporting bugs, Community
@section General Kawa email and discussion

The general Kawa email list is @email{kawa@@sourceware.org}.
This mailing list is used for announcements, questions, patches,
and general discussion relating to Kawa.  If you wish to subscribe,
send a blank message request to @email{kawa-subscribe@@sourceware.org}.
To unsubscribe, send a blank message to
@email{kawa-unsubscribe@@sourceware.org}.
(If your mail is forwarded and you're not sure which email address you're
subscribed as send mail to the address following @code{mailto:} in the
@code{List-Unsubscribe} line in the headers of the messages you get from
the list.)

You can browse the @uref{http://sourceware.org/ml/kawa/,
archive of past messages}.

There are separate mailing lists for
@uref{http://mail.gnu.org/mailman/listinfo/qexo-general, Qexo}
and @uref{http://lists.sourceforge.net/mailman/listinfo/jemacs-info,JEmacs}.


@node Support, Projects, Mailing lists, Community
@section Technical Support for Kawa

If you have a project that depends on Kawa or one of its component
packages, you might do well get get paid priority support from
Kawa's author.

The base price is $2400 for one year.  This entitles you to basic
support by email or phone.  Per @email{per@@bothner.com} will answer techical
questions about Kawa or its implementation, investigate bug reports, and
suggest work-arounds.  I may (at my discretion) provide fixes and
enhancements (patches) for simple problems.  Reponse for support
requests received using the day (California time) will normally be
within a few hours.

All support requests must come through a single designated contact
person.  If Kawa is important to your business, you probably
want at least two contact people, doubling the price.

If the support contract is cancelled (by either party), remaining
time will be prorated and refunded.

Per is also available for development projects.

@node Projects
@section Projects using Kawa

Google's @uref{http://appinventor.googlelabs.com/,App Inventor for Android}
uses Kawa to translate its visual blocks language.

@uref{http://www.mercedsystems.com/, Merced Systems@comma{} Inc.} uses Kawa
extensively in their contact center performance management product
Merced Peformance Suite.  Kawa Scheme is used for all development
and has allowed Merced to realize the large productivity gains
that come with using Scheme while still maintaining tight
integration with a large number of Java libraries.

JEmacs is included in the Kawa distribution.  It is a project to
re-implement Emacs, allowing a mix of Java. Scheme, and Emacs Lisp.
It has its own @uref{http://jemacs.sourceforge.net/,home-page}.

BRL ("the Beautiful Report Language") is a database-oriented language
to embed in HTML and other markup.
@uref{http://brl.sourceforge.net/, BRL} allows you to embed Scheme in
a an HTML file on a web server.

The @uref{http://schemeway.sourceforge.net,SchemeWay Project} is a set of
@uref{http://www.eclipse.org,Eclipse} plug-ins for professional Scheme
programming. The first plugin released, SchemeScript, is a fully-featured
Scheme
editor customizable in Scheme. It embeds the Kawa Scheme system and has
many features that ease Kawa Scheme programming (like code completion on
variable names, 
class and method names, namespaces, etc).

@uref{http://www.nuecho.com,Nü Echo} develops high-performance speech
enabled applications. Nü Echo uses Kawa for the development of innovative
speech application development tools, like a complete 
@uref{http://www.nuecho.com/en/services/grammar.shtml,grammar IDE} and a 
S-expression based language and development environment for the
specification of 
highly reusable @uref{http://www.nuecho.com/en/services/dcl.shtml,dialog
components}. 

The Health Media Research Laboratory, part of the Comprehensive Cancer
Center at the University of Michigan, is using Kawa as an integral part of
its core tailoring technologies. Java programs using Kawa libraries are used
to administer customized web-based surveys, generate tailored feedback,
validate data, and "characterize," or transform, data. Kawa code is embedded
directly in XML-formatted surveys and data dictionaries. Performance and
ease of implementation has far exceeded expectations. For more information
contact Paul R. Potts, Technical Director, Health Media Research Lab,
@code{<potts@@umich.edu>}.

Mike Dillon (@code{mdillon@@gjt.org})
did the preliminary work of creating a
Kawa plugin for jEdit. It is called SchemeShell and provides a REPL inside
of the jEdit console for executing expressions in Kawa (much as the BeanShell
plugin does with the BeanShell scripting language).
It is currently available only via CVS from:
@example
CVSROOT=:pserver:anonymous@@cvs.jedit.sourceforge.net:/cvsroot/jedit
MODULE=plugins/SchemeShell
@end example

STMicroelectronics (@code{marco.vezzoli@@st.com})
uses Kawa in a prototypal
intranet 3tier information retrival system as a communication protocol
between server and clients and to do server agents programming.

The Nice Programming Language is a new open source language with a
Java-like syntax. It features multiple dispatch, parametric types,
higher-order functions, tuples, optional parameters, safe static typing
of @code{null}, ..., and the new concept of "abstract interfaces".
The Nice compiler (@code{nicec}) uses Kawa's @code{gnu.expr}
and @code{gnu.bytecode}
packages to generate Java bytecode.
You can find more about Nice at @uref{http://nice.sourceforge.net}.
For more information feel free to contact
Daniel Bonniot @email{bonniot@@users.sf.net}).

@node Ideas and tasks
@section Ideas and tasks for contributing to Kawa

Kawa (like other Free Software projects) has no lack of tasks and projects
to work on.  Here are some ideas.

@subsection Compiler should use class-file reading instead of reflection
The Kawa compiler currently uses reflection to determine properties
(such as exported function definitions) from referenced classes.
It would be better to read class files.
This should not be too difficult, since the gnu.bytecode library
abstracts over class information read by reflection or class reading.

@subsection Make use of Java-7 MethodHandles
Java 7 will support MethodHandles which are meant to provide better
performance (ultimately) for dynamic languages.
See @uref{http://jcp.org/en/jsr/detail?id=292,JSR 292}
amd the @uref{http://openjdk.java.net/projects/mlvm/,Da Vinci Machine Project}. 
MethodHandles will be used to compile lambdas in Java 8.
Kawa can already be compiled to use Methodhandles, but only in
one unimportant way.  There much more to be done.  For example we
can start by optimizing arithmetic when the types are unknown
at compile-time.  They could make implementing
generic functions (multimethods) more efficient.
At some point we want to compile lambdas in the same way
as the experimental Java 8 branch does. This can potenitally
be more efficient than Kawa's current mechanism.

@subsection R6RS libraries and syntax
Kawa supports most of the functionality of R6RS libraries,
as well as the R6RS library @code{import} form.  However,
it does not support actual R6RS library definition syntax.
This needs to be added.
In a related matter, Kawa supports most of the functionality of
@code{syntax-case}, but some pieces are missing, and no
doubt some of it is incorrect.  Adding the missing pieces
and testing for correctness of corner cases is needed.
@uref{http://lists.r6rs.org/pipermail/r6rs-discuss/2007-October/003387.html,Andre van Tonder's R6RS expander} may be helpful.

@subsection Optimize switches (case)

Implement @code{SwitchExp} as a new class extending @code{Expression},
and compile it using the existing @code{gnu.bytecode.SwitchState}.
Use it to optimize Scheme's @code{case} form.

(This is a fairly small starter project.)

@subsection Parameterized types
Add support for parameterized types to Kawa.  Currently, you can
declare a variable as having type @samp{list}.  It would be useful
to declare it to have type @samp{list[string]} (or whatever syntax
makes most sense).  This should build on and be compatible with Java generics.
(However, it might be better to have wild-carding be associated with
declarations, as in Scala, rather than uses.)  This involves adding
syntax, an appropriate internal repesentation, changing core sequence-based
types to use generics, type checking/inference, reading and writing
the appropriate information from/to class files.

@subsection Full continuations
Add support for full continuations, which is the major
feature missing for Kawa to qualify as a ``true Scheme''.
One way to implement continuations is to add a add that converts
the abstract syntax tree to continuation-pass-style, and then
exhand the existing full-tail-call support to manage a stack.
There are other ways to solve the problem.
This may benefit from @ref{task-faster-tailcalls,Faster tailcalls}.

@anchor{task-faster-tailcalls}
@subsection Faster tailcalls
Make @code{--full-tailcalls} run faster.
This may depend on (or incorporate)
@ref{task-TreeList-optimization,TreeList-optimization}. 

@anchor{task-TreeList-optimization}
@subsection TreeList-optimization
The @uref{http://www.gnu.org/software/kawa/api/gnu/lists/TreeList.html,TreeList} class is a data structure for ``flattened'' trees.  It is used for
XML-style nodes, for multiple values, and for the full-tail-call API.
The basic concept is fine, but it could do with some re-thinking
to make make random-access indexing fast.  Also, support for updating
is insufficient.  (This needs someone into designing and hacking on
low-level data-structures, along with lots of profiling and testing.)

@subsection Lazy evaluation
Add support for lazy evaluation and implicit futures.
Kawa alread has @code{delay} (which creates a lazily-calculated value)
and @code{future} (which creates a child thread to calculate a value).
The function @code{force} takes either of these and waits until the
result is calculated.  Using these would be much more pleasant if
the cmpiler could as @code{force} as needed automatically.
This involves run-time changes, compiler changes, as well as
optimizations (and type specifiers) to minimize unneeded @code{force} calls.

@anchor{task-REPL-improvements}
@subsection REPL console and other REPL improvement
Improvements to the read-eval-print console.
In addition to a traditional Swing console,
it would be useful to support using a web browser as a a remote terminal,
possibly using web-sockets.
(This allows ``printing'' HTML-expressions, which can be a useful way
to learn and experiment with web technologies.)
See @uref{http://per.bothner.com/blog/2007/ReplPane/, here} for an article
on the existing Swing REPL, along with some to-do items.
Being able to hide and show different parts of the output might be nice.
Being able to link from error messages to source might be nice.
Better handling of redefinitions is discussed 
@uref{http://per.bothner.com/blog/2009/REPL-for-JavaFX/, here in the context of JavaXF Script}; this is a general REPL issue, mostly independent of the GUI for it.

@subsection XQuery-1.1-functionality
It would be nice to update the XQuery (Qexo) support
to @uref{http://www.w3.org/TR/xquery-30/,XQuery 1.1}.

@subsection XQuery-updates
It would be nice to support @uref{http://www.w3.org/TR/xquery-update-10/, XQuery updates}.  This depends on @ref{task-TreeList-optimization,TreeList-optimization}. 

@anchor{task-common-lisp}
@subsection Common Lisp support
Kawa supports a small subset of the Common Lisp language, but it supports
a much larger subset of core Common Lisp concepts and data structure, some
designed with Common Lisp functionality in mind.  Examples include
packages, arrays, expanded function declarations, type specifications,
and format.  A lot could be done to improve the Common Lisp support
with modest effort.  Some Common Lisp features could also be useful
for Scheme: Documentation strings (or markup) as Java annotations,
better MOP-like introspection, and generic methods a la defmethod
(i.e. with multiple definition statements, possibly in separate files,
as opposed to the current make-procedure) all come to mind.
Being able to run some existing Common Lisp code bases with
at most modest changes should be the goal.
One such package to start with might be a
@uref{http://aperiodic.net/phil/archives/Geekery/notes-on-lisp-testing-frameworks.html,existing test framework}, perhaps
@uref{http://common-lisp.net/project/bese/FiveAM.html, FivaAM}.
Full Common Lisp compatibility is nice, but let's walk before we can run.

@subsection JEmacs improvements
A lot of work is needed to make
@uref{http://jemacs.sourceforge.net/,JEmacs} useful.
One could try to import a useful package and see what works and what fails.
Or one may look at basic editing primitives.
Enhancements may be needed to core Emacs Lisp language primitives
(enhancing @ref{task-common-lisp, Common Lisp support} may help),
or to the display engine.

@subsection Improved IDE integration
There is some Kawa support for Eclipse (Schemeway), and possibly
other IDEs (NetBeans, IntelliJ).  But many improvements are
desirable.
@ref{task-REPL-improvements, REPL improvements} may be a component of this.

@subsection Output formatting and pretty printing
Kawa's @code{write} should support back-references, as in
@uref{http://srfi.schemers.org/srfi-38/srfi-38.html,SRFI-38}.
This isn't difficult, but requires understanding and modifying the
existing pretty-printer data structures.  One you figured that out,
it would be nice to integrate the pretty-printer with the REPL,
so that window re-sizing re-breaks the output lines.
It would be nice to enhance the pretty-printer to handle
variable-width fonts and other ``rich'' text.
Figuring out how to make the output formatter more flexible,
more efficient, and more customizable are also desirable.

@node License, Overall Index, Community, Top
@chapter License

@menu
* Software-License::      License for the Kawa software
* Manual-License::        License for the Kawa manual
@end menu

@node Software-License, Manual-License, , License
@section License for the Kawa software

The license for the Kawa software
(except the optional JEmacs and BRL features - see below) is the
@uref{http://opensource.org/licenses/mit-license.php, X11/MIT license}
which is quoted below.

@example
The software (with related files and documentation) in these packages
are copyright (C) 1996-2009  Per Bothner.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
@end example

In the past the Kawa license was a "modified GNU GPL (General
Public License)".
If you find any files that contain the old license or otherwise seem
to contradict the new license, please report that as a bug.

Some of the JEmacs files are based on Emacs and have a GPL license,
which is incompatible with non-Free (proprietary) products.  For that
reason, the @code{gnu.jemacs.*} packages are not included any more in
the standard @code{.jar} or by default when building from source, to
avoid surprises.
To build JEmacs you have to specify the @code{configure}
flag @code{--enable-jemacs} or the @code{ant} flag
@code{-Denable-jemacs=true}.

Some code in @code{gnu/brl} and @code{gnu/kawa/brl} is copyright
Bruce R. Lewis and Eaton Vance Management,
with a modified-GPL license: no restrictions if used
unmodified, but otherwise the GPL applies.
These packages are no longer included by default in Kawa builds,
but have to be selected with the @code{configure}
flag @code{--enable-brl} or the @code{ant} flag @code{-Denable-brl=true}.

Kawa uses some math routines from fdlib's libf77,
which have a AT&T Bell Laboratories and Bellcore copyright.
See the source file @code{gnu/math/DComplex.java}.

The sorting routine in @code{gnu.xquery.util.OrderedTuples}
is a re-implementatiomn in Java of code copyrighted by
Simon Tatham.

Some of the Scheme code in @code{kawa/lib} and @code{gnu/kawa/slib}
are copyright other parties, and may have slightly different
license wording, but I believe none of then contradicts the
main Kawa license or impose extra restrictions.
Search for the word @code{copyright} in these directories.

Some code has been converted from other languages, with permission.
This includes the @code{rationalize} method
in @code{gnu/math/RatNum.java}, based on an algorithm of Alan Bawden,
as expressed by Marc Feeley in C-Gambit.
The concepts and algorithm of @code{gnu/text/PrettyWriter.java}
are converted from SBCL, which is in the public domain.

@node Manual-License, , Software-License, License
@section License for the Kawa manual

Here is the copyright license for this manual:

Copyright @copyright{} 1996, 1997, 1998, 1999, 2005 Per Bothner

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation approved
by the author.

Parts of this manual is copied from the @uref{http://www.r6rs.org/,R6RS}
specifications, which states:
@quotation
We intend this report to belong to the entire Scheme community, and so
we grant permission to copy it in whole or in part without fee. In
particular, we encourage implementors of Scheme to use this report as
a starting point for manuals and other documentation, modifying it as
necessary.
@end quotation

Parts of this manual were derived from the SLIB manual,
copyright @copyright{} 1993-1998 Todd R. Eigenschink and Aubrey Jaffer.

Parts of this manual were derived from ISO/EIC 10179:1996(E)
(Document Style and Specifical Language) - unknown copyright.

This manual has quoted from SRFI-6 (Basic String Ports),
which is Copyright (C) William D Clinger (1999). All Rights Reserved.

This manual has quoted from SRFI-8 (receive: Binding to multiple values),
which is Copyright (C) John David Stone (1999). All Rights Reserved.

This manual has quoted from SRFI-9 (Defining Record Types)
which is Copyright (C) Richard Kelsey (1999).  All Rights Reserved.

This manual has quoted from SRFI-11 (Syntax for receiving multiple values),
which is Copyright (C) Lars T. Hansen (1999). All Rights Reserved.

This manual has quoted from SRFI-25 (Multi-dimensional Array Primitives),
which is Copyright (C) Jussi Piitulainen (2001). All Rights Reserved.

This manual has quoted from SRFI-26 (Notation for Specializing
Parameters without Currying),
which is Copyright (C) Sebastian Egner (2002). All Rights Reserved.

This manual has quoted from SRFI-39 (Parameter objects),
which is Copyright (C) Marc Feeley (2002). All Rights Reserved.

The following notice applies to SRFI-6, SRFI-8, SRFI-9, SRFI-11, SRFI-25,
SRFI-26, and SRFI-39,
which are quoted in this manual, but it does not apply to the manual as a whole:

@quotation
This document and translations of it may be copied and furnished to
others, and derivative works that comment on or otherwise explain it or
assist in its implementation may be prepared, copied, published and
distributed, in whole or in part, without restriction of any kind,
provided that the above copyright notice and this paragraph are included
on all such copies and derivative works. However, this document itself
may not be modified in any way, such as by removing the copyright notice
or references to the Scheme Request For Implementation process or
editors, except as needed for the purpose of developing SRFIs in which
case the procedures for copyrights defined in the SRFI process must be
followed, or as required to translate it into languages other than
English.

The limited permissions granted above are perpetual and will not be
revoked by the authors or their successors or assigns.

This document and the information contained herein is provided on an
"AS IS" basis and THE AUTHOR AND THE SRFI EDITORS DISCLAIM ALL
WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY
WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY
RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A
PARTICULAR PURPOSE.
@end quotation

This manual has quoted from SRFI-69 (Basic hash tables),
which is Copyright (C) Panu Kalliokoski (2005). All Rights Reserved.

The following notice applies to SRFI-69,
which are quoted in this manual, but it does not apply to the manual as a whole:

@quotation
Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
Software), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
@end quotation

This manual has made use text and examples from Dorai Sitaram's
@code{pregexp} implementation.  But not where the latter talks about
@code{pregexp-xxx} functions the manual also also talks about
the @code{regex-xxx} functions (which are are similar but use a
slight different regular expression syntax).
The @code{pregexp} distribution has the following @code{COPYING} file:
@quotation
Copyright (c) 1999-2005, Dorai Sitaram.
All rights reserved.

Permission to copy, modify, distribute, and use this work or
a modified copy of this work, for any purpose, is hereby
granted, provided that the copy includes this copyright
notice, and in the case of a modified copy, also includes a
notice of modification.  This work is provided as is, with
no warranty of any kind.
@end quotation


@c I'd prefer to call this node plain "Index", but that causes a clash
@c with index.html when generating HTML on case-insenstive file systems.
@node Overall Index,  , License, Top
@unnumbered Index
@printindex cp

@bye
