\input texinfo.tex      @c -*-texinfo-*-
@c %**start of header
@setfilename kawa.info
@settitle Kawa, the Java-based Scheme system
@setchapternewpage off
@syncodeindex fn cp
@syncodeindex vr cp
@c version: %W% %G%
@c %**end of header

@include version.texi

@iftex
@finalout
@end iftex
@titlepage
@title Kawa, the Java-based Scheme system
@subtitle @value{UPDATED}
@sp 1
@author Per Bothner
@page
@end titlepage

@ifinfo
@format
START-INFO-DIR-ENTRY
* kawa: (kawa).         Kawa, the Java-based Scheme system
END-INFO-DIR-ENTRY
@end format
@end ifinfo

@ifnottex
@node Top, Features, (dir), (dir)
@top
@unnumbered The Kawa Scheme system, by Per Bothner
@end ifnottex

Kawa is a Scheme environment, written in Java,
and that compiles Scheme code into Java byte-codes.

This documents version @value{VERSION}, updated @value{UPDATED}.

See the summary
of @uref{http://www.gnu.org/software/kawa/NEWS,recent changes}.

The author of Kawa is
@ifhtml
<a href="http://home.pacbell.net/bothner/">Per Bothner</a>
<tt>&lt;<a href="mailto:per@bothner.com">per@bothner.com</a>&gt;</tt>.
It is a re-write of Kawa 0.2, which was written by R. Alexander Milowski
<tt>&lt;<a href="mailto:alex@copsol.com">alex@copsol.com</a>&gt;</tt>.
@end ifhtml
@ifclear html
Per Bothner @w{<per@@bothner.com>}.
It is a re-write of Kawa 0.2, which was written by
R. Alexander Milowski @w{<alex@@copsol.com>}.
@end ifclear

The Kawa home page (which is currently just an on-line
version of this document) is @uref{http://www.gnu.org/software/kawa/}.
The @uref{http://www.cygnus.com/~bothner/kawa.html, old Kawa home page}
should also work.

The
@uref{http://www.cs.indiana.edu/scheme-repository/home.html,Scheme repository}
has various useful information on Scheme.
but it is not very actively updated.
A new repository has been started at
@uref{http://www.schemers.org/,www.schemers.org}.
It includes pointer to an online copy of
@uref{http://www.schemers.org/Documents/#standards,R5RS}.

A nice quick introduction to Scheme can be found in
@uref{http://www.cs.washington.edu/education/courses/341/CurrentQtr/lectures/scheme/,Greg Badros's lecture notes}.  A more in-depth tutorial which also
discusses Scheme implementation is
@uref{http://www.cs.utexas.edu/users/wilson/schintro/schintro_toc.html, Paul Wilson's "An Introduction to Scheme and its Implementation"}.


Javadoc generated @uref{http://sourceware.cygnus.com/kawa/api/,documentation of the Kawa classes} is also available.

For copyright information on the software and documentation,
see @ref{License}.

This package has nothing to do with the
@uref{http://www.tek-tools.com/kawa/,Kawa commercial Java IDE}.

The packages
@uref{http://sourceware.cygnus.com/kawa/api/gnu/bytecode/package-summary.html,@code{gnu.bytecode}},
@uref{http://sourceware.cygnus.com/kawa/api/gnu/math/package-summary.html,@code{gnu.math}},
@uref{http://sourceware.cygnus.com/kawa/api/gnu/expr/package-summary.html,@code{gnu.expr}},
@uref{http://sourceware.cygnus.com/kawa/api/gnu/mapping/package-summary.html,@code{gnu.mapping}},
and
@uref{http://sourceware.cygnus.com/kawa/api/gnu/text/package-summary.html,@code{gnu.text}},
are used by Kawa, and distributed with it, but may be independently useful.

For a technical overview of Kawa, see these
@uref{http://sourceware.cygnus.com/kawa/papers/,papers}.

@menu
* Features::
* Getting Kawa::
* Installation::         Building and installing Kawa
* Running::              How to start up and run Kawa
* Restrictions::         Features of R5RS not implemented
* Compiling::            Compiling Scheme code to byte-codes
* Extensions::           Kawa features not in standard Scheme
* Types::
* Objects and Classes::  Object-oriented features
* Low-level functions::  The Scheme-Java interface
* Reporting Bugs::       The Kawa Mailing List
* License::
* Index::
@end menu

@node Features, Getting Kawa, Top, Top
@chapter Features

Kawa is a full Scheme implementation.  It implements almost
all of R5RS (for exceptions @pxref{Restrictions}), plus some extensions.
By default, symbols are case sensitive.

It is completely written in Java.  Scheme functions and files
are automatically compiled into Java byte-codes.  Kawa does some
optimizations, and the compiled code runs at reasonable speed.

Kawa provides the usual read-eval-print loop, as well as batch modes.

Kawa is written in an object-oriented style.

Kawa implements most of the features of the expression language of DSSSL,
the Scheme-derived ISO-standard Document Style Semantics and Specification
Language for SGML.  Of the core expression language, the only features
missing are character properties, @code{external-procedure},
the time-relationed procedures, and character name escapes in
string literals.  Also, Kawa is not generally tail-recursive.
From the full expression language, Kawa additionally is missing
@code{format-number}, @code{format-number-list}, and language objects.
Quantities, keyword values, and the expanded @code{lambda} form
(with optional and keyword parameters) are supported.

@node Getting Kawa, Installation, Features, Top
@chapter Getting Kawa

To get the Kawa sources, you have choice between the
@uref{ftp://ftp.gnu.org/pub/gnu/kawa/kawa-stable.tar.gz,
current stable version} (possibly quite old), or the newer
@uref{ftp://ftp.gnu.org/pub/gnu/kawa/kawa-newest.tar.gz,
latest snapshot of the development tree} (builds and passes
the testsuite but less extensively tested).

A ready-to-run @code{.zip} archive of the pre-compiled classes is in
@ifhtml
<a href="ftp://ftp.gnu.org/pub/gnu/kawa/kawa-stable-compiled.zip">here</a>.
@end ifhtml
@ifclear html
@url{ftp://ftp.gnu.org/pub/gnu/kawa/kawa-stable-compiled.zip}.
@end ifclear

These are all in the @uref{ftp://ftp.gnu.org/pub/gnu/kawa/,Kawa ftp site},
which includes other versions and files, including a @code{.deb}
Debian package file of Kawa.

You can also check out the very latest version via anonymous cvs.
@example
cvs -d :pserver:anoncvs@@anoncvs.cygnus.com:/cvs/kawa login
     (password is ``anoncvs'')
cvs -d :pserver:anoncvs@@anoncvs.cygnus.com:/cvs/kawa co kawa
@end example

Once you have it checked out, you can update it with @code{cvs update}.

You can also
@uref{http://anoncvs.cygnus.com/cgi-bin/cvsweb.cgi/kawa/?cvsroot=kawa,view
the cvs archive} via cvsweb.

@node Installation, Running, Getting Kawa, Top
@chapter Building and installing Kawa

Before installing Kawa, you must have Java working on your
system.

You can compile Kawa from the source distribution.
Alternatively, you can install the pre-compiled binary distribution.

@menu
* Running Java::                Getting and running Java
* Binary distribution::         Installing and using the binary distribution
* Source distribution::         Installing and using the source distribution
@end menu

@node Running Java, Binary distribution, , Installation
@section Getting and running Java

You will need a working Java system.
The discussion below assumes you are using the Java Developer's Kit
(JDK) version 1.1.x from JavaSoft (Sun).
(Kawa has also been reported to work with Kaffe, Symantec Cafe, J++,
and JDK 1.2beta.)
You can download free copies of
@ifhtml
<a href="http://java.sun.com/products/jdk/1.1/index.html">
@end ifhtml
JDK 1.1.x
@ifhtml
</a>
for various platforms.
@end ifhtml
@ifclear html
for various platforms
from @url{http://java.sun.com/products/jdk/1.1/index.html/index.html}.
@end ifclear

If you want to run Kawa on a Macintosh, see
@uref{http://home.earthlink.net/~athene/2/scheme/mackawa.html}.

The program @code{java} is the Java interpreter.
The program @code{javac} is the Java compiler,
and is needed if you want to compile the source release yourself.
Both programs must be in your @code{PATH}.

You also need to set @code{CLASSPATH} so it includes both the
current directory, and the standard Java library.
After you have installed Kawa, the @code{CLASSPATH} needs to
include wherever you installed Kawa.

If you have the JDK in directory @code{$JDK},
and you are using a Bourne-shell compatible shell
(/bin/sh, ksh, bash, and some others) you can set both variables thus:
@example
PATH=$JDK/bin:$PATH
CLASSPATH=.:$JDK/lib/classes.zip
export PATH CLASSPATH
@end example

@node Binary distribution, Source distribution, Running Java, Installation
@section Installing and using the binary distribution

The binary release includes only the binary compiled @samp{.class}
versions of the same @samp{.java} source files in the source release.
It does not include any documentation, so you probably want the
source release in addition to the binary release.  The purpose
of the binary release is just to save you time and trouble of
compiling the sources.

The binary release comes as a @code{.zip} archive
@samp{kawa-@value{VERSION}-compiled.zip}.

You can unzip the archive, or you can use it as is.
Assuming the latter, copy the archive to some suitable location,
such as @code{/usr/local/lib/kawa-compiled.zip}.

Then, before you can actually run Kawa, you need to set @code{CLASSPATH}
so it includes the Kawa archive.  On Unix, using a Bourne-style shell:
@example
CLASSPATH=/usr/local/lib/kawa-compiled.zip
export CLASSPATH
@end example

On Windows95/WindowsNT, you need to set @code{classpath} in a DOS console.
For example:
@example
set classpath=\kawa\kawa-@value{VERSION}-compiled.zip
@end example

Then to run Kawa do:
@example
java kawa.repl
@end example

To run Kawa in a fresh window, you can do:
@example
java kawa.repl -w
@end example
On Windows, you probably do want to use the @code{-w} flag,
because if you run Kawa under the MS-DOS prompt, you won't see
commands echoed until you hit Enter.  (If anyone knows a way
to fix this problem, please let me know.)

@node Source distribution,  , Binary distribution, Installation
@section Installing and using the source distribution
The Kawa release normally comes as a gzip-compressed tar file named
@samp{kawa-@value{VERSION}.tar.gz} .

In your build directory do:
@example
tar xzf kawa-@value{VERSION}.tar.gz
cd kawa-@value{VERSION}
@end example

Then you must configure the sources.  This you can do
the same way you configure most other GNU software.  Normally
you can just run the configure script with no arguments:

@example
./configure
@end example

This will specify that a later @code{make install} will install the
compiled @samp{.class} files into @code{/usr/local/share/java}.
If you want them
to be installed someplace else, such as @code{$PREFIX/share/java}, then
specify that when you run configure:
@example
./configure --prefix $PREFIX
@end example

If you have the GNU @samp{readline} library installed, you might try
adding the @samp{--enable-kawa-frontend} flag.  This will build the
@samp{kawa} front-end program, which provides input-line editing
and an input history.  You can get @samp{readline} from archives
of GNU programs, including @uref{ftp://www.gnu.org/}.

If you have installed Kawa before, make sure your @code{CLASSPATH}
does not include old versions of Kawa, or other classes that may
conflict with the new ones.

Thus you need to compile all the .java source files.
Just run make:
@example
make
@end example
This assumes that @samp{java} and @samp{javac} are the java interpreter
and compiler, respectively.
For example, if you are using the Kaffe Java interpreter,
you need to instead say:
@example
make JAVA=kaffe
@end example

You can now test the system by running Kawa in place:
@example
java kawa.repl
@end example

or you can run the test suite:
@example
(cd testsuite;  make check)
@end example

or you can install the compiled files:
@example
make install
@end example

This will install your classes into @code{$PREFIX/share/java} (and its
sub-directories).  Here @code{$PREFIX} is the directory you specified
to configure with the @code{--prefix} option, or @code{/usr/local} if you
did not specify a @code{--prefix} option.

To use the installed files, you need to set @code{CLASSPATH} so
that @code{$PREFIX/share/java} is on the path:
@example
CLASSPATH=$PREFIX/share/java
export CLASSPATH
@end example
This is done automatically if you use the @samp{kawa} script.

@subsection Building Kawa under Windows

The Kawa @code{configure} and @code{make} process assumes a Unix-like
environment.  If you want to build Kawa from source under Windows
(95, 98, or NT), you could use a Unix empulation package, such
as the free @uref{http://sourceware.cygnus.com/cygwin/,Cygwin}.
However, there are some problems with filenames that make this
more complicated than it should be.

The Kawa source distribution now includes a simple batch file for building
Kawa under Windows.  You can do the following:

@enumerate
@item
Download the Kawa source distribution @code{kawa-@value{VERSION}.tar.gz}.
@item
Extract the files using an appropriate tool.
(I did @code{tar xzf kawa-@value{VERSION}.tar.gz}, using the @code{tar}
that is part of @uref{http://sourceware.cygnus.com/cygwin/, Cygwin}.
If there are alternative commonly-available tools, please let me
know about them.)
@item
In an MS-DOS window, @code{cd kawa-@value{VERSION}}.
@item
Edit @code{makekawa.bat} if need be to specify the location of your Java tools.
@item
Execute @code{makekawa.bat}.
@item
If this succeeded, you should have a working kawa.
For example you can do @code{java kawa.repl -w}, assuming
@code{java} is in your @code{PATH}.
@end enumerate

If you use an integrated Java development environment, you should be
able to import all the Java source files, and have it compile all of them.
You then need to compile the builtin Scheme procedures:
@example
cd kawa\lib
%KAWA% -d ..\.. -P kawa.lib. -C *.scm
@end example

@node Running, Restrictions, Installation, Top
@chapter How to start up and run Kawa

The easiest way to start up Kawa is to run the @samp{kawa}
program.  This finds your java interpreter, and sets up @samp{CLASSPATH}
correctly.
If you have installed Kawa such @code{$PREFIX/bin} is in your @code{$PATH},
just do:
@example
kawa
@end example
However, @samp{kawa} only works if you have a Unix-like environment.
On some platforms, @samp{kawa} is a program that uses the GNU
@samp{readline} library to provide input line editing.

To run Kawa manually, you must start a Java interpreter.
How you do this depends on the Java interpreter.
For JavaSoft's JDK, you must have the Java interpreter
in your @code{PATH}.
You must also make sure that the @code{kawa/repl.class} file,
the rest of the Kawa packages, and the standard Java
packages can be found by searching CLASSPATH.
@xref{Running Java}.

Then you do:
@example
java kawa.repl
@end example

In either case, you will then get the @samp{#|kawa:1|#} prompt,
which means you are
in the Kawa read-eval-print-loop.  If you type a Scheme
expression, Kawa will evaluate it.  Kawa will then print the
result (if there is a non-"void" result).

@menu
* Options::      Command-line arguments
* New-Window::   Running a Command Interpreter in a new Window
* Exiting::      Exiting Kawa
@end menu

@node Options, New-Window, Running, Running
@section Command-line arguments

@cindex options
You can pass various flags to Kawa, for example:
@example
kawa -e '(display (+ 12 4))(newline)'
@end example
or:
@example
java kawa.repl -e '(display (+ 12 4))(newline)'
@end example
Either causes Kawa to print @samp{16}, and then exit.

At startup, Kawa executes an init file from the user's home
directory.
The init file is named @code{.kawarc.scm} on Unix-like systems
(those for which the file separator is @code{'/'}),
and @code{kawarc.scm} on other systems.
This is done before the read-eval-print loop
or before the first @code{-f} or @code{-c} argument.  (It is not run
for a @code{-e} command, to allow you to set options to override
the defaults.)

@table @samp
@item -e @var{expr}
Kawa evaluates @var{expr}, which contains one or more Scheme expressions.
Does not cause the @code{~/.kawarc.scm} init file to be run.
@item -c @var{expr}
Same as @samp{-e @var{expr}}, except that it
does cause the @code{~/.kawarc.scm} init file to be run.
@item -f @var{filename}
Kawa reads and evaluates expressions from the file named by @var{filename}.
If @var{filename} is @samp{-}, standard input is read (with no prompting).
@item -s
@itemx --
The global variable @samp{command-line-arguments} is set to the remaining
arguments (if any), and an interactive read-eval-print loop is started.
This uses the same "console" as where you started up Kawa;
use @samp{-w} to get a new window.
@item -w
Creates a new top-level window, and runs an interactive read-eval-print
in the new window.  See @ref{New-Window}.
Same as @code{-e (scheme-window #t)}.
You can specify multiple @samp{-w} options, and also use @samp{-s}.
@item --version
Prints out the Kawa version number, and then exits.
@item --server @var{portnum}
Start a server listening from connections on the specified @var{portnum}.
Each connection using the Telnet protocol causes a new read-eval-print-loop
to started.  This option allows you to connect using any
Telnet client program to a remote "Kawa server".
@item --scheme
Set the default language to Scheme.
(This is the default unless you select another language.)
@item --elisp
Set the default language to Emacs Lisp.
(This is not very useful yet - little beyond the parser works.)
@end table

The following options control which calling conventions are used:
@table @samp
@item --full-tailcalls
Use a calling convention that supports proper tail recursion.
@item --no-full-tailcalls
Use a calling convention that does not support proper tail recursion.
Self-tail-recursion (i.e. a recursive call to the current function)
is still implemented correctly, assuming that the called function
is known at compile time.
@end table

The default is currently @code{--no-full-tailcalls} because I believe it is
faster (though I have not done any measurements yet).
It is also closer to the Java call model, so may be better for people
primarily interested in using Kawa for scripting Java systems.

Both calling conventions can co-exist:  Code compiled
with @code{--full-tailcalls} can call code compiled
with @code{--no-full-tailcalls} and vice versa.

The options @samp{-C}, @samp{-d}, @samp{-T}, @samp{-P}, and @samp{--main}
are used to compile a Scheme file; see @ref{Files compilation}.
The option @samp{--connect @var{portnum}} is only used by
the @samp{kawa} front-end program.

If there are further command-line arguments after the options
have been processed, then the first remaining argument names a
file that is read and evaluated.  If there is no such argument,
then Kawa enters an interactive read-eval-print loop,
but only if none of the @samp{-c}, @samp{-e}, @samp{-f}, @samp{-s},
@samp{-C}, or @samp{--} options were specified.

@node New-Window, Exiting, Options, Running
@section Running a Command Interpreter in a new Window

An alternative interface runs the Java read-eval-print-loop
inside a new window. This is in some ways nicer.  One reason
is that it provides better editing.  You can also create
new windows.  They can either have different top-level
environments or they can share environments.  To try it, do:
@example
java kawa.repl -w
@end example

@node Exiting,  , New-Window, Running
@section Exiting Kawa
Kawa normally keeps running as long as there is an active
read-eval-print loop still awaiting input or there is an unfinished
other computation (such as requested by a @samp{-e} of @samp{-f} option).

To close a read-eval-print-loop, you can type the special
literal @code{#!eof} at top level.  This is recognized as end-of-file.
Unfortunately, due to thread-related complications, just typing
an end-of-file character (normally ctrl/D until Unix), will not work.

If the read-eval-print-loop
is in a new window, you can select @samp{Close} from the @samp{File} menu.

To exit the entire Kawa session, call the
@code{exit} procedure (with 0 or 1 integer arguments).

@node Restrictions, Compiling, Running, Top
@chapter Features of R5RS not implemented

Kawa implements all the required and optional features of R5RS,
with the following exceptions.

The entire "numeric tower" is implemented.
However, some transcendental function only work on reals.
Integral function do not necessarily work on
inexact (floating-point) integers.
(The whole idea of "inexact integer" in R5RS seems rather pointless ...)

Also, @code{call-with-current-continuation} is only "upwards" (?).
I.e. once a continuation has been exited, it cannot be invoked.
These restricted continuations can be used to implement catch/throw
(such as the examples in R4RS), but not co-routines or backtracking.

Kawa now does general tail-call elimination, but only if
you use the flag @code{--full-tail-calls}.  (Currently, the
@code{eval} function itself is not fully tail-recursive, in violation
of R5RS.)   The @code{--full-tail-calls} flag is not on by default,
partly because it is noticably slower (though I have not measured how
much), and partly I think it is more useful for Kawa to be compilatible
with standard Java calling conventions and tools.
Code compiled with @code{--full-tail-calls} can call code
 compiled without it and vice versa.

Even without @code{--full-tail-calls}, if the
compiler can prove that the procedure being called is the current
function, then the tail call will be replaced by a jump.
This means the procedure must be defined using a letrec, not a
define (because the compiler does not know if someone might
re-define a global definition), and there must be no assignments
(using @code{set!}) to the procedure binding.

@node Compiling, Extensions, Restrictions, Top
@chapter Compiling Scheme code to byte-codes

All Scheme functions and source files are invisibly compiled
into internal Java byte-codes.
A traditional evaluator is only used for top-level directly entered
expressions @emph{outside} a lambda.  (It would have been simpler
to also byte-compile top-level expressions by surrounding them
by a dummy lambda.  However, this would create a new Class object
in the Java VM for every top-level expression.  This is undesirable
unless you have a VM that can garbage collect Class objects.)

To save speed when loading large Scheme source files, you probably
want to pre-compile them and save them on your local disk.
There are two ways to do this.

You can compile a Scheme source file to a single archive file.
You do this using the @code{compile-file} function.
The result is a single file that you can move around and @code{load}
just like the @code{.scm} source file.  You just specify the name
of the archive file to the @code{load} procedure.
Currently, the archive is a "zip" archive and has extension ".zip";
a future release will probably use "Java Archive" (jar) files.
The advantage of compiling to an archive is that it is simple
and transparent.  A minor disadvantage is that it causes the
Java "verifier" to be run when functions are loaded from it,
which takes a little extra time.

Alternatively, you can compile a Scheme source file to a
collection of @samp{.class} files.
You then use the standard Java class loading mechanism to load the code.
The Java "verifier" does not need to get run, which makes
loading a little faster.
The compiled class files do have to be installed be installed somewhere
in the @code{CLASSPATH}.

@menu
* Archive compilation::         Compiling Scheme to an archive file
* Files compilation::           Compiling Scheme to a set of .class files
* Application compilation::     Compiling Scheme to a standalone application
@end menu

@node Archive compilation, Files compilation, Compiling, Compiling
@section Compiling Scheme to an archive file

To byte-compile a file @samp{foo.scm} do:
@example
(compile-file "foo.scm" "foo")
@end example

This will create @samp{foo.zip}, which contains byte-compiled "j-code"
that implements @samp{foo.scm}.

You can later do:
@example
(load "foo")
@end example

This will load @samp{foo.zip}, which should have the same effect as
loading @samp{foo.scm}, except you will get the byte-compiled versions.

@node Files compilation, Application compilation, Archive compilation, Compiling
@section Compiling Scheme to a set of .class files

Invoking @samp{kawa} (or @samp{java kawa.repl}) with
the @samp{-C} flag will compile
a @samp{.scm} source file into one or more @samp{.class} files.

You run it as follows:
@example
kawa [-d @var{outdirectory}] [-P @var{prefix}] [-T @var{topname}] [--main] -C @var{infile} ...
@end example

Note the @samp{-C} must come last, because @samp{Kawa} processes the
arguments and options in order,

Here:
@table @samp
@item -C @var{infile} ...
The Scheme source files we want to compile.
@item -d @var{outdirectory}
The directory under which the resulting @samp{.class} files will be.
The default is the current directory.
@item -P @var{prefix}
A string to prepend to the generated class names.
The default is the empty string.
@item -T @var{topname}
The name of the "top" class - i.e. the one that contains the code
for the top-level expressions and definitions.
The default is generated from the @var{infile} and @var{prefix}.
@item --main
Generate a @code{main} method so that the resulting "top" class can
be used as a stand-alone application. @xref{Application compilation}.
@end table

When you actually want to load the classes, the @var{outdirectory}
must be in your @samp{CLASSPATH}.
You can use the standard @code{load} function to load the code,
by specifying the top-level class, either as a file name
(relative to @var{outdirectory}) or a class name.
E.g. if you did:
@example
kawa -d /usr/local/share/java -P my.lib. -T foo -C foosrc.scm
@end example
you can use either:
@example
(load "my.lib.foo")
@end example
or:
@example
(load "my/lib/foo.class")
@end example

If you are compiling a Scheme source file (say @samp{foosrc.scm})
that uses macros defined in some other file (say @samp{macs.scm}),
you need to make sure the definitions are visible to the compiler.
One way to do that is with the @samp{-f}:
@example
kawa -f macs.scm -C foosrc.scm
@end example

@node Application compilation,  , Files compilation, Compiling
@section Compiling Scheme to a standalone application

A Java application is a Java class with a special method
(whose name is @code{main}).  The application can be invoked directly
by naming it in the Java command.
If you want to generate an application from a Scheme program,
create a Scheme source file with the definitions you need, plus
the top-level actions that you want the application to execute.
You can compile in the regular way decribed in the previous section, but add
the @code{--main} option.  For example,
assuming your Scheme file is @code{MyProgram.scm}:
@example
kawa --main -C MyProgram.scm
@end example
This will create a @code{MyProgram.class} which you can either @code{load}
(as decribed in the previous section), or invoke as an application:
@example
java MyProgram [@var{args}]
@end example
Your Scheme program can access the command-line arguments @var{args}
by using the global variable @samp{command-line-arguments}.

@node Extensions, Types, Compiling, Top
@chapter Extensions

@menu
* Multiple values::
* Keywords::
* Special named constants::
* Formals:: Extended formal arguments list
* Quantities::
* Logical Number Operations::
* Strings::
* Files:: File System Interface
* Ports::
* Format:: Formatted Output (Common-Lisp-style)
* Exceptions:: Signalling and recovering from exceptions
* Locations::
* Eval and Environments::
* Debugging::
* Threads::
* Processes::
* Miscellaneous::
@end menu

@node Multiple values, Special named constants, Extensions, Extensions
@section Multiple values

The multiple-value feature was added in R5RS.

@defun values object ...
Delivers all of its arguments to its continuation.
@end defun

@defun call-with-values thunk receiver
Call its @var{thunk} argument with a continuation that,
when passed some values, calls the @var{receiver} procedure
with those values as arguments.
@end defun

@node Special named constants, Keywords, Multiple values, Extensions
@section Special named constants

@defvr Constant #!optional
Special self-evaluating literal used in lambda parameter lists
before optional parameters.
@end defvr

@defvr Constant #!rest
Special self-evaluating literal used in lambda parameter lists
before the rest parameter.
@end defvr

@defvr Constant #!key
Special self-evaluating literal used in lambda parameter lists
before keyword parameters.
@end defvr

@defvr Constant #!eof
The end-of-file object.

Note that if the Scheme reader sees this literal at top-level,
it is returned literally.  This is indistinguishable from
coming to the end of the input file.  If you do not want to end reading,
but want the actual value of @code{#!eof}, you should quote it.
@end defvr

@defvr Constant #!void
The void value.  Same as @code{(values)}.
If this is the value of an expression in a read-eval-print loop,
nothing is printed.
@end defvr

@defvr Constant #!null
The Java @code{null} value.  This is not really a Scheme value,
but is useful when interfacing to low-level Java code.
@end defvr

@node Keywords, Formals, Special named constants, Extensions
@section Keywords

Keywords are similar to symbols.  The main difference is that keywords are
self-evaluating and therefore do not need to be quoted in expressions.
They are used mainly for specifying keyword arguments.

@display
@var{keyword} = @var{identifier}:
@end display

An alternative syntax, with the colon first, is supported for
compatibility with Common Lisp and some other Scheme implementations:

@display
@var{keyword} = :@var{identifier}
@end display

Putting the colon first has exactly the same effect as putting it last;
putting is last is recommended, and is how keywords are printed.

A keyword is a single token; therefore no whitespace is allowed between
the @var{identifier} and the colon (which is not considered part
of the name of the keyword).

@defun keyword? obj
Return @code{#t} if @var{obj} is a keyword, and otherwise returns @code{#f}.
@end defun

@defun keyword->string keyword
Returns the name of @var{keyword} as a string.
The name does not include the final @code{#\:}.
@end defun

@defun string->keyword string
Returns the keyword whose name is @var{string}.
(The @var{string} does not include a final @code{#\:}.)
@end defun

@node Formals, Quantities, Keywords, Extensions
@section Extended Formal Arguments List

The formal arguments list of a lambda expression has two
extendsions over standard Scheme:
Kawa borrows the extended formal argument list of DSSSL,
and Kawa allows you to declare the type of the parameter.

@display
@var{lambda-expression} = (lambda @var{formals} [@var{rtype}] @var{body})
@end display
where
@display
@var{formals} = (@var{formal-arguments}) | @var{rest-arg}
@end display
You can of course also use the extended format in a @code{define}:
@display
(define (@var{name} @var{formal-arguments}) [@var{rtype}] @var{body})
@end display

@display
@var{formal-arguments} =
@var{req-opt-args} (@var{rest-key-args} | . @var{rest-arg})
@end display
@display
@var{req-opt-args} = @var{req-arg} ... [#!optional @var{opt-arg} ...]
@var{rest-key-args} = [#!rest @var{rest-arg}] [#key @var{key-arg} ...]
@var{req-arg} = @var{variable} | (@var{variable} @var{type})
@var{opt-arg} = @var{variable} | (@var{variable} @var{initializer} [@var{type}])
@var{key-arg} = @var{variable} | (@var{variable} @var{initializer} [@var{type}])
@var{rest-arg} = @var{variable}
@end display

When the procedure is applied to a list of actual arguments, the formal and
actual arguments are processed from left to right as follows:

@itemize @bullet
@item
The @var{req-arg}s are bound to actual arguments starting with the
first actual argument.  It shall be an error if there are fewer actual
arguments then there are @var{req-arg}s.
@item
Next the @var{opt-arg}s are bound to remaining actual arguemnts.
If there are fewer remaining actual arguments than there are
@var{opt-arg}s, then the remaining @var{variable}s are bound
to the corresponding @var{initializer}, if one was specified, and
otherwise to @code{#f}.  The @var{initializer} is evaluated in an
environment in which all the previous formal parameters have been bound.
@item
If there is a @var{rest-arg}, it is bound to a list of all the
remaining actual arguments.  These remaining actual arguments are also
eligible to be bound to keyword arguments.   If there is no
@var{rest-arg} and there are no @var{key-arg}s, then it shall
be an error if there are any remaining actual arguments.
@item
If @code{#!key} was specified, then there shall be an even number of
remaining actual arguments.  These are interpreted as a series of pairs,
where the first member of each pair is a keyword specifying the argument name,
and the second is the corresponding value.  It shall be an error if the first
member of a pair is not a keyword.  It shall be an error if the argument name
is not the same as a variable in a @var{key-arg}s, unless there
is a @var{rest-arg}.  If the same argument name occurs more than once
in the list of actual arguments, then the first value is used.
If there is no actual argument for a particular @var{key-arg},
then the variable is bound
to the corresponding @var{initializer}, if one was specified, and
otherwise to @code{#f}.  The @var{initializer} is evaluated in an
environment in which all the previous formal parameters have been bound.
@end itemize

If a @var{type} is specified, the corresponding actual argument (or
the @var{initializer} default value) is coerced to the specified @var{type}.
In the function body, the parameter has the specified type.

If @var{rtype} (the first form of the function body) is an unbound
identifier of the form @code{<TYPE>} (that is the first character
is @samp{<} and the last is @samp{>}), then tha specifies the
functions return type.  It is syntactic sugar for
@code{(as <TYPE> (begin BODY))}.

@node Quantities, Logical Number Operations, Formals, Extensions
@section Quantities

As a super-class of numbers, Kawa also provides quantities.
A @dfn{quantity} is a product of a @dfn{unit} and a pure number.
The number part can be an arbitrary complex number.
The unit is a product of integer powers of base units,
such as meter or second.

Kawa quantities are a generalization of the quantities in DSSSL,
which only has length-derived quantities.

The precise syntax of quantity literals may change,
but some examples are @code{10pt} (10 points), @code{5s} (5 seconds),
and @code{4cm2} (4 square centimeters).

@defun quantity? object
True iff @var{object} is a quantity.  Note that all numbers are
quantities, but not the other way round.
Currently, there are no quantities that re not numbers.
To distinguish a plain unit-less number from a quantity,
you can use @code{complex?}.
@end defun

@defun quantity->number q
Returns the pure number part of the quantity @var{q}, relative to
primitive (base) units.
If @var{q} is a number, returns @var{q}.
If @var{q} is a unit, yields the magitude of @var{q} relative to base units.
@end defun

@defun quantity->unit q
Returns the unit of the quantity @var{q}.
If @var{q} is a number, returns the empty unit.
@end defun

@defun make-quantity x unit
Returns the product of @var{x} (a pure number) and @var{unit}.
You can specify a string instead of @var{unit}, such as @code{"cm"}
or @code{"s"} (seconds).
@end defun

@deffn Syntax define-unit unit-name expression
Define @var{unit-name} as a unit (that can be used in literals)
equal to the quantity @var{expression}.
@end deffn

@node Logical Number Operations, Strings, Quantities, Extensions
@section Logical Number Operations

These functions operate on the 2's complement binary representation
of an exact integer.

@defun logand i ...
Returns the bit-wise logical "and" of the arguments.
If no argument is given, the result is -1.
@end defun

@defun logior i ...
Returns the bit-wise logical "(inclusive) or" of the arguments.
If no argument is given, the result is 0.
@end defun

@defun logxor i ...
Returns the bit-wise logical "exclusive or" of the arguments.
If no argument is given, the result is 0.
@end defun

@defun lognot i
Returns the bit-wise logical inverse of the argument.
@end defun

@defun logop op x y
Perform one of the 16 bitwise operations of @var{x} and @var{y},
depending on @var{op}.
@end defun

@defun bittest i j
Returns true if the arguments have any bits in common.
Same as @code{(not (zero? (logand @var{i} @var{j})))},
but is more efficient.
@end defun

@defun logbit? i pos
Returns @code{#t} iff the bit numbered @var{pos} in @var{i} is one.
@end defun

@defun arithmetic-shift i j
Shifts @var{i} by @var{j}.
It is a "left" shift if @code{@var{j}>0}, and
a "right" shift if @code{@var{j}<0}.

The result is equal to @code{(floor (* @var{i} (expt 2 @var{j})))}.
@end defun

@defun ash i j
Alias for @code{arithmetic-shift}.
@end defun

@defun logcount i
Count the number of 1-bits in @var{i}, if it is non-negative.
If @var{i} is negative, count number of 0-bits.
@end defun

@defun integer-length i
Return number of bits needed to represent @var{i} in an unsigned field.
Regardless of the sign of @var{i}, return one less than the number of bits
needed for a field that can represent @var{i} as a two's complement integer.
@end defun

@defun bit-extract n start end
Return the integer formed from the (unsigned) bit-field
starting at @var{start} and ending just before @var{end}.
Same as @code{(arithmetic-shift (bitand n (bitnot (arithmetic-shift -1 end))) (- start))}.
@end defun

@node Strings, Files, Logical Number Operations, Extensions
@section Strings

@defun string-upcase str
Return a new string where the letters in @var{str} are replaced
by their upper-case equivalents.
@end defun

@defun string-downcase str
Return a new string where the letters in @var{str} are replaced
by their lower-case equivalents.
@end defun

@defun string-capitalize str
Return a new string where the letters in @var{str} that start a new word
are replaced by their title-case equivalents, while non-initial letters
are replaced by their lower-case equivalents.
@end defun

@defun string-upcase! str
Destructively modify @var{str}, replacing the letters
by their upper-case equivalents.
@end defun

@defun string-downcase! str
Destructively modify @var{str}, replacing the letters
by their upper-lower equivalents.
@end defun

@defun string-capitalize! str
Destructively modify @var{str}, such that the letters that start a new word
are replaced by their title-case equivalents, while non-initial letters
are replaced by their lower-case equivalents.
@end defun

@node Files, Ports, Strings, Extensions
@section File System Interface

@defun file-exists? filename
Returns true iff the file named @var{filename} actually exists.
@end defun

@defun file-directory? filename
Returns true iff the file named @var{filename} actually exists
and is a directory.
@end defun

@defun file-readable? filename
Returns true iff the file named @var{filename} actually exists
and can be read from.
@end defun

@defun file-writable? filename
Returns true iff the file named @var{filename} actually exists
and can be writen to.
(Undefined if the @var{filename} does not exist,
but the file can be created in the directory.)
@end defun

@defun delete-file filename
Delete the file named @var{filename}.
@end defun

@defun rename-file oldname newname
Renames the file named @var{oldname} to @var{newname}.
@end defun

@defun copy-file oldname newname-from path-to
Copy the file named @var{oldname} to @var{newname}.
The return value is unspecified.
@end defun

@defun create-directory dirname
Create a new directory named @var{dirname}.
Unspecified what happens on error (such as exiting file with the same name).
(Currently returns @code{#f} on error, but may change to be more compatible
with scsh.)
@end defun

@defun system-tmpdir
Return the name of the default directory for temporary files.
@end defun

@defun make-temporary-file [format]
Return a file with a name that does not match any existing file.
Use @var{format} (which defaults to @code{"kawa~d.tmp"}) to generate
a unique filename in @code{(system-tmpdir)}.
The current implementation is @emph{not} safe from race conditions;
this will be fixed in a future release (using Java2 features).
@end defun

@node Ports, Format, Files, Extensions
@section Ports

@defun read-line [port [handle-newline]]
Reads a line of input from @var{port}.
The @var{handle-newline} parameter determines what is done with
terminating end-of-line delimiter.
The default, @code{'trim}, ignores the delimiter;
@code{'peek} leaves the delimiter in the input stream;
@code{'concat} appends the delimiter to the returned value;
and @code{'split} returns the delimiter as a second value.
You can use the last three options to tell if the string was
terminated by end-or-line or by end-of-file.
@end defun

@defun open-input-string string
Takes a string and returns an input port that delivers characters
from the string. The port can be closed by @code{close-input-port},
though its storage will be reclaimed by the
garbage collector if it becomes inaccessible. 

@example
(define p
  (open-input-string "(a . (b c . ())) 34"))

(input-port? p)                 -->  #t
(read p)                        -->  (a b c)
(read p)                        -->  34
(eof-object? (peek-char p))     -->  #t
@end example
@end defun

@defun open-output-string
Returns an output port that will accumulate characters
for retrieval by @code{get-output-string}.
The port can be closed by the procedure @code{close-output-port},
though its storage will be reclaimed by the garbage collector
if it becomes inaccessible. 
@example
(let ((q (open-output-string))
  (x '(a b c)))
    (write (car x) q)
    (write (cdr x) q)
    (get-output-string q))        -->  "a(b c)"
@end example
@end defun

@defun get-output-string output-port
Given an output port created by @code{open-output-string},
returns a string consisting of the characters that have been
output to the port so far. 
@end defun

@defun call-with-input-string string proc
Create an input port that gets its data from @var{string},
call @var{proc} with that port as its one argument, and return
the result from the call of @var{proc}
@end defun

@defun call-with-output-string proc
Create an output port that writes its data to a @var{string},
and call @var{proc} with that port as its one argument.
Return a string consisting of the data written to the port.
@end defun

@defun force-output [port]
Forces any pending output on @var{port} to be delivered to the output
device and returns an unspecified value.  If the @var{port} argument is
omitted it defaults to the value returned by @code{(current-output-port)}.
@end defun

An interactive input port has a prompt procedure associated with it.
The prompt procedure is called before a new line is read.  It is passed
the port as an argument, and returns a string, which gets printed as a prompt.

@defun input-port-prompter port
Get the prompt procedure associated with @var{port}.
@end defun

@defun set-input-port-prompter! port prompter
Set the prompt procedure associated with @var{port} to @var{prompter},
which must be a one-argument procedure taking an input port,
and returning a string.
@end defun

@defun default-prompter port
The default prompt procedure.  It returns @code{"#|kawa:@var{L}|# "}, where
@var{L} is the current line number of @var{port}.
When reading a continuation line, the result
is @code{"#|@var{C}---:@var{L}|# "}, where @code{C} is the character returned
by @code{(input-port-read-state @var{port})}.
The prompt has the form of a comment to make it easier to cut-and-paste.
@end defun

@deffn Function port-column input-port
@deffnx Function port-line input-port
Return the current column number or line number of @var{input-port},
using the current input port if none is specified.
If the number is unknown, the result is @code{#f}.  Otherwise,
the result is a 0-origin integer - i.e. the first character
of the first line is line 0, column 0.  (However, when you
display a file position, for example in an error message,
we recommend you add 1 to get 1-origin integers.  This is
because lines and column numbers traditionally start with
1, and that is what non-programmers will find most natural.)
@end deffn

@defun set-port-line! port line
Set (0-origin) line number of the current line of @var{port} to @var{num}.
@end defun

@defun input-port-line-number port
Get the line number of the current line of @var{port},
which must be a (non-binary) input port.
The initial line is line 1.
Deprecated; replaced by @code{(+ 1 (port-line @var{port}))}.
@end defun

@defun set-input-port-line-number! port num
Set line number of the current line of @var{port} to @var{num}.
Deprecated;  replaced by @code{(set-port-line @var{port} (- @var{num} 1))}.
@end defun

@defun input-port-column-number port 
Get the column number of the current line of @var{port}, 
which must be a (non-binary) input port.
The initial column is column 1.
Deprecated; replaced by @code{(+ 1 (port-column @var{port}))}.
@end defun

@defun input-port-read-state port
Returns a character indicating the current @code{read} state of the @var{port}.
Returns @code{#\Return} if not current doing a @var{read},
@code{#\"} if reading a string;  @code{#\|} if reading a comment;  @code{#\(}
if inside a list; and @code{#\Space} when otherwise in a @code{read}.
The result is intended for use by prompt prcedures, and is not necessarily
correct except when reading a new-line.
@end defun

@defvar symbol-read-case
A symbol that controls how @code{read} handles letters when reading a symbol.
If the first letter is @samp{U}, then letters in symbols are upper-cased.
If the first letter is @samp{D} or @samp{L}, then letters
in symbols are down-cased.
If the first letter is @samp{I}, then the case of letters in symbols
is inverted.
Otherwise (the default), the letter is not changed.
(Letters following a @samp{\} are always unchanged.)
@end defvar

@defvar port-char-encoding
Controls how bytes in external files are converted to/from internal
Unicode characters.  Can be either a symbol or a boolean.
If @code{port-char-encoding} is @code{#f}, the file is assumed
to be a binary file and no conversion is done.
Otherwise, the file is a text file.  The default is @code{#t}, which
uses a locale-dependent conversion.  If @code{port-char-encoding}
is a symbol, it must be the name of a character encoding known to Java.
For all text files (that is if @code{port-char-encoding} is not @code{#f}),
on input a @code{#\Return} character or
a @code{#\Return} followed by @code{#\Newline}
are converted into plain @code{#\Newline}.

This variable is checked when the file is opened;  not when actually
reading or writing.  Here is an example of how you can safely
change the encoding temporarily:
@example
(define (open-binary-input-file name)
  (fluid-let ((port-char-encoding #f)) (open-input-file name)))
@end example
@end defvar

@node Format, Exceptions, Ports, Extensions
@section Formatted Output (Common-Lisp-style)

@defun format destination fmt . arguments
An almost complete implementation of Common LISP format description
according to the CL reference book @cite{Common LISP} from Guy L.
Steele, Digital Press.  Backward compatible to most of the available
Scheme format implementations.

Returns @code{#t}, @code{#f} or a string; has side effect of printing
according to @var{fmt}.  If @var{destination} is @code{#t},
the output is to the current output port and @code{#t} is returned.  If
@var{destination} is @code{#f}, a formatted string is returned as the
result of the call.  If @var{destination} is a string,
@var{destination} is regarded as the format string; @var{fmt} is
then the first argument and the output is returned as a string. If
@var{destination} is a number, the output is to the current error port
if available by the implementation. Otherwise @var{destination} must be
an output port and @code{#t} is returned.@refill

@var{fmt} must be a string or an instance of @code{gnu.text.MessageFormat}
or @code{java.text.MessageFormat}.  If @var{fmt} is a string,
it is parsed as if by @code{parse-format}.
@end defun

@defun parse-format format-string
Parses @code{format-string}, which is a string of the form of a Common LISP
format description.  Returns an instance of @code{gnu.text.ReportFormat},
which can be passed to the @code{format} function.
@end defun

A format string passed to @code{format} or @code{parse-format}
consists of format directives (that start with @samp{~}),
and regular characters (that are written directly to the destination).
Most of the Common Lisp (and Slib) format directives are implemented.
Neither justification, nor pretty-printing are supported yet.

Plus of course, we need documentation for @code{format}!

@subsection Implemented CL Format Control Directives

Documentation syntax: Uppercase characters represent the corresponding
control directive characters. Lowercase characters represent control
directive parameter descriptions.

@table @asis
@item @code{~A}
Any (print as @code{display} does).
@table @asis
@item @code{~@@A}
left pad.
@item @code{~@var{mincol},@var{colinc},@var{minpad},@var{padchar}A}
full padding.
@end table
@item @code{~S}
S-expression (print as @code{write} does).
@table @asis
@item @code{~@@S}
left pad.
@item @code{~@var{mincol},@var{colinc},@var{minpad},@var{padchar}S}
full padding.
@end table

@item @code{~C}
Character.
@table @asis
@item @code{~@@C}
prints a character as the reader can understand it (i.e. @code{#\} prefixing).
@item @code{~:C}
prints a character as emacs does (eg. @code{^C} for ASCII 03).
@end table
@end table

@subsection Formatting Integers

@table @asis
@item @code{~D}
Decimal.
@table @asis
@item @code{~@@D}
print number sign always.
@item @code{~:D}
print comma separated.
@item @code{~@var{mincol},@var{padchar},@var{commachar},@var{commawidth}D}
padding.
@end table
@item @code{~X}
Hexadecimal.
@table @asis
@item @code{~@@X}
print number sign always.
@item @code{~:X}
print comma separated.
@item @code{~@var{mincol},@var{padchar},@var{commachar},@var{commawidth}X}
padding.
@end table
@item @code{~O}
Octal.
@table @asis
@item @code{~@@O}
print number sign always.
@item @code{~:O}
print comma separated.
@item @code{~@var{mincol},@var{padchar},@var{commachar},@var{commawidth}O}
padding.
@end table
@item @code{~B}
Binary.
@table @asis
@item @code{~@@B}
print number sign always.
@item @code{~:B}
print comma separated.
@item @code{~@var{mincol},@var{padchar},@var{commachar},@var{commawidth}B}
padding.
@end table
@item @code{~@var{n}R}
Radix @var{n}.
@table @asis
@item @code{~@var{n},@var{mincol},@var{padchar},@var{commachar},@var{commawidth}R}
padding.
@end table
@item @code{~@@R}
print a number as a Roman numeral.
@item @code{~:@@R}
print a number as an ``old fashioned'' Roman numeral.
@item @code{~:R}
print a number as an ordinal English number.
@item @code{~:@@R}
print a number as a cardinal English number.
@item @code{~P}
Plural.
@table @asis
@item @code{~@@P}
prints @code{y} and @code{ies}.
@item @code{~:P}
as @code{~P but jumps 1 argument backward.}
@item @code{~:@@P}
as @code{~@@P but jumps 1 argument backward.}
@end table
@end table

@var{commawidth} is the number of characters between two comma characters.


@subsection Formatting floating-point (real) numbers

@table @asis
@item @code{~F}
Fixed-format floating-point (prints a flonum like @var{mmm.nnn}).
@table @asis
@item @code{~@var{width},@var{digits},@var{scale},@var{overflowchar},@var{padchar}F}
@item @code{~@@F}
If the number is positive a plus sign is printed.
@end table
@end table

@table @asis
@item @code{~E}
Exponential floating-point (prints a flonum like @var{mmm.nnn}@code{E}@var{ee})
@table @asis
@item @code{~@var{width},@var{digits},@var{exponentdigits},@var{scale},@var{overflowchar},@var{padchar},@var{exponentchar}E}
@item @code{~@@E}
If the number is positive a plus sign is printed.
@end table
@end table

@table @asis
@item @code{~G}
General floating-point (prints a flonum either fixed or exponential).
@table @asis
@item @code{~@var{width},@var{digits},@var{exponentdigits},@var{scale},@var{overflowchar},@var{padchar},@var{exponentchar}G}
@item @code{~@@G}
If the number is positive a plus sign is printed.
@end table
A slight difference from Common Lisp:  If the number is printed
in fixed form and the fraction is zero,
then a zero digit is printed for the fraction, if allowed by the @var{width}
and @var{digits} is unspecified.
@end table

@table @asis
@item @code{~$}
Dollars floating-point (prints a flonum in fixed with signs separated).
@table @asis
@item @code{~@var{digits},@var{scale},@var{width},@var{padchar}$}
@item @code{~@@$}
If the number is positive a plus sign is printed.
@item @code{~:@@$}
A sign is always printed and appears before the padding.
@item @code{~:$}
The sign appears before the padding.
@end table
@end table

@subsection Miscellaneous formatting operators

@table @asis
@item @code{~%}
Newline.
@table @asis
@item @code{~@var{n}%}
print @var{n} newlines.
@end table
@item @code{~&}
print newline if not at the beginning of the output line.
@table @asis
@item @code{~@var{n}&}
prints @code{~&} and then @var{n-1} newlines.
@end table
@item @code{~|}
Page Separator.
@table @asis
@item @code{~@var{n}|}
print @var{n} page separators.
@end table
@item @code{~~}
Tilde.
@table @asis
@item @code{~@var{n}~}
print @var{n} tildes.
@end table
@item @code{~}<newline>
Continuation Line.
@table @asis
@item @code{~:}<newline>
newline is ignored, white space left.
@item @code{~@@}<newline>
newline is left, white space ignored.
@end table
@item @code{~T}
Tabulation.
@table @asis
@item @code{~@@T}
relative tabulation.
@item @code{~@var{colnum},@var{colinc}T}
full tabulation.
@end table
@item @code{~?}
Indirection (expects indirect arguments as a list).
@table @asis
@item @code{~@@?}
extracts indirect arguments from format arguments.
@end table
@item @code{~(@var{str}~)}
Case conversion (converts by @code{string-downcase}).
@table @asis
@item @code{~:(@var{str}~)}
converts by @code{string-capitalize}.
@item @code{~@@(@var{str}~)}
converts by @code{string-capitalize-first}.
@item @code{~:@@(@var{str}~)}
converts by @code{string-upcase}.
@end table
@item @code{~*}
Argument Jumping (jumps 1 argument forward).
@table @asis
@item @code{~@var{n}*}
jumps @var{n} arguments forward.
@item @code{~:*}
jumps 1 argument backward.
@item @code{~@var{n}:*}
jumps @var{n} arguments backward.
@item @code{~@@*}
jumps to the 0th argument.
@item @code{~@var{n}@@*}
jumps to the @var{n}th argument (beginning from 0)
@end table
@item @code{~[@var{str0}~;@var{str1}~;...~;@var{strn}~]}
Conditional Expression (numerical clause conditional).
@table @asis
@item @code{~@var{n}[}
take argument from @var{n}.
@item @code{~@@[}
true test conditional.
@item @code{~:[}
if-else-then conditional.
@item @code{~;}
clause separator.
@item @code{~:;}
default clause follows.
@end table
@item @code{~@{@var{str}~@}}
Iteration (args come from the next argument (a list)).
@table @asis
@item @code{~@var{n}@{}
at most @var{n} iterations.
@item @code{~:@{}
args from next arg (a list of lists).
@item @code{~@@@{}
args from the rest of arguments.
@item @code{~:@@@{}
args from the rest args (lists).
@end table
@item @code{~^}
Up and out.
@table @asis
@item @code{~@var{n}^}
aborts if @var{n} = 0
@item @code{~@var{n},@var{m}^}
aborts if @var{n} = @var{m}
@item @code{~@var{n},@var{m},@var{k}^}
aborts if @var{n} <= @var{m} <= @var{k}
@end table
@end table

@subsection Not Implemented CL Format Control Directives

@table @asis
@item @code{~:A}
print @code{#f} as an empty list (see below).
@item @code{~:S}
print @code{#f} as an empty list (see below).
@item @code{~<~>}
Justification.
@item @code{~:^}
@end table

@subsubsection Extended, Replaced and Additional Control Directives

These are not necesasrily implemented in Kawa!

@table @asis
@item @code{~I}
print a R4RS complex number as @code{~F~@@Fi} with passed parameters for
@code{~F}.
@item @code{~Y}
Pretty print formatting of an argument for scheme code lists.
@item @code{~K}
Same as @code{~?.}
@item @code{~!}
Flushes the output if format @var{destination} is a port.
@item @code{~_}
Print a @code{#\space} character
@table @asis
@item @code{~@var{n}_}
print @var{n} @code{#\space} characters.
@end table

@item @code{~@var{n}C}
Takes @var{n} as an integer representation for a character. No arguments
are consumed. @var{n} is converted to a character by
@code{integer->char}.  @var{n} must be a positive decimal number.@refill
@item @code{~:S}
Print out readproof.  Prints out internal objects represented as
@code{#<...>} as strings @code{"#<...>"} so that the format output can always
be processed by @code{read}.
@refill
@item @code{~:A}
Print out readproof.  Prints out internal objects represented as
@code{#<...>} as strings @code{"#<...>"} so that the format output can always
be processed by @code{read}.
@refill
@item @code{~F, ~E, ~G, ~$}
may also print number strings, i.e. passing a number as a string and
format it accordingly.
@end table

@node Exceptions, Locations, Format, Extensions
@section Signalling and recovering from exceptions

@defun catch key thunk handler
Invoke @var{thunk} in the dynamic context of @var{handler} for
exceptions matching @var{key}.  If thunk throws to the symbol @var{key},
then @var{handler} is invoked this way:

@example
(handler key args ...)
@end example

@var{key} may be a symbol.  The @var{thunk} takes no
arguments.  If @var{thunk} returns normally, that is the return value of
@code{catch}.

Handler is invoked outside the scope of its own @code{catch}.  If
@var{handler} again throws to the same key, a new handler from further
up the call chain is invoked.

If the key is @code{#t}, then a throw to @emph{any} symbol will match
this call to @code{catch}.
@end defun

@defun throw key &rest args ...
Invoke the catch form matching @var{key}, passing @var{args} to the
@var{handler}.  

If the key is a symbol it will match catches of the same
symbol or of #t.

If there is no handler at all, an error is signaled.
@end defun

@deffn procedure error message args ...
Raise an error with key @code{misc-error} and a message constructed by
displaying @var{msg} and writing @var{args}.
This normally prints a stack trace, and brings you back to
the top level, or exits kawa if you are not running interactively.
@end deffn

@defun primitive-throw exception
Throws the @var{exception}, which must be an instance of a sub-class
of @code{<java.lang.Throwable>}.
@end defun

@deffn Syntax try-finally body handler
Evaluate @var{body}, and return its result.
However, before it returns, evaluate @var{handler}.
Even if @var{body} returns abnormally (by throwing an exception),
@var{handler} is evaluated.

(This is implemented just like Java's @code{try}-@code{finally}.)
@end deffn

@deffn Syntax try-catch body handler ...
Evaluate @var{body}, in the conect of the given @var{handler-spec}s.
Each @var{handler} has the form:
@example
@var{var} @var{type} @var{exp} ...
@end example
If an exception is thrown in @var{body}, the first @var{handle-spec}
is selected such that the thrown exception is an instance of
the @var{handler}'s @var{type}. If no @var{handler} is selected,
the exception is propagated through the dynamic execution context
until a matching @var{handler} is found.  (If no matching @var{handler}
is found, then an error message is printed, and the computation terminated.)

Once a @var{handler} is selected,
the @var{var} is bound to the thrown exception, and the @var{exp} in
the @var{handler} are executed.  The result of the @code{try-catch}
is the result of @var{body} if no exception is thrown, or the
value of the last @var{exp} in the selected @var{handler} if an
exception is thrown.

(This is implemented just like Java's @code{try}-@code{catch}.)
@end deffn

@defun dynamic-wind in-guard thunk out-guard
All three arguments must be 0-argument procedures.
First calls @var{in-guard}, then @var{thunk}, then @var{out-guard}.
The result of the expression is that of @var{thunk}.
If @var{thunk} is exited abnormally (by throwing an exception or
invoking a continuation), @var{out-guard} is called.

If the continuation of the dynamic-wind is re-entered (which
is not yet possible in Kawa), the @var{in-guard} is called again.

This function was added in R5RS.
@end defun

@node Locations, Eval and Environments, Exceptions, Extensions
@section Locations

A @dfn{location} is a place where a value can be stored.
An @dfn{lvalue} is an expression that refers to a location.
(The name "lvalue" refers to the fact that the left operand
of @code{set!} is an lvalue.)
The only kind of lvalue in standard Scheme is a @dfn{variable}.
Kawa also allows @dfn{computed lvalues}.  These are procedure
calls used in "lvalue context", such as the left operand of @code{set!}.

You can only use procedures that have an associated @dfn{setter}.
In that case, @code{(set! (f arg ...) value)}
is equivalent to @code{((setter f) value arg ...)}
(It is possible the definition will change
to @code{((setter f) arg ... value)} if Guile goes for that.)
Currently, only a few procedures have associated @code{setter}s,
and only builtin procedures written in Java can have @code{setter}s.

For example:
@example
(set! (car x) 10)
@end example
is equivalent to:
@example
(set-car! x 10)
@end example

Kawa also gives you access to locations as first-class values:

@deffn Syntax location lvalue
Returns a location object for the given @var{lvalue}.
You can get its value (by applying it, as if it were a procedure),
and you can set its value (by using @code{set!} on the application).
The @var{lvalue} can be a local or global variable, or a procedure
call using a procedure that has a @code{setter}.
@example
(define x 100)
(define lx (location x))
(set! (lx) (cons 1 2)) ;; set x to (1 . 2)
(lx)  ;; returns (1 . 2)
(define lc (location (car x)))
(set! (lc) (+ 10 (lc)))
;; x is now (11 . 2)
@end example
@end deffn

@deffn Syntax define-alias variable lvalue
Define @var{variable} as an alias for @var{lvalue}.
In other words, makes it so that @code{(location @var{variable})}
is equivalent to @code{(location @var{lvalue})}.
This works both top-level and inside a function.
@end deffn

Some people mind find it helpful to think of a location
as a settable @dfn{thunk}.  Others may find it useful to
think of the @code{location} syntax as similar to the C @samp{&} operator;
for the @samp{*} indirection operator, Kawa uses procedure application.

@node Eval and Environments, Debugging, Locations, Extensions
@section Eval and Environments

@defun eval expression [environment]
@code{eval} evaluates @var{expression} in the environment indicated
by @var{environment}.

The default for @var{environment} is the result
of @code{(interaction-environment)}.
@end defun

@defun null-environment
This procedure returns an environment that contains no variable bindings,
but contains (syntactic) bindings for all the syntactic keywords.

The effect of assigning to a variable in this environment (such
as @code{let}) is undefined.
@end defun

@defun scheme-report-environment version
The @var{version} must be an exact non-negative inetger corresponding to
a version of one of the Revised@var{version} Reports on Scheme.
The procedure returns an environment that contains exactly the set of
bindings specified in the corresponding report.

This implementation supports @var{version} that is 4 or 5.

The effect of assigning to a variable in this environment (such
as @code{car}) is undefined.
@end defun

@defun interaction-environment
This procedure return an environment that contains implementation-defined
bindings, as well as top-level user bindings.
@end defun

@defun environment-bound? environment symbol
Return true @code{#t} if there is a binding for @var{symbol}
in @var{environment};  otherwise returns @code{#f}.
@end defun

@deffn Syntax fluid-let ((variable init) ...) body ...
Evaluate the @var{init} expressions.
Then modify the dynamic bindings for the @var{variables} to the
values of the @var{init} expressions, and evaluate the @var{body} expressions.
Return the result of the last expression in @var{body}.
Before returning, restore the original bindings.
The temporary bindings are only visible in the current thread, and its
descendent threads.
@end deffn

@node Debugging, Threads, Eval and Environments, Extensions
@section Debugging

@deffn Syntax trace procedure
Cause @var{procedure} to be "traced", that is debugging output will
be written to the standard error port every time @var{procedure}
is called, with the parameters and return value.
@end deffn

@deffn Syntax untrace procedure
Turn off tracing (debugging output) of @var{procedure}.
@end deffn

@node Threads, Processes, Debugging, Extensions
@section Threads

There is a very preliminary interface to create parallel threads.
The interface is similar to the standard @code{delay}/@code{force},
where a thread is basically the same as a promise, except that
evaluation may be in parallel.

So far, little or no effort has been made into making Kawa
thread-safe.  There are no per-thread bindings, and
the current input and output parts are global.
That needs to change.

@deffn Syntax future expression
Creates a new thread that evaluates @var{expression}.
@end deffn

@defun force thread
The standard @code{force} function has generalized to also work
on threads.  If waits for the thread's @var{expression} to finish
executing, and returns the result.
@end defun

@defun sleep time
Suspends the current thread for the specified time.
The @var{time} can be either a pure number (in secords),
or a quantity whose unit is a time unit (such as @code{10s}).
@end defun

@node Processes, Miscellaneous, Threads, Extensions
@section Processes

@defun make-process command envp
Creates a @code{<java.lang.Process>} object, using the specified
@var{command} and @var{envp}.
The @var{command} is converted to an array of Java strings
(that is an object that has type @code{<java.lang.String[]>}.
It can be a Scheme vector or list (whose elements should be
Java strings or Scheme strings);  a Java array of Java strings;
or a Scheme string.  In the latter case, the command is converted
using @code{command-parse}.
The @var{envp} is process environment;  it should be either
a Java array of Java strings, or the special @code{#!null} value.
@end defun

@defun system command
Runs the specified @var{command}, and waits for it to finish.
Returns the return code from the command.  The return code is an integer,
where 0 conventionally means successful completion.
The @var{command} can be any of the types handled by @code{make-process}.
@end defun

@defvar command-parse
The value of this variable should be a one-argument procedure.
It is used to convert a command from a Scheme string to a Java
array of the constituent "words".
The default binding, on Unix-like systems, returns a new command to
invoke @code{"/bin/sh" "-c"} concatenated with the command string;
on non-Unix-systems, it is bound to @code{tokenize-string-to-string-array}.
@end defvar

@defun tokenize-string-to-string-array command
Uses a @code{java.util.StringTokenizer} to parse the @var{command} string
into an array of words.  This splits the @var{command} using spaces
to delimit words; there is no special processing for quotes or other
special characters.
(This is the same as what @code{java.lang.Runtime.exec(String)} does.)
@end defun

@node Miscellaneous,  , Processes, Extensions
@section Miscellaneous

@defun scheme-implementation-version
Returns the Kawa version number as a string.
@c (Compatible with slib.)
@end defun

@defun gentemp
Returns a new (interned) symbol each time it is called.
The symbol names are implementation-dependent.
@end defun

@deffn Syntax defmacro name lambda-list form ...
Defines an old-style macro a la Common Lisp,
and installs @code{(lambda @var{lambda-list} @var{form} ...)}
as the expansion function for @var{name}.
When the translator sees an application of @var{name},
the expansion function is called with the rest of the application
as the actual arguments.  The resulting object must be a Scheme
source form that is futher processed (it may be repeatedly macro-expanded).

If you define a macro with @code{defmacro}, you (currently) cannot use
the macro in the same compilation as the definition.
This restriction does not apply to macros defined by @code{define-syntax}.
@end deffn

@defvar command-line-arguments
Any command-line arguments (following flags processed by Kawa itself)
are assigned to the global variable @samp{command-line-arguments},
which is a vector of strings.
@end defvar

@defvar home-directory
A string containing the home directory of the user.
@end defvar

@defun exit [code]
Exits the Kawa interpreter, and ends the Java session.
The integer value @var{code} is returned to the operating
system.  If @var{code} is not specified, zero is returned,
indicating normal (non-error) termination.
@end defun

@defun scheme-window [shared]
Create a read-eval-print-loop in a new top-level window.
If @var{shared} is true, it uses the same environment as the
current @code{(interaction-environment)};  if not (the default),
a new top-level environment is created.

You can create multiple top-level window that can co-exist.
They run in separate threads.
@end defun

@defun apply proc [arg1 ...] args
@var{Args} must be a sequence (list, vector, or string) or a
primitive Java array.
(This is an extension over standard Scheme, which requires that
@var{args} be a list.)
Calls the @var{proc} (which must be a procedure), using as arguments
the @var{arg1}... values plus all the elements of @var{args}.
@end defun

@deffn Syntax constant-fold proc arg1 ...
Same as @code{(@var{proc} @var{arg1} ...)}, unless @var{proc} and
all the following arguments are compile-time constants.
(That is:  They are either constant, or symbols that have a global
binding and no lexical binding.)  In that case, @var{proc}
is applied to the arguments at compile-time, and the result replaces
the @code{constant-fold} form.  If the application raises an exception,
a compile-time error is reported.
For example:
@example
(constant-fold vector 'a 'b 'c)
@end example
is equivalent to @code{(quote #(a b c))}, assuming @code{vector}
has not been re-bound.
@end deffn

@deffn Syntax when condition form...
If @var{condition} is true, evaluate each @var{form} in order,
returning the value of the last one.
@end deffn

@deffn Syntax unless condition form...
If @var{condition} is false, evaluate each @var{form} in order,
returning the value of the last one.
@end deffn

@defun vector-append @var{arg}...
Creates a new vector, containing the elements from all the @var{arg}s
appended together.   Each @var{arg} may be a vector or a list.
@end defun

@defun instance? value type
Returns @code{#t} iff @var{value} is an instance of type @var{type}.
(Undefined if @var{type} is a primitive type, such as @code{<int>}.)
@end defun

@defun as type value
Converts or coerces @var{value} to a value of type @var{type}.
Throws an exception if that cannot be done.
Not supported for @var{type} to be a primitive type such as @code{<int>}.
@end defun

@deffn Syntax synchronized object form ...
Synchronize on the given @var{object}.  (This means getting an
exclusive lock on the object, by acquiring its @dfn{monitor}.)
Then execute the @var{form}s while holding the lock.
When the @var{form}s finish (normally or abnormally by throwing
an exception), the lock is released.
Returns the result of the last @var{form}.
Equivalent to the Java @code{synchronized} statement,
except that it may return a result.
@end deffn

@node Types, Objects and Classes, Extensions, Top
@chapter Types

A @dfn{type} is a set of values, plus an associated set of operations
valid on those values.
Types are useful for catching errors ("type-checking"), documenting
the programmer's intent, and to help the compiler generate better code.
Types in some languages (such as C) appear in programs,
but do not exist at run-time.  In such languages, all type-checking
is done at compile-time.  Other languages (such as standard Scheme)
do not have types as such, but they have @dfn{predicates}, which
allow you to check if a value is a member of certain sets;  also,
the primitive functions will check at run-time if the arguments
are members of the allowed sets.  Other languages, including Java
and Common Lisp, provide a combination:  Types may be used as specifiers
to guide the compiler, but also exist as actual run-time values.
In Java, for each class, there is a corresponding @code{java.lang.Class}
run-time object, as well as an associated type (the set of values
of that class, plus its sub-classes, plus @code{null}).

Kawa, like Java, has first-class types, that is types exist as
objects you can pass around at run-time.  For each Java type,
there is a corresponding Kawa type (but not necessarily vice
versa).  It would be nice if we could represent run-time
type values using @code{java.lang.Class} objects, but unfortunately
that does not work very well.  One reason is that we need
to be able to refer to types and classes that do not exist yet,
because we are in the processing of compiling them.  Another
reason is that we want to be able to distinuish between different
types that are implemented using the same Java class.

Various Kawa constructs require or allow a type to be specified.
Those specifications consist of @dfn{type expressions}, which
is evaluated to yield a type value.  The current Kawa compiler
is rather simple-minded, and in many places only allows simple
types that the compiler can evaluate at compile-time.
More specifically, it only allows simple @dfn{type names}
that map to primitive Java types or java classes.

@menu
* Standard Types::
* Declaring Types of Variables::
@end menu

@node Standard Types, Declaring Types of Variables, Types, Types
@section Standard Types

These types are bound to identifiers having the form @code{<TYPENAME>}.
(This syntax and most of the names are as in RScheme.)

To find which Java classes these types map into, look in
@code{kawa/standard/Scheme.java}.

Note that the value of these variables are instances
of @code{gnu.bytecode.Type},
not (as you might at first expect) @code{java.lang.Class}.

@defvar <object>
An arbitrary Scheme value - and hence an arbitrary Java object.
@end defvar

@defvar <number>
The type of Scheme numbers.
@end defvar

@defvar <quantity>
The type of quantities optionally with units.
This is a sub-type of @code{<number>}.
@end defvar

@defvar <complex>
The type of complex numbers.
This is a sub-type of @code{<quantity>}.
@end defvar

@defvar <real>
The type of real numbers.
This is a sub-type of @code{<complex>}.
@end defvar

@defvar <rational>
The type of complex numbers.
This is a sub-type of @code{<real>}.
@end defvar

@defvar <integer>
The type of Scheme integers.
This is a sub-type of @code{<rational>}.
@end defvar

@defvar <symbol>
The type of Scheme symbols.
@end defvar

@defvar <keyword>
The type of keyword values.  @xref{Keywords}.
@end defvar

@defvar <list>
The type of Scheme lists (pure and impure, including the empty list).
@end defvar

@defvar <pair>
The type of Scheme pairs.  This is a sub-type of @code{<list>}.
@end defvar

@defvar <string>
The type of (mutable) Scheme strings.
This is @emph{not} the same as (non-mutable) Java strings
(which happen to be the same as @code{<symbol>}).
@end defvar

@defvar <character>
The type of Scheme character values.  This is a sub-type of
@code{<object>}, in contrast to type @code{<char>}, which is the
primitive Java @code{char} type.
@end defvar

@defvar <vector>
The type of Scheme vectors.
@end defvar

@defvar <function>
The type of Scheme procedures.
@end defvar

@defvar <input-port>
The type of Scheme input ports.
@end defvar

@defvar <output-port>
The type of Scheme output ports.
@end defvar

@defvar <String>
This type name is a special case.  It specifies the class
@code{<java.lang.String>} (just as @code{<symbol>} does).
However, coercing a value to @code{<String>} is done by
invoking the @code{toString} method on the value to be coerced.
Thus it "works" for all objects.
However, it does not work for @code{#!null}.  (Using
the fully-qualified @code{<java.lang.String>} does work for @code{#!null},
but does not work for non-@code{String} objects.)
@end defvar

More will be added later.

A type specifier can also be one of the primitive Java types.
The numeric types @code{<long>}, @code{<int>}, @code{<short>},
@code{<byte>}, @code{<float>}, and @code{<double>} are converted from the
corresponding Scheme number classes.  Similarly, @code{<char>}
can be converted to and from Scheme characters.  The type
@code{boolean} matches any object, and the result is @code{false}
if and only if the actual argument is @code{#f}.
The return type @code{<void>} indicates that no value is returned.

A type specifier can also be a fully-qualified Java class name
(for example @code{<java.lang.StringBuffer>}).  In that case,
the actual argument is cast at run time to the named class.
Also, @code{<java.lang.StringBuffer[]>} represents
an array of references to @code{java.lang.StringBuffer} objects.

@node Declaring Types of Variables,  , Standard Types, Types
@section Declaring Types of Variables

@deffn Syntax let ((name [:: type] init) ...) body
Declare new locals variables with the given @var{name}, initial value
@var{init}, and optional type specification @var{type}.
If @var{type} is specified, then the expression @var{init} is evaluated,
the result coerced to @var{type}, and then assigned to the variable.
If @var{type} is not specified, it defaults to @code{<object>}.
@end deffn

@deffn Syntax let* ((name [:: type] init) ...) body
@end deffn

@deffn Syntax letrec ((name [:: type] init) ...) body
@end deffn


@node Objects and Classes, Low-level functions, Types, Top
@chapter Object-oriented features

Kawa provides various ways to define, create, and access Java objects.
Here are the currently supported features.

@menu
* Records::
* Mangling::              Mapping Scheme names to Java names
* Allocating objects::
* Field operations::      Accessing fields of Java objects
* Method operations::     Calling Java methods from Scheme
* Anonymous classes::
@end menu

@node Records, Mangling, Objects and Classes, Objects and Classes
@section Records

The Record package provides a facility for users to define their own
record data types.  Records are extensions of the class @code{Record}.
These procedures use the Java 1.1 reflection facility.

@defun make-record-type type-name field-names
Returns a @dfn{record-type descriptor}, a value representing a new data
type disjoint from all others.  The @var{type-name} argument must be a
string, but is only used for debugging purposes (such as the printed
representation of a record of the new type).  The @var{field-names}
argument is a list of symbols naming the @dfn{fields} of a record of the
new type.  It is an error if the list contains any duplicates.
@end defun

@c @defun make-record-sub-type type-name field-names rtd
@c Returns a @dfn{record-type descriptor}, a value representing a new data
@c type, disjoint from all others.  The @var{type-name} argument must be a
@c string.  The @var{field-names} argument is a list of symbols naming the
@c additional @dfn{fields} to be appended to @var{field-names} of
@c @var{rtd}.  It is an error if the combinded list contains any
@c duplicates.@refill
@c
@c Record-modifiers and record-accessors for @var{rtd} work for the new
@c record-sub-type as well.  But record-modifiers and record-accessors for
@c the new record-sub-type will not neccessarily work for @var{rtd}.@refill
@c @end defun

@defun record-constructor rtd [field-names]
Returns a procedure for constructing new members of the type represented
by @var{rtd}.  The returned procedure accepts exactly as many arguments
as there are symbols in the given list, @var{field-names}; these are
used, in order, as the initial values of those fields in a new record,
which is returned by the constructor procedure.  The values of any
fields not named in that list are unspecified.  The @var{field-names}
argument defaults to the list of field names in the call to
@code{make-record-type} that created the type represented by @var{rtd};
if the @var{field-names} argument is provided, it is an error if it
contains any duplicates or any symbols not in the default list.

@c In Kawa, @var{rtd} may be any @code{Class} that has a public default
@c constructor, as long as the @var{field-names} are public instance
@c fields.  (The fields should have type @code{Object} -- unless you
@c know what you are doing!)
@end defun

@defun record-predicate rtd
Returns a procedure for testing membership in the type represented by
@var{rtd}.  The returned procedure accepts exactly one argument and
returns a true value if the argument is a member of the indicated record
type; it returns a false value otherwise.

@c In Kawa, the returned procedure checks if the argument is an instance
@c of @var{rtd} or one of its sub-classes.
@end defun

@c @defun record-sub-predicate rtd
@c Returns a procedure for testing membership in the type represented by
@c @var{rtd} or its parents.  The returned procedure accepts exactly one
@c argument and returns a true value if the argument is a member of the
@c indicated record type or its parents; it returns a false value
@c otherwise.@refill
@c @end defun

@defun record-accessor rtd field-name
Returns a procedure for reading the value of a particular field of a
member of the type represented by @var{rtd}.  The returned procedure
accepts exactly one argument which must be a record of the appropriate
type; it returns the current value of the field named by the symbol
@var{field-name} in that record.  The symbol @var{field-name} must be a
member of the list of field-names in the call to @code{make-record-type}
that created the type represented by @var{rtd}.
@end defun

@defun record-modifier rtd field-name
Returns a procedure for writing the value of a particular field of a
member of the type represented by @var{rtd}.  The returned procedure
accepts exactly two arguments: first, a record of the appropriate type,
and second, an arbitrary Scheme value; it modifies the field named by
the symbol @var{field-name} in that record to contain the given value.
The returned value of the modifier procedure is unspecified.  The symbol
@var{field-name} must be a member of the list of field-names in the call
to @code{make-record-type} that created the type represented by @var{rtd}.
@end defun

@defun record? obj
Returns a true value if @var{obj} is a record of any type and a false
value otherwise.
@end defun

@defun record-type-descriptor record
Returns a record-type descriptor representing the type of the given
record.  That is, for example, if the returned descriptor were passed to
@code{record-predicate}, the resulting predicate would return a true
value when passed the given record.
@end defun

@defun record-type-name rtd
Returns the type-name associated with the type represented by rtd.  The
returned value is @code{eqv?} to the @var{type-name} argument given in
the call to @code{make-record-type} that created the type represented by
@var{rtd}.@refill
@end defun

@defun record-type-field-names rtd
Returns a list of the symbols naming the fields in members of the type
represented by @var{rtd}.  The returned value is @code{equal?} to the
field-names argument given in the call to @code{make-record-type} that
created the type represented by @var{rtd}.@refill
@end defun

@node Mangling, Allocating objects, Records, Objects and Classes
@section Mapping Scheme names to Java names

Programs use "names" to refer to various values and procedures.
The definition of what is a "name" is different in different
programming languages.  A name in Scheme (and other Lisp-like
languages) can be principle contain any character (if using a
suitable quoting convention), but typically names consist of
"words" (one or more letters) separated by hyphens, such
as @samp{make-temporary-file}.  Digits
and some special symbols are also used.  Standard Scheme
is case-insensitive;  this means that the names @samp{loop},
@samp{Loop}, and @samp{LOOP} are all the same name.  Kawa
is by default case-sensitive, but we recommend that you
avoid using upper-case letters as a general rule.

The Java language and the Java virtual machine uses names for
classes, variables, fields and methods.  These names can
contain upper- and lower-case letters, digits, and the special
symbols @samp{_} and @samp{$}.

Given a name in a Scheme program,
Kawa needs to map that name into a valid Java name.  A typical
Scheme name such as @samp{make-temporary-file} is not a valid
Java name.  The convention for Java names is to use
"mixed-case" words, such as @samp{makeTemporaryFile}.
So Kawa will translate a Scheme-style name into a Java-style
name.  The basic rule is simple:  Hyphens are dropped, and
a letter that follows a hyphen is translated to its
upper-case (actually "title-case") equivalent.  Otherwise,
letters are translated as is.

Some special characters are handled specially.  A final @samp{?}
is replaced by an @emph{initial} @samp{is}, with the following
letter converted to titlecase.  Thus @samp{number?} is
converted to @samp{isNumber} (which fits with Java conventions),
and @samp{file-exists?} is converted to @samp{isFileExists}
(which doesn't really).
The pair @samp{->} is translated to @samp{To}, and if followed
by a letter, that is is converted to titlecase.
For example @samp{list->string} is translated to @samp{listToString}.

Other special characters are translated in uglier ways,
using a mapping scheme that is likely to change in future versions.

Note that this mapping may map different Scheme names to the
same Java name.  For example @samp{string?}, @samp{String?},
@samp{is-string}, @samp{is-String},
and @samp{isString} are all mapped to the same Java identifier
@samp{isString}.  Code that uses such "Java-clashing" names
is @emph{not} supported.  There is very partial support for
renaming names in the case of a clash, and there may be better
support in the future.  However, some of the nice features of
Kawa depend on being able to map Scheme name to Java names
naturally, so we urge you to @emph{not} write code that
"mixes" naming conventions by using (say) the names @samp{open-file}
and @samp{openFile} to name two different objects.


@node Allocating objects, Method operations, Mangling, Objects and Classes
@section  Allocating objects

@defun make type args ...
Constructs a new object instance of the specified @var{type},
which must be either a @code{java.lang.Class} or a
@code{<gnu.bytecode.ClassType>}.

The @var{args ...} are passed to the constructor of the class type.
If there is no applicable constructor, and the @var{args ...}
consist of a set of (@var{keyword},@var{value})-pairs,
then the default constructor is called, and each
(@var{keyword},@var{value})-pair is used to set the correspdong slot
of the result, as if by:
@code{(slot-set! @var{result} @var{keyword} @var{value})}.

For example, the following are all equivalent:
@example
(set! p (make <java.awt.Point> 3 4))

(set! p (make <java.awt.Point> y: 4 x: 3))

(set! p (make <java.awt.Point>))
(slot-set! p 'x 3)
(set! (slot-ref p 'y) 4)
@end example

@end defun

@node Method operations, Field operations, Allocating objects, Objects and Classes
@section Calling Java methods from Scheme

Kawa has both a low-level and a high-level 
"Foreign Function Interface",
which allows you to call any (virtual or static) Java method
as if it were a Scheme procedure.

@defun invoke-static class name args ...
The @var{class} can be a @code{<java.lang.Class>}, a
@code{<gnu.bytecode.ClassType>}, or a @code{<symbol>} or @code{<string>}
that names a Java class.  The @var{name} can be @code{<symbol>} or
@code{<string>} that names one or more methods in the Java class.
The name is "mangled" (@pxref{Mangling}) into a valid Java name.

Any public methods (static or instance) in the specified @var{class} (or its
super-classes) that match "@var{name}" or "@var{name}$V" collectively form a
generic procedure.  When the procedure is applied to the argument list,
the most specific applicable method is chosen depending on the
argument list;  that method is then
called with the given arguments.  Iff the method is an instance method,
the first actual argument is used as the @code{this} argument.  If there are
no applicable methods (or no methods at all!), or there is no "best"
method, @code{WrongType} is thrown.

("@var{name}$V" is used for procedures with @code{#!rest} or keyword args;
the last argument must be an array type;  all the "extra" arguments
must be compatible with the type of the array elements.)

An example (derived from the Skij FAQ):
@example
(invoke-static <java.lang.Thread> 'sleep 100)
@end example

The behavior of interpreted code and compiled code is not
indentical, though you should get the same result either way
unless you have designed the classes rather strangely.  The
details will be nailed down later, but the basic idea is that
the compiler will "inline" the @code{invoke-static} call
if it can pick a single "best" matching method.
@end defun

@defun invoke object name args ...
The @var{name} can be @code{<symbol>} or
@code{<string>} that names one or more methods in the Java class.
The name is "mangled" (@pxref{Mangling}) into a valid Java name.

Any public methods (static or instance) in the specified @var{class} (or its
super-classes) that match "@var{name}" or "@var{name}$V" collectively form a
generic procedure.  When the procedure is applied to the argument list,
the most specific applicable method is chosen depending on the
argument list;  that method is then
called with the given arguments.  Iff the method is an instance method,
the @var{object} is used as the @code{this} argument;
otherwise @var{object} is prepended to the @var{args} list.  If there are
no applicable methods (or no methods at all!), or there is no "best"
method, @code{WrongType} is thrown.

("@var{name}$V" is used for procedures with @code{#!rest} or keyword args;
the last argument must be an array type;  all the "extra" arguments
must be compatible with the type of the array elements.)

The behavior of interpreted code and compiled code is not
indentical, though you should get the same result either way
unless you have designed the classes rather strangely.  The
details will be nailed down later, but the basic idea is that
the compiler will "inline" the @code{invoke-static} call
if it can pick a single "best" matching method.
@end defun

@defun class-methods class name
Return a generic function containing those methods of @var{class}
that match the name @var{name}, in the sense of @code{invoke-static}.
Same as:
@example
(lambda args (apply invoke-static (cons class (cons name args))))
@end example
@end defun

Some examples using these functions are @samp{vectors.scm}
and @samp{characters.scm} the directory @samp{kawa/lib} in
the Kawa sources.

@node Field operations, Anonymous classes, Method operations, Objects and Classes
@section Accessing fields of Java objects

Kawa has both a high-level interface and a low-level interface for accessing
the fields of Java objects and static fields.
The lower-level interfaces are macros that return functions.
These functions can be inlined, producing efficient code.
The higher-level functions are less verbose and more convenient.
However, they can only access public fields.

@defun field object fieldname
Get the instance field with the given @var{fieldname} from the given
@var{Object}.  Returns the value of the field, which must be public.
This procedure has a @code{setter}, and so can be used as the first
operand to @code{set!}.

The field name is "mangled" (@pxref{Mangling}) into a valid Java name.
If there is no accessible field whose name is @code{"@var{fieldname}"},
we look for a no-argument method whose name is @code{"get@var{Fieldname}"}.

@end defun

@defun static-field class fieldname
Get the static field with the given @var{fieldname} from the given
@var{class}.  Returns the value of the field, which must be public.
This procedure has a @code{setter}, and so can be used as the first
operand to @code{set!}.
@end defun

Examples:
@example
(static-field <java.lang.System> 'err)
;; Copy the car field of b into a.
(set! (field a 'car) (field b 'car))
@end example

@defun slot-ref object fieldname
A synonym for @code{(field @var{object} @var{fieldname})}.
@end defun

@defun slot-set! object fieldname value
A synonym for @code{(set! (field @var{object} @var{fieldname}) @var{value})}.
@end defun

@node Anonymous classes,  , Field operations, Objects and Classes
@section Anonymous classes

@deffn Syntax object (supers ...) field-or-method-decl ...
Returns a new instance of an anonymous (inner) class.
@display
@var{field-or-method} = @var{field-decl} | @var{method-decl}
@var{field-decl} = (@var{field-name} [[@var{field-type}] @var{field-init}])
@var{method-decl} = ((@var{method-name} @var{formal-arguments}) [@var{rtype}] @var{body})
@end display

Returns a new instance of a unique (anonymous) class.
The class inherits from the list of @var{supers}, where at most one of the
elements should be the base class being extended from, and the rest
are interfaces.

Each @var{field-decl} declares a public instance field.
If @var{field-type} is given, it specifies the type of the field.
If @var{field-init} is given, it is an expression whose value
becomes the initial value of the field.
The @var{field-init} is evaluated at the same time as the @code{object}
expression is evaluated,
in a scope where all the @var{field-name}s are visible.

Each @var{method-decl} declares a public non-static method,
whose name is @var{method-name}.  (If @var{method-name} is not a valid
Java method name, it is mapped to something reasonable.
For example @code{foo-bar?} is mapped to @code{isFooBar}.)
The types of the method arguments can be specified in the
@var{formal-arguments}.  The return type can be specified by @var{rtype},
or is otherwise the type of the @var{body}.
Currently, the @var{formal-arguments} cannot contain optional, rest,
or keyword parameters.  (The plan is to allow optional parameters,
implemented using multiple overloaded methods.)

The scope of the @var{body} of a method includes the @var{field-decl}s
of the object.  It does include the surrounding lexical scope.
It sort-of also includes the declared methods, but this is not working yet.
@end deffn

@node Low-level functions, Reporting Bugs, Objects and Classes, Top
@chapter The Scheme-Java interface

Kawa has extensive features so you can work with Java objects
and call Java methods.

@menu
* Scheme types in Java::
* Array operations::      Low-level operations on Java arrays
* Low-level Method invocation::
* Low-level Field operations::
* Loading a ModuleBody::
* Evaluating Scheme expressions from Java::
@end menu

@node Scheme types in Java, Array operations, Low-level functions, Low-level functions
@section Scheme types in Java

All Scheme values are implemented by sub-classes of @samp{java.lang.Object}.

Scheme symbols are implemented using @code{java.lang.String}.
(Don't be confused by the fact the Scheme sybols are represented
using Java Strings, while Scheme strings are represented by
@code{kawa.lang.Scheme}.  It is just that the semantics of Java strings
match Scheme symbols, but do not match mutable Scheme strings.)
Interned symbols are presented as interned Strings.
(Note that with JDK 1.1 string literals are automatically interned.)

Scheme integers are implemented by @code{kawa.math.IntNum}.
Use the make static function to create a new IntNum from an int or a long.
Use the intValue or longValue methods to get the int or long value of
an IntNum.

A Scheme "flonum" is implemented by @code{kawa.math.DFloNum}.

A Scheme pair is implemented by @code{kawa.lang.Pair}.

A Scheme vector is implemented by @code{kawa.lang.Vector}.

Scheme characters are implemented using @code{kawa.lang.Char}.

Scheme strings are implemented using @code{kawa.lang.FString}.

Scheme procedures are all sub-classes of @code{kawa.lang.Procedure}.
Normally each function (lambda expression) in the source code is
compiled to a separate sub-class of @samp{Procedure}.
The "action" of a @samp{Procedure} is invoked by using one of
the @samp{apply*} methods:  @samp{apply0}, @samp{apply1},
@samp{apply2}, @samp{apply3}, @samp{apply4}, or @samp{applyN}.
Various sub-class of @samp{Procedure} provide defaults
for the various @samp{apply*} methods.  For example,
a @samp{Procedure2} is used by 2-argument procedures.
The @samp{Procedure2} class provides implementations of all
the @samp{apply*} methods @emph{except} @samp{apply2},
which must be provided by any class that extends @code{Procedure2}.

@node Array operations, Low-level Method invocation, Scheme types in Java, Low-level functions
@section Low-level Operations on Java Arrays

The following macros evaluate to procedures that can be used to
manipulate primitive Java array objects.
The compiler can inline each to a single bytecode instruction
(not counting type conversion).

@deffn Syntax primitive-array-new element-type
Evaluates to a one-argument procedure.  Applying the resulting procedure to
an integer count allocates a new Java array of the specified length,
and whose elements have type @var{element-type}.
@end deffn

@deffn Syntax primitive-array-set element-type
Evaluates to a three-argument procedure.  The first argument of
the resulting procedure must be an array whose elements have type
@var{element-type};  the second argument is an index;  and the third
argument is a value (coercible to @var{element-type}) which replaces
the value specified by the index in the given array.
@end deffn

@deffn Syntax primitive-array-get element-type
Evaluates to a two-argument procedure.  The first argument of
the resulting procedure must be an array whose elements have type
@var{element-type};  the second argument is an index.
Applying the procedure returns the element at the specified index.
@end deffn

@deffn Syntax primitive-array-new element-type
Evaluates to a one-argument procedure.  The argument of
the resulting procedure must be an array whose elements have type
@var{element-type}.
Applying the procedure returns the length of the array.
@end deffn

@node Low-level Method invocation, Low-level Field operations, Array operations, Low-level functions
@section Low-level Method invocation

The following lower-level primitives require you to specify
the parameter and return types explicitly.
Type specifications are currently required to be string literals
or one of the standard types (@pxref{Standard Types}).

@deffn Syntax primitive-constructor class (argtype ...)
Returns a new anonymous procedure, which when called will create
a new object of the specified class, and will then call the
constructor matching the specified argument types.
@end deffn

@deffn Syntax primitive-virtual-method class method rtype (argtype ...)
Returns a new anonymous procedure, which when called will
invoke the instance method whose name is the string @var{method}
in the class whose name is @var{class}.
@end deffn

@deffn Syntax primitive-static-method class method rtype (argtype ...)
Returns a new anonymous procedure, which when called will
invoke the static method whose name is the string @var{method}
in the class whose name is @var{class}.
@end deffn

@deffn Syntax primitive-interface-method interface method rtype (argtype ...)
Returns a new anonymous procedure, which when called will
invoke the matching method from the interface whose name is @var{interface}.
@end deffn

The macros return procedure values, just like @code{lambda}.
If the macros are used directly as the procedure of a procedure call,
then kawa can inline the correct bytecodes to call the specified methods.
(Note also that neither macro
checks that there really is a method that matches the specification.)
Otherwise, the Java reflection facility is used.

@node Low-level Field operations, Loading a ModuleBody, Low-level Method invocation, Low-level functions
@section Low-level Operations on Object Fields

The following macros evaluate to procedures that can be used to
access or change the fields of objects or static fields.
The compiler can inline each to a single bytecode instruction
(not counting type conversion).

These macros are deprecated.
The @code{fields} and @code{static-field} functions
(@pxref{Field operations}) are easier to use, more powerful, and
just as efficient.  (One exception is for @code{primitive-set-static};
while its functionality can be expressed using
@code{(set! (static-field ...) ...)}, that idiom is currently
less efficient.)  Also, the high-level functions currently do
not provide access to private fields.

@deffn Syntax primitive-get-field class fname ftype
Use this to access a field named @var{fname} having type @var{type} in
class @var{class}.  Evaluates to a new one-argument procedure,
whose argument is a reference to an object of the specified @var{class}.
Calling that procedure returns the value of the specified field.
@end deffn

@deffn Syntax primitive-set-field class fname ftype
Use this to change a field named @var{fname} having type @var{type} in
class @var{class}.  Evaluates to a new two-argument procedure,
whose first argument is a reference to an object of the
specified @var{class}, and the second argument is the new value.
Calling that procedure sets the field to the specified value.
(This macro's name does not end in a @samp{!}, because it does not actually
set the field.  Rather, it returns a function for setting the field.)
@end deffn

@deffn Syntax primitive-get-static class fname ftype
Like @code{primitive-get-field}, but used to access static fields.
Returns a zero-argument function, which when called returns
the value of the static field.
@end deffn

@deffn Syntax primitive-set-static class fname ftype
Like @code{primitive-set-field}, but used to modify static fields.
Returns a one-argument function, which when called sets the
value of the static field to the argument.
@end deffn

@node Loading a ModuleBody, Evaluating Scheme expressions from Java, Low-level Field operations, Low-level functions
@section Loading a ModuleBody

The "top" class created by @code{kawa -C} (@pxref{Files compilation})
extends the @code{ModuleBody} class.  It is actually fairly
easy to write a @code{ModuleBody} by hand in Java, and you can
then use the Scheme @code{load} procedure to cause arbitrary
actions.  Here is an example.
@emph{(Note that the details are subject to change!)}

@example
package MyDev;
import kawa.lang.*;
class MyDevFunc extends Procedure2
@{
  public Object apply2 (Object arg1, Object arg2)
  @{
    ... stuff to control my device ...;
  @}
@}

public class MyDevice extends ModuleBody
@{
  public Object run (Environment env)
    throws WrongArguments, WrongType, GenericError, UnboundSymbol
  @{
    ... initialize my device here ...;

    // Declare (handle-my-device x y) to call MyDevFunc.apply2 (x, y):
    env.define ("handle-my-device", new MyDevFunc ());

    // Return the void value (i.e. no value).
    return Interpreter.voidObject;
  @}
@}
@end example

If this text is in the file @code{MyDev/MyDevice.java}, and you compile
it with @code{javac}, you will get @code{MyDev/MyDevice.class}
and @code{MyDev/MyDevFunc.class}.  Assuming the current directory
is in your @code{CLASSPATH}, you can now do the following in Kawa:
@example
(load "MyDev/MyDevice.class")
@end example
or:
@example
(load "MyDev.MyDevice")
@end example

This will cause the actions in @code{MyDevice.run} to be executed.
The current environment is passed in as the parameter @code{env}.
One of those actions is to define the procedure @code{handle-my-device}.

@node Evaluating Scheme expressions from Java,  , Loading a ModuleBody, Low-level functions
@section Evaluating Scheme expressions from Java

The following methods are recommended if you need to evaluate a
Scheme expression from a Java method.
(Some details (such as the @samp{throws} lists) may change.)

@deftypefn {Static method} Object Scheme.eval (InPort @var{port}, Environment @var{env})
Read expressions from @var{port}, and evaluate them in the
@var{env} environment, until end-of-file is reached.
Return the value of the last expression,
or @code{Interpreter.voidObject} if there is no expression.
@end deftypefn

@deftypefn {Static method} Object Scheme.eval (String @var{string}, Environment @var{env})
Read expressions from @var{string}, and evaluate them in the
@var{env} environment, until the end of the string is reached.
Return the value of the last expression,
or @code{Interpreter.voidObject} if there is no expression.
@end deftypefn

@deftypefn {Static method} Object Scheme.eval (Object @var{sexpr}, Environment @var{env})
The @var{sexpr} is an S-expression (as may be returned by @code{read}).
Evaluate it in the @var{env} environment, and return the result.
@end deftypefn

For the @code{Environment} in most cases you could use
@samp{Environment.current()}.  Before you start, you
need to initialize the global environment,
which you can with
@example
Environment.setCurrent(new Scheme().getEnvironment());
@end example

Alternatively, rather than setting the global environment,
you can use this style:
@example
Scheme scm = new Scheme();
Object x = scm.eval("(+ 3 2)");
System.out.println(x);
@end example

@node Reporting Bugs, License, Low-level functions, Top
@chapter Reporting Bugs and the Kawa Mailing List

If you have a problem installing or using Kawa,
send mail to @code{kawa@@sourceware.cygnus.com}

This mailing list is used for reporting bugs, patches, discussing
changes to Kawa, and announcing snapshots.  If you wish to subscribe,
send a blank message request to @code{kawa-subscribe@@sourceware.cygnus.com}.
To unsubscribe, send a blank message to
@code{kawa-unsubscribe@@sourcware.cygnus.com}.  (If your mail is forwarded,
send mail to the address following @code{mailto:} in the
@code{List-Unsubscribe} line in the messages you get form the list.)

Messages to the mailing list are now
@uref{http://sourceware.cygnus.com/ml/kawa/, archived}.

@node License, Index, Reporting Bugs, Top
@chapter License

@section License for the Kawa software

The license for Kawa and the packages it depends on
is a "modified Gnu Public License".  You can find it in
the file @code{COPYING} in the Kawa sources, and
also quoted here:.

@example
The Java classes (with related files and documentation) in these packages
are copyright (C) 1996, 1997, 1998, 1999  Per Bothner.

These classes are distributed in the hope that they will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

These classes are free software.  You can use and re-distribute a class
without restriction (in source or binary form) as long as you use a
version has not been modified in any way from a version released
by Per Bothner, Cygnus Solutions, or the Free Software Foundation.
You may make and distribute a modified version, provided you follow
the terms of the GNU General Public License; either version 2,
or (at your option) any later version.
@end example

The file @code{COPYING} also contains a copy of the
GNU General Public License version 2.

People have asked what the Kawa license means in practice.
Informally, you get to pick between these choices:
@enumerate
@item
Use Kawa as distributed by Per Bothner (or his approved agents),
with no modifications.  In that case, you can use Kawa for any
purpose you like, and distribute your application with any license
you like.  (This basically gives you the same rights as
a typical commercial royalty-free re-distribution license.)
@item
Obey the terms of the standard Gnu Public License.  (See
@uref{http://www.gnu.org/copyleft/gpl.html}).  Informally, this means
that if you distribute any application that is based on Kawa, you must
also make available to all your recipients (customers) the source code
for your entire application, giving them the modification and
re-distribution rights they have under the GPL.  In a Java context, I take
"entire application" to mean all classes (and native code) that run in
the same Java virtual machine, except for the Java runtime system itself
(the virtual machine, low-level run-time system, and any classes in
a @code{java} or @code{javax} package).
@item
If you need to make a change to Kawa, you can submit them to Per Bothner,
and convince him to include them in future Kawa releases.
@item
You can negotiate some other (commercial) license with Per Bothner.
@end enumerate

In general, If the license of Kawa or asociated packages causes
difficulties, let me know.

@section Copyright for this manual

Here is the license for this manual:

Copyright @copyright{} 1996, 1997, 1998, 1999 Per Bothner
@*Parts of this manual were derived from the SLIB manual,
copyright @copyright{} 1993-1998 Todd R. Eigenschink and Aubrey Jaffer.
@*Parts of this manual were derived from ISO/EIC 10179:1996(E)
(Document Style and Specifical Language) - unknown copyright.

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation approved
by the author.

This manual has quoted from SRFI-6,
which is Copyright (C) William D Clinger (1999). All Rights Reserved.

The following notice applies to SRFI-6, which is quoted in this
manual, but it does not apply to the manual as a whole:

@quotation
This document and translations of it may be copied and furnished to
others, and derivative works that comment on or otherwise explain it or
assist in its implementation may be prepared, copied, published and
distributed, in whole or in part, without restriction of any kind,
provided that the above copyright notice and this paragraph are included
on all such copies and derivative works. However, this document itself
may not be modified in any way, such as by removing the copyright notice
or references to the Scheme Request For Implementation process or
editors, except as needed for the purpose of developing SRFIs in which
case the procedures for copyrights defined in the SRFI process must be
followed, or as required to translate it into languages other than
English.
@end quotation

@node Index,  , License, Top
@unnumbered Index
@printindex cp

@bye
