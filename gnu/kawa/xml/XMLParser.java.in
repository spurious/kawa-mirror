/* -*-Java-*- */
// Copyright (c) 2001  Per M.A. Bothner and Brainfood Inc.
// This is free software;  for terms and warranty disclaimer see ./COPYING.
package gnu.kawa.xml;
import java.io.*;
import java.net.*;

/** Reads XML from a @CHAR@ array.
 * Assumes a state-less character encoding containing ascii as a sub-set,
 * and where no byte in a multi-byte character is the same as a xml special
 * character.  Any bytes with high-order bit set are treated as if they
 * are letters, and can be part of names.
 *
 * Handles CR/LF, CDATA, entity references, processing instructions, DOCTYPE,
 * as well as the obvious (text, element, and attributes).
 *
 * @author Per Bothner
 */

public class @XMLParser@
{
  @CHAR@[] buffer;
  int pos;
  int limit;

  @ParsedXMLHandler@ out;

  private static final int EXPECT_NAME_MODIFIER = 1;
  private static final int SKIP_SPACES_MODIFIER = 2;
  private static final int INIT_STATE = 0;
  private static final int TEXT_STATE = 1;
  private static final int BEGIN_ELEMENT_STATE = 2;
  private static final int END_ELEMENT_STATE = 4;
  private static final int SAW_ENTITY_REF = 6;  // Saw '&'.  
  private static final int ATTRIBUTE_SEEN_NAME_STATE = 8;
  private static final int MAYBE_ATTRIBUTE_STATE = 10;
  private static final int ATTRIBUTE_SEEN_EQ_STATE = 11;
  private static final int DOCTYPE_SEEN_STATE = 13;
  private static final int EXPECT_RIGHT_STATE = 15;
  private static final int SAW_LEFT_STATE = 18;
  private static final int SAW_LEFT_SLASH_STATE = 19; // Seen '</'
  private static final int SAW_LEFT_EXCL_STATE = 20;
  private static final int SAW_LEFT_QUEST_STATE = 21; // Seen '<?'
  private static final int SAW_LEFT_EXCL_MINUS_STATE = 22;
  private static final int SAW_AMP_STATE = 25;  // Saw '&'.  
  private static final int SAW_AMP_SHARP_STATE = 26;  // Saw '&#'.  
  private static final int SAW_ERROR = 27;
  private static final int SAW_EOF_ERROR = 28;  // Unexpected end-of-file.

  public void parse()
  {
    // Cache fields in local variables, for speed.
    @CHAR@[] buffer = this.buffer;
    int pos = this.pos;
    int limit = this.limit;
    @ParsedXMLHandler@ out = this.out;
    
    // The flow logic of this method is unusual.  It is one big state machine,
    // but with two "subroutines": SKIP_SPACES_MODIFIER and EXPECT_NAME_MODIFIER.
    // There is also a "subroutine" to get a new character (and leave it in 'ch')
    // when 'break handleChar' is executed, except this has the hard-wired
    // continuation of switching on the 'state'.
    //
    // The justification for this rather usual design is performance.
    // As long as the input is contained within 'buffer', we don't need
    // to call input methods (only methods for emitting parsed data is
    // called).  We also maximize use of local variables - we do not
    // access any object fields (including fields of 'this') except
    // for getting the next char from 'buffer'.  These properties mean
    // this method can be compiled to very tight efficient code.

    int state = INIT_STATE;
    // 0: normal - in character context.
    // 1: seen '&'

    // The next two varibles are only relevant if state==INIT_STATE:
    @CHAR@ terminator = (@CHAR@) '<';
    int continue_state = SAW_LEFT_STATE;
    @CHAR@ ch = (@CHAR@) ' '; // ???
    int length = 0;
    String message = null;

    int start = pos;
  mainLoop: //
    for (;;)
      {
        //System.err.println("state:"+state+" ch:"+(char)ch);
        handleChar:  // When done get next character.
        switch (state)
          {
          case INIT_STATE:
            state = TEXT_STATE;
            break handleChar;

          case SAW_ERROR:
            this.pos = pos;
            error(message);
            for (;;)
              {
                if (pos >= limit)
                  break mainLoop;
                ch = buffer[pos++];
                if (ch == '>')
                  {
                    state = TEXT_STATE;
                    break handleChar;
                  }
              }

          case SAW_EOF_ERROR:
            this.pos = pos;
            error("unexpected end-of-file");
            return;

          case TEXT_STATE:
            // This state handle text not inside tags (in which case
            // terminator=='<').  It also handles attribute values (in
            // which case terminator is '\'' or '"').
            length = 0;
            start = pos - 1;
            for (;;)
              {
                if (ch == terminator)
                  {
                    state = continue_state;
                    length = -1;
                    break;
                  }
                if (ch == '&')
                  {
                    state = SAW_AMP_STATE;
                    length = -1;
                    break;
                  }
                if (pos == limit)
                  {
                    break;
                  }
                ch = buffer[pos++];
              }
            length = pos - start + length;
            if (length > 0)
              out.emitCharacters(buffer, start, length);
            break handleChar;

          case SKIP_SPACES_MODIFIER + EXPECT_RIGHT_STATE:
          case SKIP_SPACES_MODIFIER + MAYBE_ATTRIBUTE_STATE:
          case SKIP_SPACES_MODIFIER + SAW_LEFT_QUEST_STATE:
          case SKIP_SPACES_MODIFIER + EXPECT_NAME_MODIFIER + DOCTYPE_SEEN_STATE:
            // "Subroutine" for skipping whitespace.
            if (ch == ' ' || ch == '\t'|| ch == '\n' || ch == '\r')
              break handleChar;
            // Not a space, so "return" to next state.
            state -= SKIP_SPACES_MODIFIER;
            continue mainLoop;

          case EXPECT_NAME_MODIFIER + BEGIN_ELEMENT_STATE:
          case EXPECT_NAME_MODIFIER + END_ELEMENT_STATE:
          case EXPECT_NAME_MODIFIER + ATTRIBUTE_SEEN_NAME_STATE:
          case EXPECT_NAME_MODIFIER + SAW_ENTITY_REF:
          case EXPECT_NAME_MODIFIER + DOCTYPE_SEEN_STATE:
          case EXPECT_NAME_MODIFIER + SKIP_SPACES_MODIFIER + SAW_LEFT_QUEST_STATE:
            // "Subroutine" for reading a Name.
            if (! (ch >= 'a' && ch <= 'z') && ! (ch >= 'A' && ch <= 'Z')
                && ch != '_' && ch != ':'
                && ch >= 0)
              {
                message = "missing name";
                state = SAW_ERROR;
                continue mainLoop;
              }
            length = 1;
            start = pos - 1;
            for (;;)
              {
                if (pos >= limit)
                  {
                    pos = start;
                    state = SAW_EOF_ERROR;
                    continue mainLoop;
                  }
                ch = buffer[pos++];
                if ((ch >= 'a' && ch <= 'z')
                    || (ch >= 'A' && ch <= 'Z')
                    || (ch >= '0' && ch <= '9')
                    || ch == '.' || ch == '-' || ch == '_' || ch == ':'
                    || ch < 0)
                  {
                    length++;
                  }
                else
                  {
                    state -= EXPECT_NAME_MODIFIER;
                    continue mainLoop;
                  }
              }
          case SAW_AMP_SHARP_STATE:
            int value = 0;
            int base;
            if (ch == 'x' && pos < limit)
              {
                ch = buffer[pos++];
                base = 16;
              }
            else
              base = 10;
            length = 0;
            for (;;)
              {
                if (ch == ';')
                  break;
                int digit = Character.digit((char) ch, base);
                if (digit < 0 || pos == limit)
                  {
                    length = 0;
                    break;
                  }
                value = base * value + digit;
                length++;
                ch = buffer[pos++];
              }
            if (length == 0)
              {
                message = "Invalid character reference";
                state = SAW_ERROR;
                continue mainLoop;
              }
            if (base == 16)
              length++;
            out.emitCharacterReference(value, buffer, pos - 1 - length, length);
            state = TEXT_STATE;
            break handleChar;

          case SAW_AMP_STATE:
            if (ch == '#')
              {
                state = SAW_AMP_SHARP_STATE;
                break handleChar;
              }
            state = EXPECT_NAME_MODIFIER + SAW_ENTITY_REF;
            continue mainLoop;

          case SAW_ENTITY_REF:
            if (ch != ';')
              {
                this.pos = pos;
                error("missing ';'");
              }
            out.emitEntityReference(buffer, start, length);
            state = TEXT_STATE;
            break handleChar;

          case SAW_LEFT_STATE: // Saw '<'
            if (ch == '/')
              {
                state = SAW_LEFT_SLASH_STATE;
                break handleChar;
              }
            if (ch == '?')
              {
                state = EXPECT_NAME_MODIFIER + SKIP_SPACES_MODIFIER + SAW_LEFT_QUEST_STATE;
                break handleChar;
              }
            if (ch == '!')
              {
                state = SAW_LEFT_EXCL_STATE;
                break handleChar;
              }
            // Read Name then goto BEGIN_ELEMENT_STATE.
            state = EXPECT_NAME_MODIFIER + BEGIN_ELEMENT_STATE;
            continue mainLoop;
          case BEGIN_ELEMENT_STATE:
            out.emitBeginElement(buffer, start, length);
            state = SKIP_SPACES_MODIFIER + MAYBE_ATTRIBUTE_STATE;
            continue mainLoop;

          case SAW_LEFT_QUEST_STATE: // Seen '<?' Name.
            for (int dstart = pos - 1;;)
              {
                if (pos + 2 >= limit)
                  {
                    pos = dstart;
                    state = SAW_EOF_ERROR;
                    continue mainLoop;
                  }
                ch = buffer[pos++];
                if (ch != '?')
                  continue;
                ch = buffer[pos++];
                if (ch != '>')
                  continue;
                out.emitProcessingInstruction(buffer, start, length,
                                              dstart, pos - 2 - dstart);
                state = TEXT_STATE;
                break handleChar;
              }

          case SAW_LEFT_EXCL_STATE: // Seen '<!'
            if (ch == '-' && pos < limit && buffer[pos++] == '-')
              {
                // Handle comment.
                start = pos - 4;
                for (;;)
                  {
                    if (pos + 3 >= limit)
                      {
                        pos = start;
                        state = SAW_EOF_ERROR;
                        continue mainLoop;
                      }
                    ch = buffer[pos++];
                    if (ch != '-')
                      continue;
                    ch = buffer[pos++];
                    if (ch != '-')
                      continue;
                    ch = buffer[pos++];
                    if (ch != '>')
                      continue;
                    out.emitComment(buffer, start, pos-start);
                    state = TEXT_STATE;
                    break handleChar;
                  }
              }

            if (ch == '[' && pos + 5 < limit
                && buffer[pos] == 'C'
                && buffer[pos+1] == 'D'
                && buffer[pos+2] == 'A'
                && buffer[pos+3] == 'T'
                && buffer[pos+4] == 'A'
                && buffer[pos+5] == '[')
              {
                pos += 6;
                start = pos;
                for (;;)
                  {
                    if (pos + 3 >= limit)
                      {
                        pos = start;
                        state = SAW_EOF_ERROR;
                        continue mainLoop;
                      }
                    ch = buffer[pos++];
                    if (ch != ']')
                      continue;
                    ch = buffer[pos++];
                    if (ch != ']')
                      continue;
                    ch = buffer[pos++];
                    if (ch != '>')
                      continue;
                    out.emitCharacters(buffer, start, pos - 3 - start);
                    state = TEXT_STATE;
                    break handleChar;
                  }
              }
            if (pos + 8 < limit
                && ch == 'D'
                && buffer[pos] == 'O'
                && buffer[pos+1] == 'C'
                && buffer[pos+2] == 'T'
                && buffer[pos+3] == 'Y'
                && buffer[pos+4] == 'P'
                && buffer[pos+5] == 'E')
              {
                pos = pos + 6;
                state = EXPECT_NAME_MODIFIER + SKIP_SPACES_MODIFIER + DOCTYPE_SEEN_STATE;
                break handleChar;
              }
            message = "unexpected or unimplemented text after '<!'";
            state = SAW_ERROR;
            continue mainLoop;

          case DOCTYPE_SEEN_STATE:
            terminator = 0;
            for (int dstart = pos - 1;;)
              {
                if (pos >= limit)
                  {
                    pos = dstart;
                    state = SAW_EOF_ERROR;
                    continue mainLoop;
                  }
                ch = buffer[pos++];
                if (ch == '\'' || ch == '\"')
                  {
                    if (terminator == 0)
                      terminator = ch;
                    else if (terminator == ch)
                      terminator = 0;
                  }
                if (ch == '>' && terminator == 0)
                  {
                    out.emitDoctypeDecl(buffer, start, length,
                                        dstart, pos - 1 - dstart);
                    terminator = (@CHAR@) '<';
                    state = TEXT_STATE;
                    break handleChar;
                  }
              }

          case MAYBE_ATTRIBUTE_STATE:
            terminator = (@CHAR@) '<';
            continue_state = SAW_LEFT_STATE;
            if (ch == '/')
              {
                out.emitEndAttributes();
                out.emitEndElement(null, 0, 0);
                state = EXPECT_RIGHT_STATE;
                break handleChar;
              }
            if (ch == '>')
              {
                out.emitEndAttributes();
                state = TEXT_STATE;
                break handleChar;
              }
            state = EXPECT_NAME_MODIFIER + ATTRIBUTE_SEEN_NAME_STATE;
            continue mainLoop;
          case ATTRIBUTE_SEEN_NAME_STATE:
            out.emitBeginAttribute(buffer, start, length);
            if (ch == '=')
              {
                state = ATTRIBUTE_SEEN_EQ_STATE;
                break handleChar;
              }
            if (ch == ' ' || ch == '\t' || ch == '\r' || ch == '\n')
              break handleChar;
            message = "missing or misplaced '=' after attribute name";
            state = SAW_ERROR;
            continue mainLoop;
          case ATTRIBUTE_SEEN_EQ_STATE:
            if (ch == '\'' || ch == '\"')
              {
                terminator = ch;
                continue_state = SKIP_SPACES_MODIFIER + MAYBE_ATTRIBUTE_STATE;
                state = TEXT_STATE;
                break handleChar;
              }
            if (ch == ' ' || ch == '\t' || ch == '\r' || ch == '\n')
              break handleChar;
            message = "missing or unquoted attribute value";
            state = SAW_ERROR;
            continue mainLoop;

          case SAW_LEFT_SLASH_STATE: // Seen '</'.
            // Do "Name" subroutine, then goto END_ELEMENT_STATE.
            state = EXPECT_NAME_MODIFIER + END_ELEMENT_STATE;
            continue mainLoop;

          case END_ELEMENT_STATE:  // Seen '</' Name.
            out.emitEndElement(buffer, start, length);
            // Skip spaces then goto EXPECT_RIGHT_STATE.
            state = SKIP_SPACES_MODIFIER + EXPECT_RIGHT_STATE;
            continue mainLoop;
          
          case EXPECT_RIGHT_STATE: // Looking for '>'.
            if (ch != '>')
              {
                message = "missing '>'";
                state = SAW_ERROR;
                continue mainLoop;
              }
            state = TEXT_STATE;
            break handleChar;
          }

        // After 'break handleChar', we get here.
        if (pos < limit)
          ch = buffer[pos++];
        else
          {
            if (state == TEXT_STATE)
              return;
            state = SAW_EOF_ERROR;
          }
      }
  }

  public @XMLParser@(URL url, @ParsedXMLHandler@ out)  throws IOException
  {
    URLConnection conn = url.openConnection();
    int length = conn.getContentLength();
    InputStream in = conn.getInputStream();
@if CHAR is byte@
    if (length < 0)
      throw new IOException("-1 length - not found?");
    buffer = new byte[length];
    for (int done = 0;  done < length; )
      done += in.read(buffer, done, length - done);
    in.close();
@endif CHAR is byte@
@if CHAR is char@
    InputStreamReader reader = new InputStreamReader(in);
    int size = length + 1024;
    buffer = new char[size];
    length = 0;
    for (;;)
      {
	int avail = buffer.length - length;
	if (avail == 0)
	  {
	    char[] tmp = new char[2 * length];
	    System.arraycopy(buffer, 0, tmp, 0, length);
	    buffer = tmp;
	  }
	int count = reader.read(buffer, length, avail);
	if (count <= 0)
	  break;
	length += count;
      }
    reader.close();
@endif CHAR is char@
    pos = 0;
    limit = length;

    this.out = out;
  }

  public void error(String message)
  {
    out.error(this, message);
  }
}
