/* -*-Java-*- */
// Copyright (c) 2001  Per M.A. Bothner and Brainfood Inc.
// This is free software;  for terms and warranty disclaimer see ./COPYING.

package gnu.xml;

/** Handle the output from XMLParser, or other @CHAR@-array-oriented XML source. */

public class @ParsedXMLHandler@
{
  /** Process raw text. */
  public void emitCharacters(@CHAR@[] text, int start, int length)
  {
  }

  /** Process a start tag, with the given element name. */
  public void emitBeginElement(@CHAR@[] name, int start, int length)
  {
  }

  /** Process an attribute, with the given attribute name.
   * The attribute value is given using emitCharacters.
   * The value is terminated by either another emitBeginAttribute
   * or an emitEndAttributes.
   */
  public void emitBeginAttribute(@CHAR@[] name, int start, int length)
  {
  }

  /** Process the end of a start tag.
   * There are no more attributes. */
  public void emitEndAttributes()
  {
  }

  /** Process an end tag.
   * An abbrevated tag (such as '<br/>') has a name==null.
   */
  public void emitEndElement(@CHAR@[] name, int start, int length)
  {
  }

  /** Process an entity reference.
   * The entity name is given. */
  public void emitEntityReference(@CHAR@[] name, int start, int length)
  {
  }

  /** Process a character entity reference.
   * The string encoding of the character (e.g. "xFF" or "255") is given,
   * as well as the character value. */
  public void emitCharacterReference(int value, @CHAR@[] name, int start, int length)
  {
  }

  /** Process a comment.
   * The data (starting at start for length @CHAR@s).
   * Does not include the delimiters (i.e. "<!--" and "-->" are excluded). */
  public void emitComment(@CHAR@[] data, int start, int length)
  {
  }

  /** Process a processing incluction. */
  public void emitProcessingInstruction(@CHAR@[] buffer,
                                        int target, int tlength,
                                        int data, int dlength)
  {
  }

  /** Process a DOCTYPE declaration. */
  public void emitDoctypeDecl(@CHAR@[] buffer,
                              int target, int tlength,
                              int data, int dlength)
  {
  }

  public void error(@XMLParser@ parser, String message)
  {
    StringBuffer sbuf = new StringBuffer();
    error(parser, message, sbuf);
    System.err.println(sbuf);
  }

  public static void error(@XMLParser@ parser, String message, StringBuffer sbuf)
  {
    /*
    String name = port.getName();
    if (name != null)
      sbuf.append(name);
    */
    int line = 1;
    int lstart = 0;
    int i = 0;
    int pos = parser.pos;
    @CHAR@[] buffer = parser.buffer;
    while (i < pos)
      {
        @CHAR@ ch = buffer[i++];
        if (ch == '\n')
          {
            line++;
            lstart = i;
          }
        else if (ch == '\r')
          {
            if (i < pos && buffer[i] == '\n')
              i++;
            line++;
            lstart = i;
          }
      }
    sbuf.append(':');
    sbuf.append(line);
    int column = pos - lstart;
    sbuf.append(':');
    sbuf.append(column + 1);
    sbuf.append(": ");

    sbuf.append("xml parse error");
    if (message != null)
      {
        sbuf.append(" - ");
        sbuf.append(message);
      }
  }
}
