\input texinfo.tex      @c -*-texinfo-*-
@c %**start of header
@setfilename kawa.info
@settitle Kawa, the Java-based Scheme system
@setchapternewpage off
@c version: %W% %G%
@c %**end of header

@include version.texi

@iftex
@finalout
@end iftex
@titlepage
@title Kawa, the Java-based Scheme system
@subtitle September, 1996
@sp 1
@author Per Bothner
@page
@end titlepage

@ifinfo
@format
START-INFO-DIR-ENTRY
* kawa: (kawa).         Kawa, the Java-based Scheme system
END-INFO-DIR-ENTRY
@end format
@menu
* Features::                    
* Installation::                
* Running::                     
* Restrictions::                
* Extensions::                  
* Compiling::                   
* Primitive functions::         
* Reporting Bugs::              
* License::                     
@end menu

@node Top, Features, (dir), (dir)
@top
@unnumbered The Kawa Scheme system, by Per Bothner
@end ifinfo

Kawa is a Scheme environment, written in java,
and that compiles Scheme code into Java byte-codes.

This documents version @value{VERSION}, updated @value{UPDATED}.

R. Alexander Milowski @w{<alex@@copsol.com>} wrote the first Kawa releases.
Per Bothner @w{<bothner@@cygnus.com>} extensively re-wrote Kawa,
and released version 0.3 and up.

@menu
* Features::
* Installation::         Building and installing Kawa
* Running::              How to start up and run Kawa
* Restrictions::         Features of R4RS not implemented
* Extensions::
* Compiling::            Compiling Scheme code to byte-codes
* Primitive functions::  Writing new "primitive" Scheme functions in Java
* Reporting Bugs::
* License::              
@end menu

@node Features, Installation, Top, Top
@section Features

Kawa is a full Scheme implementation.  It implements almost
all of R4RS (for exceptions @pxref{Restrictions}), plus some extensions.
It provide @code{define-syntax} from the R4RS appendex,
and multiple values (from the draft R5RS).

It is completely written in Java.  Scheme functions and files
are automatically compiled into Java byte-codes, providing
reasonable speed.  (However, Kawa is not an optimizing compiler,
and does not perform major transformations on the code.)

Kawa provides the usual read-eval-print loop, as well as batch modes.

Kawa is written in an object-oriented style.

@node Installation, Running, Features, Top
@section Building and installing Kawa

Before installing Kawa, you must have Java working on your
system.

You can compile Kawa from the source distribution.
Alternatively, you can install the pre-compiled binary distribution.

@menu
* Running Java::                Getting and running Java
* Binary distribution::         Installing and using the binary distribution
* Source distribution::         Installing and using the source distribution
@end menu

@node Running Java, Binary distribution, Installation, Installation
@subsection Getting and running Java

You will need a working Java system.
The discussion below assumes you are using the Java Developer's Kit
(JDK) JDK 1.0.x from JavaSoft (Sun).
You can download free copies of JDK 1.0.2 for Sparc/Solaris,
x86/Solaris, MS-Windows 95/NT, and MacOS;
see @samp{http://java.sun.com:80/java.sun.com/products/JDK/1.0.2/index.html}.

The program 'java' is the Java interpreter.
The program 'javac' is the Java compiler,
and is needed if you want to compile the source release yourself.
Both programs must both be in your @code{PATH}.

You also need to set @code{CLASSPATH} so it includes both the
current directory, and the standard Java library.
After you have installed Kawa, the @code{CLASSPATH} needs to
include wherever you installed Kawa.

If you have the JDK in directory @code{$JDK},
and you are using a Bourne-shell compatible shell
(/bin/sh, ksh, bash, or other) you can set both variables thus:
@example
PATH=$JDK/bin:$PATH
CLASSPATH=.:$JDK/lib/classes.zip
export PATH CLASSPATH
@end example

@node Binary distribution, Source distribution, Running Java, Installation
@subsection Installing and using the binary distribution

The binary release includes only the binary compiled @samp{.class}
versions of the same @samp{.java} source files in the source release.
It does not include any documentation, so you probably want the
source release in addition to the binary release.  The purpose
of the binary release is just to save you time and trouble
compiling the sources.

The binary release comes as a gzip-compressed tar file named
@samp{kawa-@value{VERSION}-compiled.tar.gz}.

You need to decide where you want to put the Kawa @samp{.class} files.
Assuming it is @samp{/usr/local/java} (the default), you can do:
@example
gunzip -c <kawa-@value{VERSION}-compiled.tar.gz|(cd /usr/local/java; tar xf -)
@end example

Then, before you can actually run Kawa, you need to set @code{CLASSPATH}
so it includes the Kawa files.  For example:
@example
export CLASSPATH=.:/usr/local/java:$JDK/lib/classes.zip
@end example

Then to run Kawa do:
@example
java kawa
@end example

@node Source distribution,  , Binary distribution, Installation
@subsection Installing and using the source distribution
The Kawa release normally comes as a gzip-compressed tar file named
@samp{kawa-@value{VERSION}.tar.gz}.

In your build directory do:
@example
tar xzf kawa-@value{VERSION}.tar.gz
cd kawa-@value{VERSION}
@end example

Then you must configure the sources.  This you can do
the same way you configure most other GNU software.  Normally
you can just run the configure script with no arguments:

@example
./configure
@end example

This will specify that a later @code{make install} will install the
compiled @samp{.class} files into @code{/usr/local/java}.  If you want them
to be installed someplace else, such as @code{$PREFIX/java}, then
specify that when you run configure:
@example
./configure -- prefix $PREFIX
@end example

Thus you need to compile all the .java source files.
Just run make:
@example
make
@end example

You can now test the system by running Kawa in place:
@example
java kawa
@end example

or you can install the compiled files:
@example
make install
@end example

This will install your classes into @code{$PREFIX/java} (and its
sub-directories).  Here @code{$PREFIX} is the directory you specified
to configure with the @code{--prefix} option, or @code{/usr/local} if you
did not specify a @code{--prefix} option.

To use the installed files, you need to set @code{CLASSPATH} so
that @code{$PREFIX/java} is on the path:
@example
export CLASSPATH=.:$PREFIX/java:$JDK/lib/classes.zip
@end example

@node Running, Restrictions, Installation, Top
@section How to start up and run Kawa

To run Kawa, you must start a Java interpreter.
This depends on the Java interpreter.
For JavaSoft's JDK, you must have the Java interpreter
in your @code{PATH}.
You must also make sure that the @code{kawa.class} file,
the rest of the Kawa packages, and the standard Java
packages can be found by searching CLASSPATH.
@xref{Running Java}.

Then you do:
@example
java kawa
@end example

You will then get the @samp{kawa>} prompt, which means you are
in the Kawa read-eval-print-loop.  If you type a Scheme
expression, Kawa will evaluate it.  Kawa will then print the
result (if there is a non-"void" result).

To exit Kawa, type the end-of-file character (normally ctrl/D),
or call the @code{exit} procedure (with 0 or 1 integer arguments).

You can pass various flags to Kawa, for example:
@example
java kawa -e '(display (+ 12 4))(newline)'
@end example
This causes Kawa to print @samp{16}, and then exit.

@table @samp
@item -c @var{expr}
Kawa evaluates @var{expr}, which contains one or more Scheme expressions.
@item -e @var{expr}
Same as @samp{-c @var{expr}}.
@item -f @var{filename}
Kawa reads and evaluates expressions from the file named by @var{filename}.
If @var{filename} is @samp{-}, standard input is read (with no prompting).
@item -s
@itemx --
The global variable @samp{command-line-arguments} is set to the remaining
arguments (if any), and an interactive read-eval-print loop is started.
@end table

If there are further command-line arguments after the options
have been processed, then the first remaining argument names a
file that is read and evaluated.  If there is no such argument,
then Kawa enters an interactive read-eval-print loop,
but only if none of the @samp{-c}, @samp{-e}, @samp{-f}, @samp{-s},
or @samp{--} options were specified.

@defvar command-line-arguments
The remaining arguments (following any switches processed by Kawa itself)
are assigned to the global variable @samp{command-line-arguments},
which is a vector of strings.
@end defvar

@node Restrictions, Extensions, Running, Top
@section Features of R4RS not implemented

The file Compliance.html specifies which functions and syntax
have been implemented so far.

Of the "numeric tower", only integers and double-precision
floats are implemented.  There is partial bignum support,
but many operations are only available for 32-bit
(or sometimes 64-bit) fixnums.
Integral function do not necessarily work on
inexact (floating-point) integers.
(The whole idea of "inexact integer" in R4RS seems rather pointless ...)

Also, call-with-current-continuation is only "upwards" (?).
I.e. once a continuation has been exited, it cannot be invoked.
These restricted continuations can be used to implement catch/throw
(such as the examples in R4RS), but not co-routines or backtracking.

Kawa does not do general tail-call elimination.  However, if the
compiler can prove that the procedure being called is the current
function, then the tail call will be replaced by a jump.
This means the procedure must be defined using a letrec, not a
define (because the compiler does not know if someone might
re-define a global definition), and there must be no assignments
(using @code{set!}) to the procedure binding.

@node Extensions, Compiling, Restrictions, Top
@section Extensions

@subsection Multiple values

@defun values object ...
Delivers all of its arguments to its continuation.
@end defun

@defun call-with-values thunk receiver
Call its @var{thunk} argument with a continuation that,
when passed some values, calls the @var{receiver} procedure
with those values as arguments.
@end defun

@subsection Ports

@defun call-with-input-string string proc
Create an input port that gets its data from @var{string},
call @var{proc} with that port as its one argument, and return
the result from the call of @var{proc}
@end defun

@defun call-with-output-string proc
Create an output port that writes its data to a @var{string},
and call @var{proc} with that port as its one argument.
Return a string consisting of the data written to the port.
@end defun

@subsection Eval and Environments

@defun eval expression [environment-specifier]
@code{eval} evaluates @var{expression} in the environment indicated
by @var{environment-specifier}.

The default for @var{environment-specifier} is the result
of @code{(interaction-environment)}.
@end defun

@defun null-environment
This procedure returns an environment that contains no variable bindings,
but contains (syntactic) bindings for all the syntactic keywords.

The effect of assigning to a variable in this environment (such
as @code{let}) is undefined.
@end defun

@defun scheme-report-environment version
The @var{version} must be an exact non-negative inetger corresponding to
a version of one of the Revised@var{version} Reports on Scheme.
The procedure returns an environment that contains exactly the set of
bindings specified in the corresponding report.

This implementation supports @var{version} that is 4 or 5.

The effect of assigning to a variable in this environment (such
as @code{car}) is undefined.
@end defun

@defun interaction-environment
This procedure return an environment that contains implementation-defined
bindings, as well as top-level user bindings.
@end defun

@subsection Miscellaneous

@defun exit [code]
Exits the Kawa interpreter, and ends the Java session.
The integer value @var{code} is returned to the operating
system.  If @var{code} is not specified, zero is returned,
indicating normal (non-error) termination.
@end defun

@defmac when condition form...
If @var{condition} is true, evaluate each @var{form} in order,
returning the value of the last one.
@end defmac

@defmac unless condition form...
If @var{condition} is false, evaluate each @var{form} in order,
returning the value of the last one.
@end defmac

@defun arithmetic-shift i j
Shifts @var{i} by @var{j}.
It is a "left" shift if @code{@var{j}>0}, and
a "right" shift if @code{@var{j}<0}.

The result is equal to @code{(floor (* @var{i} (expt 2 @var{j})))}.
@end defun

@defun vector-append @var{arg}...
Creates a new vector, containing the elements from all the @var{arg}s
appended together.   Each @var{arg} may be a vector or a list.
@end defun

@node Compiling, Primitive functions, Extensions, Top
@section Compiling Scheme code to byte-codes

All Scheme functions and source files are invisibly compiled
into internal Java byte-codes.
A traditional evaluator is only used for top-level directly entered
expressions @emph{outside} a lambda.  (It would have been simpler
to also byte-compile top-level expressions by surrounding them
by a dummy lambda.  However, this would create a new Class object
in the Java VM for every top-level expression.  This is undesirable
unless you have a VM that can garbage collect Class objects.
Sun's VM currently does not, but that is planned for JDK 1.1.)

To save speed when loading large Scheme source files, you probably
want to pre-compile them and save them on your local disk.
There are two ways to do this.

You can compile a Scheme source file to a single archive file.
You do this using the @code{compile-file} function.
The result is a single file that you can move around @code{load}
just like the @code{.scm} source file.  You just specify the name
of the archive file to the @code{load} procedure.
Currently, the archive is a "zip" archive and has extension ".zip";
a future release will probably use "Java Archive" (jar) files,
once support from that has been released from JavaSoft.
The advantage of compiling to an archive is that it is simple
and transparent.  A disadvantage is that it causes the
Java "verifier" to be run when functions are loaded from it,
which takes a little extra time.

Alternatively, you can compile a Scheme source file to a
collection of @samp{.class} files using the stand-alone
@samp{kawac} application.
You then use the standard Java class loading mechanism to load the code.
The Java "verifier" does not need to get run, which makes
loading a little faster.
The compiled class files do have to be installed be installed somewhere
in the @code{CLASSPATH}.

@menu
* Archive compilation::         Compiling Scheme to an archive file
* Files compilation::           Compiling Scheme to a set of .class files
@end menu

@node Archive compilation, Files compilation, Compiling, Compiling
@subsection Compiling Scheme to an archive file

To byte-compile a file @samp{foo.scm} do:
@example
(compile-file "foo.scm" "foo")
@end example

This will create @samp{foo.zip}, which contains byte-compiled "j-code"
that implements @samp{foo.scm}.

You can later do:
@example
(load "foo")
@end example

This will load @samp{foo.zip}, which should have the same effect as
loading @samp{foo.scm}, except you will get the byte-compiled versions.

@node Files compilation,  , Archive compilation, Compiling
@subsection Compiling Scheme to a set of .class files

The @samp{kawac} will compile a @samp{.scm} source file into one or
more @samp{.class} files.

You run it as follows:
@example
java kawac infile [-d outdirectory] [prefix [topname]]
@end example

Here:
@table @var
@item infile
The Scheme source file we want to compile.
@item @samp{-d} outdirectory
The directory under which the resulting @samp{.class} files will be.
The default is the current directory.
@item prefix
A string to prepend to the generated class names.
The default is the empty string.
@item topname
The name of the "top" class - i.e. the one that contains the code
for the top-level expressions and definitions.
The default is generated from the @var{infile} and @var{prefix}.
@end table

When you actually want to load the classes, the @var{outdirectory}
must be in your @samp{CLASSPATH}.
You can use the standard @code{load} function to load the code,
by specifying the top-level class, either as a file name
(relative to @var{outdirectory}) or a class name.
E.g. if you did:
@example
java kawac foosrc.scm -d /usr/local/java my.lib. foo     
@end example
you can use either:
@example
(load "my.lib.foo")
@end example
or:
@example
(load "my/lib/foo.class")
@end example

@node Primitive functions, Reporting Bugs, Compiling, Top
@section Writing new "primitive" Scheme functions in Java

@subsection Scheme types in Java

All Scheme values are implemented by sub-classes of @samp{java.lang.Object}.

Scheme symbols are implemented by @code{kawa.lang.Symbol}.
Use the @samp{make} static method to create a new (interned) symbol.

Scheme integers are implemented by @code{kawa.math.IntNum}.
Use the make static function to create a new IntNum from an int or a long.
Use the intValue or longValue methods to get the int or long value of
an IntNum.  There is partial support for bignums.

A Scheme "flonum" is implemented by @code{kawa.math.DFloNum}.

A Scheme pair is implemented by @code{kawa.lang.Pair}.

A Scheme vector is implemented by @code{kawa.lang.Vector}.

Scheme characters are implemented using @code{kawa.lang.Char}.

Scheme strings are @emph{currently} implemented using
@code{java.lang.StringBuffer}.  This will probably be
changed to use a new sub-class of @code{kawa.lang.Sequence}.

Scheme procedures are all sub-classes of @code{kawa.lang.Procedure}.
Normally each function (lambda expression) in the source code is
compiled to a separate sub-class of @samp{Procedure}.
The "action" of a @samp{Procedure} is invoked by using one of
the @samp{apply*} methods:  @samp{apply0}, @samp{apply1},
@samp{apply2}, @samp{apply3}, @samp{apply4}, or @samp{applyN}.
Various sub-class of @samp{Procedure} provide defaults
for the various @samp{apply*} methods.  For example,
a @samp{Procedure2} is used by 2-argument procedures.
The @samp{Procedure2} class provides implementations of all
the @samp{apply*} methods @emph{except} @samp{apply2},
which must be provided by any class that extends @code{Procedure2}.

A function that does some initialization and makes definitions
should probably be written as a @code{ModuleBody}.
A @code{ModuleBody} is a sub-class of @code{Procedure0}.
It must therefore define an @samp{apply0} method;  that is where
you can put definitions.  A @code{ModuleBody} can be loaded
using the Scheme @samp{load} procedure.

You can define new bindings in the top-level environment
using the @code{define_global} method in @code{kawa.lang.Interpreter}.
For example:
@example
   Interpreter.define_global (Symbol.make ("pi"),
                              new DFloNum (java.lang.Math.PI));
@end example

The various Kawa classes may be shuffled around some in the future.
It is quite likely they will not remain in the package @samp{kawa.lang},
so you should probably use @code{import} statements rather than
fully-qualified class names to refer to Kawa classes.

@node Reporting Bugs, License, Primitive functions, Top
@section Reporting Bugs

If you have a problem installing or using Kawa,
send mail to @code{kawa@@cygnus.com}

This mailing list is used for reporting bugs, patches, discussing
changes to Kawa, and announcing snapshots.  If you wish to subscribe
(or later unsubscribe), send a request to @code{kawa-request@@cygnus.com}.

@node License,  , Reporting Bugs, Top
@section License

@include license.terms

@bye
